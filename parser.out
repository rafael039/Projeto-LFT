Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DOUBLEQUOTE
    EXIT
    SINGLEQUOTE
    SPACE
    UMINUS
    WHEN

Grammar

Rule 0     S' -> program
Rule 1     program -> PROCEDURE ID IS decl body
Rule 2     program -> PROCEDURE ID IS body
Rule 3     subprogram -> FUNCTION ID decl_param IS decl body
Rule 4     subprogram -> FUNCTION ID decl_param IS body
Rule 5     body -> BEGIN cmd_loop END ID SEMICOLON
Rule 6     decl -> var SEMICOLON decl_loop
Rule 7     decl -> subprogram decl_loop
Rule 8     decl_loop -> subprogram decl_loop
Rule 9     decl_loop -> subprogram
Rule 10    decl_loop -> var SEMICOLON decl_loop
Rule 11    decl_loop -> var SEMICOLON
Rule 12    var -> ID COMMA TYPE ASSIGN value
Rule 13    var -> ID COLON TYPE
Rule 14    var -> var_loop ID COLON TYPE
Rule 15    var -> array
Rule 16    var_loop -> var_loop ID COMMA
Rule 17    var_loop -> ID COMMA
Rule 18    decl_param -> LPAREN param RPAREN
Rule 19    decl_param -> LPAREN param RPAREN RETURN TYPE
Rule 20    param -> ID COLON TYPE n_param
Rule 21    n_param -> SEMICOLON ID COLON TYPE n_param
Rule 22    n_param -> SEMICOLON ID COLON TYPE
Rule 23    function_call -> ID LPAREN param_pass RPAREN SEMICOLON
Rule 24    function_call_exp -> ID LPAREN param_pass RPAREN
Rule 25    param_pass -> expression param_pass_loop
Rule 26    param_pass -> op_arithmetic param_pass_loop
Rule 27    param_pass_loop -> SEMICOLON expression param_pass_loop
Rule 28    param_pass_loop -> SEMICOLON op_arithmetic param_pass_loop
Rule 29    param_pass_loop -> SEMICOLON expression
Rule 30    param_pass_loop -> SEMICOLON op_arithmetic
Rule 31    value -> NUMBER_INT
Rule 32    value -> NUMBER_FLOAT
Rule 33    value -> NUMBER_EXPONENT
Rule 34    value -> BOOLEAN
Rule 35    value -> STRING
Rule 36    value -> CHAR
Rule 37    cmd -> if_statement
Rule 38    cmd -> repeat_statement
Rule 39    cmd -> puts
Rule 40    cmd -> return
Rule 41    cmd -> assign
Rule 42    cmd -> function_call
Rule 43    cmd_loop -> cmd_loop cmd
Rule 44    cmd_loop -> cmd
Rule 45    puts -> PUTS LPAREN STRING RPAREN SEMICOLON
Rule 46    if_statement -> IF expression THEN cmd_loop if_statement_loop
Rule 47    if_statement_loop -> ELSIF expression cmd_loop if_statement_loop
Rule 48    if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON
Rule 49    if_statement_loop -> END IF SEMICOLON
Rule 50    repeat_statement -> loop_statement
Rule 51    repeat_statement -> for_statement
Rule 52    repeat_statement -> while_statement
Rule 53    loop_statement -> LOOP cmd_loop END LOOP
Rule 54    while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON
Rule 55    for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
Rule 56    range -> ID DOTDOT ID
Rule 57    assign -> ID ASSIGN op_arithmetic SEMICOLON
Rule 58    expression -> expression AND or_exp
Rule 59    expression -> or_exp
Rule 60    or_exp -> or_exp OR comp_exp
Rule 61    or_exp -> comp_exp
Rule 62    comp_exp -> comp_exp comp_op bparen
Rule 63    comp_exp -> bparen
Rule 64    bparen -> LPAREN expression RPAREN
Rule 65    bparen -> term
Rule 66    comp_op -> GREATERTHAN
Rule 67    comp_op -> GREATERTHANEQUAL
Rule 68    comp_op -> LESSTHAN
Rule 69    comp_op -> LESSTHANEQUAL
Rule 70    comp_op -> NOTEQUAL
Rule 71    comp_op -> EQUAL
Rule 72    op_arithmetic -> op_arithmetic PLUS factor
Rule 73    op_arithmetic -> op_arithmetic MINUS factor
Rule 74    op_arithmetic -> factor
Rule 75    factor -> factor TIMES power
Rule 76    factor -> factor DIVIDE power
Rule 77    factor -> power
Rule 78    power -> power POWER paren
Rule 79    power -> paren
Rule 80    paren -> LPAREN op_arithmetic RPAREN
Rule 81    paren -> term
Rule 82    term -> ID
Rule 83    term -> function_call_exp
Rule 84    array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON
Rule 85    return -> RETURN expression
Rule 86    return -> RETURN op_arithmetic

Terminals, with rules where they appear

AND                  : 58
ARRAY                : 84
ASSIGN               : 12 57
BEGIN                : 5
BOOLEAN              : 34
CHAR                 : 36
COLON                : 13 14 20 21 22
COMMA                : 12 16 17
COMMENT              : 
DIVIDE               : 76
DOTDOT               : 56
DOUBLEQUOTE          : 
ELSE                 : 48
ELSIF                : 47
END                  : 5 48 49 53 54 55
EQUAL                : 71
EXIT                 : 
FOR                  : 55
FUNCTION             : 3 4
GREATERTHAN          : 66
GREATERTHANEQUAL     : 67
ID                   : 1 2 3 4 5 12 13 14 16 17 20 21 22 23 24 55 56 56 57 82 84
IF                   : 46 48 49
IN                   : 55
IS                   : 1 2 3 4 84
LESSTHAN             : 68
LESSTHANEQUAL        : 69
LOOP                 : 53 53 54 54 55 55
LPAREN               : 18 19 23 24 45 64 80 84
MINUS                : 73
NOTEQUAL             : 70
NUMBER_EXPONENT      : 33
NUMBER_FLOAT         : 32
NUMBER_INT           : 31 54
OF                   : 84
OR                   : 60
PLUS                 : 72
POWER                : 78
PROCEDURE            : 1 2
PUTS                 : 45
RETURN               : 19 85 86
RPAREN               : 18 19 23 24 45 64 80 84
SEMICOLON            : 5 6 10 11 21 22 23 27 28 29 30 45 48 49 54 55 57 84
SINGLEQUOTE          : 
SPACE                : 
STRING               : 35 45
THEN                 : 46
TIMES                : 75
TYPE                 : 12 13 14 19 20 21 22 84 84
UMINUS               : 
WHEN                 : 
WHILE                : 54
error                : 

Nonterminals, with rules where they appear

array                : 15
assign               : 41
body                 : 1 2 3 4
bparen               : 62 63
cmd                  : 43 44
cmd_loop             : 5 43 46 47 48 53 54 55
comp_exp             : 60 61 62
comp_op              : 62
decl                 : 1 3
decl_loop            : 6 7 8 10
decl_param           : 3 4
expression           : 25 27 29 46 47 48 54 58 64 85
factor               : 72 73 74 75 76
for_statement        : 51
function_call        : 42
function_call_exp    : 83
if_statement         : 37
if_statement_loop    : 46 47
loop_statement       : 50
n_param              : 20 21
op_arithmetic        : 26 28 30 57 72 73 80 86
or_exp               : 58 59 60
param                : 18 19
param_pass           : 23 24
param_pass_loop      : 25 26 27 28
paren                : 78 79
power                : 75 76 77 78
program              : 0
puts                 : 39
range                : 55 84
repeat_statement     : 38
return               : 40
subprogram           : 7 8 9
term                 : 65 81
value                : 12
var                  : 6 10 11
var_loop             : 14 16
while_statement      : 52

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROCEDURE ID IS decl body
    (2) program -> . PROCEDURE ID IS body

    PROCEDURE       shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROCEDURE . ID IS decl body
    (2) program -> PROCEDURE . ID IS body

    ID              shift and go to state 3


state 3

    (1) program -> PROCEDURE ID . IS decl body
    (2) program -> PROCEDURE ID . IS body

    IS              shift and go to state 4


state 4

    (1) program -> PROCEDURE ID IS . decl body
    (2) program -> PROCEDURE ID IS . body
    (6) decl -> . var SEMICOLON decl_loop
    (7) decl -> . subprogram decl_loop
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON
    (12) var -> . ID COMMA TYPE ASSIGN value
    (13) var -> . ID COLON TYPE
    (14) var -> . var_loop ID COLON TYPE
    (15) var -> . array
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (16) var_loop -> . var_loop ID COMMA
    (17) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           shift and go to state 10
    ID              shift and go to state 5
    FUNCTION        shift and go to state 14
    TYPE            shift and go to state 11

    decl                           shift and go to state 6
    body                           shift and go to state 7
    var                            shift and go to state 8
    subprogram                     shift and go to state 9
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 5

    (12) var -> ID . COMMA TYPE ASSIGN value
    (13) var -> ID . COLON TYPE
    (17) var_loop -> ID . COMMA

    COMMA           shift and go to state 15
    COLON           shift and go to state 16


state 6

    (1) program -> PROCEDURE ID IS decl . body
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 10

    body                           shift and go to state 17

state 7

    (2) program -> PROCEDURE ID IS body .

    $end            reduce using rule 2 (program -> PROCEDURE ID IS body .)


state 8

    (6) decl -> var . SEMICOLON decl_loop

    SEMICOLON       shift and go to state 18


state 9

    (7) decl -> subprogram . decl_loop
    (8) decl_loop -> . subprogram decl_loop
    (9) decl_loop -> . subprogram
    (10) decl_loop -> . var SEMICOLON decl_loop
    (11) decl_loop -> . var SEMICOLON
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (12) var -> . ID COMMA TYPE ASSIGN value
    (13) var -> . ID COLON TYPE
    (14) var -> . var_loop ID COLON TYPE
    (15) var -> . array
    (16) var_loop -> . var_loop ID COMMA
    (17) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    FUNCTION        shift and go to state 14
    ID              shift and go to state 5
    TYPE            shift and go to state 11

    subprogram                     shift and go to state 19
    decl_loop                      shift and go to state 20
    var                            shift and go to state 21
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 10

    (5) body -> BEGIN . cmd_loop END ID SEMICOLON
    (43) cmd_loop -> . cmd_loop cmd
    (44) cmd_loop -> . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd_loop                       shift and go to state 22
    cmd                            shift and go to state 24
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 11

    (84) array -> TYPE . ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    ID              shift and go to state 40


state 12

    (14) var -> var_loop . ID COLON TYPE
    (16) var_loop -> var_loop . ID COMMA

    ID              shift and go to state 41


state 13

    (15) var -> array .

    SEMICOLON       reduce using rule 15 (var -> array .)


state 14

    (3) subprogram -> FUNCTION . ID decl_param IS decl body
    (4) subprogram -> FUNCTION . ID decl_param IS body

    ID              shift and go to state 42


state 15

    (12) var -> ID COMMA . TYPE ASSIGN value
    (17) var_loop -> ID COMMA .

    TYPE            shift and go to state 43
    ID              reduce using rule 17 (var_loop -> ID COMMA .)


state 16

    (13) var -> ID COLON . TYPE

    TYPE            shift and go to state 44


state 17

    (1) program -> PROCEDURE ID IS decl body .

    $end            reduce using rule 1 (program -> PROCEDURE ID IS decl body .)


state 18

    (6) decl -> var SEMICOLON . decl_loop
    (8) decl_loop -> . subprogram decl_loop
    (9) decl_loop -> . subprogram
    (10) decl_loop -> . var SEMICOLON decl_loop
    (11) decl_loop -> . var SEMICOLON
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (12) var -> . ID COMMA TYPE ASSIGN value
    (13) var -> . ID COLON TYPE
    (14) var -> . var_loop ID COLON TYPE
    (15) var -> . array
    (16) var_loop -> . var_loop ID COMMA
    (17) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    FUNCTION        shift and go to state 14
    ID              shift and go to state 5
    TYPE            shift and go to state 11

    var                            shift and go to state 21
    decl_loop                      shift and go to state 45
    subprogram                     shift and go to state 19
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 19

    (8) decl_loop -> subprogram . decl_loop
    (9) decl_loop -> subprogram .
    (8) decl_loop -> . subprogram decl_loop
    (9) decl_loop -> . subprogram
    (10) decl_loop -> . var SEMICOLON decl_loop
    (11) decl_loop -> . var SEMICOLON
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (12) var -> . ID COMMA TYPE ASSIGN value
    (13) var -> . ID COLON TYPE
    (14) var -> . var_loop ID COLON TYPE
    (15) var -> . array
    (16) var_loop -> . var_loop ID COMMA
    (17) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           reduce using rule 9 (decl_loop -> subprogram .)
    FUNCTION        shift and go to state 14
    ID              shift and go to state 5
    TYPE            shift and go to state 11

    subprogram                     shift and go to state 19
    decl_loop                      shift and go to state 46
    var                            shift and go to state 21
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 20

    (7) decl -> subprogram decl_loop .

    BEGIN           reduce using rule 7 (decl -> subprogram decl_loop .)


state 21

    (10) decl_loop -> var . SEMICOLON decl_loop
    (11) decl_loop -> var . SEMICOLON

    SEMICOLON       shift and go to state 47


state 22

    (5) body -> BEGIN cmd_loop . END ID SEMICOLON
    (43) cmd_loop -> cmd_loop . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 48
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd                            shift and go to state 49
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 23

    (57) assign -> ID . ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> ID . LPAREN param_pass RPAREN SEMICOLON

    ASSIGN          shift and go to state 50
    LPAREN          shift and go to state 51


state 24

    (44) cmd_loop -> cmd .

    END             reduce using rule 44 (cmd_loop -> cmd .)
    IF              reduce using rule 44 (cmd_loop -> cmd .)
    PUTS            reduce using rule 44 (cmd_loop -> cmd .)
    RETURN          reduce using rule 44 (cmd_loop -> cmd .)
    ID              reduce using rule 44 (cmd_loop -> cmd .)
    LOOP            reduce using rule 44 (cmd_loop -> cmd .)
    FOR             reduce using rule 44 (cmd_loop -> cmd .)
    WHILE           reduce using rule 44 (cmd_loop -> cmd .)
    ELSIF           reduce using rule 44 (cmd_loop -> cmd .)
    ELSE            reduce using rule 44 (cmd_loop -> cmd .)


state 25

    (37) cmd -> if_statement .

    END             reduce using rule 37 (cmd -> if_statement .)
    IF              reduce using rule 37 (cmd -> if_statement .)
    PUTS            reduce using rule 37 (cmd -> if_statement .)
    RETURN          reduce using rule 37 (cmd -> if_statement .)
    ID              reduce using rule 37 (cmd -> if_statement .)
    LOOP            reduce using rule 37 (cmd -> if_statement .)
    FOR             reduce using rule 37 (cmd -> if_statement .)
    WHILE           reduce using rule 37 (cmd -> if_statement .)
    ELSIF           reduce using rule 37 (cmd -> if_statement .)
    ELSE            reduce using rule 37 (cmd -> if_statement .)


state 26

    (38) cmd -> repeat_statement .

    END             reduce using rule 38 (cmd -> repeat_statement .)
    IF              reduce using rule 38 (cmd -> repeat_statement .)
    PUTS            reduce using rule 38 (cmd -> repeat_statement .)
    RETURN          reduce using rule 38 (cmd -> repeat_statement .)
    ID              reduce using rule 38 (cmd -> repeat_statement .)
    LOOP            reduce using rule 38 (cmd -> repeat_statement .)
    FOR             reduce using rule 38 (cmd -> repeat_statement .)
    WHILE           reduce using rule 38 (cmd -> repeat_statement .)
    ELSIF           reduce using rule 38 (cmd -> repeat_statement .)
    ELSE            reduce using rule 38 (cmd -> repeat_statement .)


state 27

    (39) cmd -> puts .

    END             reduce using rule 39 (cmd -> puts .)
    IF              reduce using rule 39 (cmd -> puts .)
    PUTS            reduce using rule 39 (cmd -> puts .)
    RETURN          reduce using rule 39 (cmd -> puts .)
    ID              reduce using rule 39 (cmd -> puts .)
    LOOP            reduce using rule 39 (cmd -> puts .)
    FOR             reduce using rule 39 (cmd -> puts .)
    WHILE           reduce using rule 39 (cmd -> puts .)
    ELSIF           reduce using rule 39 (cmd -> puts .)
    ELSE            reduce using rule 39 (cmd -> puts .)


state 28

    (40) cmd -> return .

    END             reduce using rule 40 (cmd -> return .)
    IF              reduce using rule 40 (cmd -> return .)
    PUTS            reduce using rule 40 (cmd -> return .)
    RETURN          reduce using rule 40 (cmd -> return .)
    ID              reduce using rule 40 (cmd -> return .)
    LOOP            reduce using rule 40 (cmd -> return .)
    FOR             reduce using rule 40 (cmd -> return .)
    WHILE           reduce using rule 40 (cmd -> return .)
    ELSIF           reduce using rule 40 (cmd -> return .)
    ELSE            reduce using rule 40 (cmd -> return .)


state 29

    (41) cmd -> assign .

    END             reduce using rule 41 (cmd -> assign .)
    IF              reduce using rule 41 (cmd -> assign .)
    PUTS            reduce using rule 41 (cmd -> assign .)
    RETURN          reduce using rule 41 (cmd -> assign .)
    ID              reduce using rule 41 (cmd -> assign .)
    LOOP            reduce using rule 41 (cmd -> assign .)
    FOR             reduce using rule 41 (cmd -> assign .)
    WHILE           reduce using rule 41 (cmd -> assign .)
    ELSIF           reduce using rule 41 (cmd -> assign .)
    ELSE            reduce using rule 41 (cmd -> assign .)


state 30

    (42) cmd -> function_call .

    END             reduce using rule 42 (cmd -> function_call .)
    IF              reduce using rule 42 (cmd -> function_call .)
    PUTS            reduce using rule 42 (cmd -> function_call .)
    RETURN          reduce using rule 42 (cmd -> function_call .)
    ID              reduce using rule 42 (cmd -> function_call .)
    LOOP            reduce using rule 42 (cmd -> function_call .)
    FOR             reduce using rule 42 (cmd -> function_call .)
    WHILE           reduce using rule 42 (cmd -> function_call .)
    ELSIF           reduce using rule 42 (cmd -> function_call .)
    ELSE            reduce using rule 42 (cmd -> function_call .)


state 31

    (46) if_statement -> IF . expression THEN cmd_loop if_statement_loop
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    expression                     shift and go to state 52
    or_exp                         shift and go to state 53
    comp_exp                       shift and go to state 54
    bparen                         shift and go to state 55
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 32

    (50) repeat_statement -> loop_statement .

    END             reduce using rule 50 (repeat_statement -> loop_statement .)
    IF              reduce using rule 50 (repeat_statement -> loop_statement .)
    PUTS            reduce using rule 50 (repeat_statement -> loop_statement .)
    RETURN          reduce using rule 50 (repeat_statement -> loop_statement .)
    ID              reduce using rule 50 (repeat_statement -> loop_statement .)
    LOOP            reduce using rule 50 (repeat_statement -> loop_statement .)
    FOR             reduce using rule 50 (repeat_statement -> loop_statement .)
    WHILE           reduce using rule 50 (repeat_statement -> loop_statement .)
    ELSIF           reduce using rule 50 (repeat_statement -> loop_statement .)
    ELSE            reduce using rule 50 (repeat_statement -> loop_statement .)


state 33

    (51) repeat_statement -> for_statement .

    END             reduce using rule 51 (repeat_statement -> for_statement .)
    IF              reduce using rule 51 (repeat_statement -> for_statement .)
    PUTS            reduce using rule 51 (repeat_statement -> for_statement .)
    RETURN          reduce using rule 51 (repeat_statement -> for_statement .)
    ID              reduce using rule 51 (repeat_statement -> for_statement .)
    LOOP            reduce using rule 51 (repeat_statement -> for_statement .)
    FOR             reduce using rule 51 (repeat_statement -> for_statement .)
    WHILE           reduce using rule 51 (repeat_statement -> for_statement .)
    ELSIF           reduce using rule 51 (repeat_statement -> for_statement .)
    ELSE            reduce using rule 51 (repeat_statement -> for_statement .)


state 34

    (52) repeat_statement -> while_statement .

    END             reduce using rule 52 (repeat_statement -> while_statement .)
    IF              reduce using rule 52 (repeat_statement -> while_statement .)
    PUTS            reduce using rule 52 (repeat_statement -> while_statement .)
    RETURN          reduce using rule 52 (repeat_statement -> while_statement .)
    ID              reduce using rule 52 (repeat_statement -> while_statement .)
    LOOP            reduce using rule 52 (repeat_statement -> while_statement .)
    FOR             reduce using rule 52 (repeat_statement -> while_statement .)
    WHILE           reduce using rule 52 (repeat_statement -> while_statement .)
    ELSIF           reduce using rule 52 (repeat_statement -> while_statement .)
    ELSE            reduce using rule 52 (repeat_statement -> while_statement .)


state 35

    (45) puts -> PUTS . LPAREN STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 60


state 36

    (85) return -> RETURN . expression
    (86) return -> RETURN . op_arithmetic
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (72) op_arithmetic -> . op_arithmetic PLUS factor
    (73) op_arithmetic -> . op_arithmetic MINUS factor
    (74) op_arithmetic -> . factor
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (78) power -> . power POWER paren
    (79) power -> . paren
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 66
    ID              shift and go to state 58

    expression                     shift and go to state 61
    op_arithmetic                  shift and go to state 62
    or_exp                         shift and go to state 53
    factor                         shift and go to state 63
    comp_exp                       shift and go to state 54
    power                          shift and go to state 64
    bparen                         shift and go to state 55
    paren                          shift and go to state 65
    term                           shift and go to state 67
    function_call_exp              shift and go to state 59

state 37

    (53) loop_statement -> LOOP . cmd_loop END LOOP
    (43) cmd_loop -> . cmd_loop cmd
    (44) cmd_loop -> . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd_loop                       shift and go to state 68
    cmd                            shift and go to state 24
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 38

    (55) for_statement -> FOR . ID IN range LOOP cmd_loop END LOOP SEMICOLON

    ID              shift and go to state 69


state 39

    (54) while_statement -> WHILE . expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    expression                     shift and go to state 70
    or_exp                         shift and go to state 53
    comp_exp                       shift and go to state 54
    bparen                         shift and go to state 55
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 40

    (84) array -> TYPE ID . IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    IS              shift and go to state 71


state 41

    (14) var -> var_loop ID . COLON TYPE
    (16) var_loop -> var_loop ID . COMMA

    COLON           shift and go to state 72
    COMMA           shift and go to state 73


state 42

    (3) subprogram -> FUNCTION ID . decl_param IS decl body
    (4) subprogram -> FUNCTION ID . decl_param IS body
    (18) decl_param -> . LPAREN param RPAREN
    (19) decl_param -> . LPAREN param RPAREN RETURN TYPE

    LPAREN          shift and go to state 75

    decl_param                     shift and go to state 74

state 43

    (12) var -> ID COMMA TYPE . ASSIGN value

    ASSIGN          shift and go to state 76


state 44

    (13) var -> ID COLON TYPE .

    SEMICOLON       reduce using rule 13 (var -> ID COLON TYPE .)


state 45

    (6) decl -> var SEMICOLON decl_loop .

    BEGIN           reduce using rule 6 (decl -> var SEMICOLON decl_loop .)


state 46

    (8) decl_loop -> subprogram decl_loop .

    BEGIN           reduce using rule 8 (decl_loop -> subprogram decl_loop .)


state 47

    (10) decl_loop -> var SEMICOLON . decl_loop
    (11) decl_loop -> var SEMICOLON .
    (8) decl_loop -> . subprogram decl_loop
    (9) decl_loop -> . subprogram
    (10) decl_loop -> . var SEMICOLON decl_loop
    (11) decl_loop -> . var SEMICOLON
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (12) var -> . ID COMMA TYPE ASSIGN value
    (13) var -> . ID COLON TYPE
    (14) var -> . var_loop ID COLON TYPE
    (15) var -> . array
    (16) var_loop -> . var_loop ID COMMA
    (17) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           reduce using rule 11 (decl_loop -> var SEMICOLON .)
    FUNCTION        shift and go to state 14
    ID              shift and go to state 5
    TYPE            shift and go to state 11

    var                            shift and go to state 21
    decl_loop                      shift and go to state 77
    subprogram                     shift and go to state 19
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 48

    (5) body -> BEGIN cmd_loop END . ID SEMICOLON

    ID              shift and go to state 78


state 49

    (43) cmd_loop -> cmd_loop cmd .

    END             reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    IF              reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    PUTS            reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    RETURN          reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    ID              reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    LOOP            reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    FOR             reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    WHILE           reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    ELSIF           reduce using rule 43 (cmd_loop -> cmd_loop cmd .)
    ELSE            reduce using rule 43 (cmd_loop -> cmd_loop cmd .)


state 50

    (57) assign -> ID ASSIGN . op_arithmetic SEMICOLON
    (72) op_arithmetic -> . op_arithmetic PLUS factor
    (73) op_arithmetic -> . op_arithmetic MINUS factor
    (74) op_arithmetic -> . factor
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (78) power -> . power POWER paren
    (79) power -> . paren
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 80
    ID              shift and go to state 58

    op_arithmetic                  shift and go to state 79
    factor                         shift and go to state 63
    power                          shift and go to state 64
    paren                          shift and go to state 65
    term                           shift and go to state 81
    function_call_exp              shift and go to state 59

state 51

    (23) function_call -> ID LPAREN . param_pass RPAREN SEMICOLON
    (25) param_pass -> . expression param_pass_loop
    (26) param_pass -> . op_arithmetic param_pass_loop
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (72) op_arithmetic -> . op_arithmetic PLUS factor
    (73) op_arithmetic -> . op_arithmetic MINUS factor
    (74) op_arithmetic -> . factor
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (78) power -> . power POWER paren
    (79) power -> . paren
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 66
    ID              shift and go to state 58

    param_pass                     shift and go to state 82
    expression                     shift and go to state 83
    op_arithmetic                  shift and go to state 84
    or_exp                         shift and go to state 53
    factor                         shift and go to state 63
    comp_exp                       shift and go to state 54
    power                          shift and go to state 64
    bparen                         shift and go to state 55
    paren                          shift and go to state 65
    term                           shift and go to state 67
    function_call_exp              shift and go to state 59

state 52

    (46) if_statement -> IF expression . THEN cmd_loop if_statement_loop
    (58) expression -> expression . AND or_exp

    THEN            shift and go to state 85
    AND             shift and go to state 86


state 53

    (59) expression -> or_exp .
    (60) or_exp -> or_exp . OR comp_exp

    THEN            reduce using rule 59 (expression -> or_exp .)
    AND             reduce using rule 59 (expression -> or_exp .)
    END             reduce using rule 59 (expression -> or_exp .)
    IF              reduce using rule 59 (expression -> or_exp .)
    PUTS            reduce using rule 59 (expression -> or_exp .)
    RETURN          reduce using rule 59 (expression -> or_exp .)
    ID              reduce using rule 59 (expression -> or_exp .)
    LOOP            reduce using rule 59 (expression -> or_exp .)
    FOR             reduce using rule 59 (expression -> or_exp .)
    WHILE           reduce using rule 59 (expression -> or_exp .)
    ELSIF           reduce using rule 59 (expression -> or_exp .)
    ELSE            reduce using rule 59 (expression -> or_exp .)
    NUMBER_INT      reduce using rule 59 (expression -> or_exp .)
    SEMICOLON       reduce using rule 59 (expression -> or_exp .)
    RPAREN          reduce using rule 59 (expression -> or_exp .)
    OR              shift and go to state 87


state 54

    (61) or_exp -> comp_exp .
    (62) comp_exp -> comp_exp . comp_op bparen
    (66) comp_op -> . GREATERTHAN
    (67) comp_op -> . GREATERTHANEQUAL
    (68) comp_op -> . LESSTHAN
    (69) comp_op -> . LESSTHANEQUAL
    (70) comp_op -> . NOTEQUAL
    (71) comp_op -> . EQUAL

    OR              reduce using rule 61 (or_exp -> comp_exp .)
    THEN            reduce using rule 61 (or_exp -> comp_exp .)
    AND             reduce using rule 61 (or_exp -> comp_exp .)
    END             reduce using rule 61 (or_exp -> comp_exp .)
    IF              reduce using rule 61 (or_exp -> comp_exp .)
    PUTS            reduce using rule 61 (or_exp -> comp_exp .)
    RETURN          reduce using rule 61 (or_exp -> comp_exp .)
    ID              reduce using rule 61 (or_exp -> comp_exp .)
    LOOP            reduce using rule 61 (or_exp -> comp_exp .)
    FOR             reduce using rule 61 (or_exp -> comp_exp .)
    WHILE           reduce using rule 61 (or_exp -> comp_exp .)
    ELSIF           reduce using rule 61 (or_exp -> comp_exp .)
    ELSE            reduce using rule 61 (or_exp -> comp_exp .)
    NUMBER_INT      reduce using rule 61 (or_exp -> comp_exp .)
    SEMICOLON       reduce using rule 61 (or_exp -> comp_exp .)
    RPAREN          reduce using rule 61 (or_exp -> comp_exp .)
    GREATERTHAN     shift and go to state 89
    GREATERTHANEQUAL shift and go to state 90
    LESSTHAN        shift and go to state 91
    LESSTHANEQUAL   shift and go to state 92
    NOTEQUAL        shift and go to state 93
    EQUAL           shift and go to state 94

    comp_op                        shift and go to state 88

state 55

    (63) comp_exp -> bparen .

    GREATERTHAN     reduce using rule 63 (comp_exp -> bparen .)
    GREATERTHANEQUAL reduce using rule 63 (comp_exp -> bparen .)
    LESSTHAN        reduce using rule 63 (comp_exp -> bparen .)
    LESSTHANEQUAL   reduce using rule 63 (comp_exp -> bparen .)
    NOTEQUAL        reduce using rule 63 (comp_exp -> bparen .)
    EQUAL           reduce using rule 63 (comp_exp -> bparen .)
    OR              reduce using rule 63 (comp_exp -> bparen .)
    THEN            reduce using rule 63 (comp_exp -> bparen .)
    AND             reduce using rule 63 (comp_exp -> bparen .)
    END             reduce using rule 63 (comp_exp -> bparen .)
    IF              reduce using rule 63 (comp_exp -> bparen .)
    PUTS            reduce using rule 63 (comp_exp -> bparen .)
    RETURN          reduce using rule 63 (comp_exp -> bparen .)
    ID              reduce using rule 63 (comp_exp -> bparen .)
    LOOP            reduce using rule 63 (comp_exp -> bparen .)
    FOR             reduce using rule 63 (comp_exp -> bparen .)
    WHILE           reduce using rule 63 (comp_exp -> bparen .)
    ELSIF           reduce using rule 63 (comp_exp -> bparen .)
    ELSE            reduce using rule 63 (comp_exp -> bparen .)
    NUMBER_INT      reduce using rule 63 (comp_exp -> bparen .)
    SEMICOLON       reduce using rule 63 (comp_exp -> bparen .)
    RPAREN          reduce using rule 63 (comp_exp -> bparen .)


state 56

    (64) bparen -> LPAREN . expression RPAREN
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    expression                     shift and go to state 95
    or_exp                         shift and go to state 53
    comp_exp                       shift and go to state 54
    bparen                         shift and go to state 55
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 57

    (65) bparen -> term .

    GREATERTHAN     reduce using rule 65 (bparen -> term .)
    GREATERTHANEQUAL reduce using rule 65 (bparen -> term .)
    LESSTHAN        reduce using rule 65 (bparen -> term .)
    LESSTHANEQUAL   reduce using rule 65 (bparen -> term .)
    NOTEQUAL        reduce using rule 65 (bparen -> term .)
    EQUAL           reduce using rule 65 (bparen -> term .)
    OR              reduce using rule 65 (bparen -> term .)
    THEN            reduce using rule 65 (bparen -> term .)
    AND             reduce using rule 65 (bparen -> term .)
    NUMBER_INT      reduce using rule 65 (bparen -> term .)
    RPAREN          reduce using rule 65 (bparen -> term .)
    END             reduce using rule 65 (bparen -> term .)
    IF              reduce using rule 65 (bparen -> term .)
    PUTS            reduce using rule 65 (bparen -> term .)
    RETURN          reduce using rule 65 (bparen -> term .)
    ID              reduce using rule 65 (bparen -> term .)
    LOOP            reduce using rule 65 (bparen -> term .)
    FOR             reduce using rule 65 (bparen -> term .)
    WHILE           reduce using rule 65 (bparen -> term .)
    ELSIF           reduce using rule 65 (bparen -> term .)
    ELSE            reduce using rule 65 (bparen -> term .)
    SEMICOLON       reduce using rule 65 (bparen -> term .)


state 58

    (82) term -> ID .
    (24) function_call_exp -> ID . LPAREN param_pass RPAREN

    GREATERTHAN     reduce using rule 82 (term -> ID .)
    GREATERTHANEQUAL reduce using rule 82 (term -> ID .)
    LESSTHAN        reduce using rule 82 (term -> ID .)
    LESSTHANEQUAL   reduce using rule 82 (term -> ID .)
    NOTEQUAL        reduce using rule 82 (term -> ID .)
    EQUAL           reduce using rule 82 (term -> ID .)
    OR              reduce using rule 82 (term -> ID .)
    THEN            reduce using rule 82 (term -> ID .)
    AND             reduce using rule 82 (term -> ID .)
    END             reduce using rule 82 (term -> ID .)
    IF              reduce using rule 82 (term -> ID .)
    PUTS            reduce using rule 82 (term -> ID .)
    RETURN          reduce using rule 82 (term -> ID .)
    ID              reduce using rule 82 (term -> ID .)
    LOOP            reduce using rule 82 (term -> ID .)
    FOR             reduce using rule 82 (term -> ID .)
    WHILE           reduce using rule 82 (term -> ID .)
    ELSIF           reduce using rule 82 (term -> ID .)
    ELSE            reduce using rule 82 (term -> ID .)
    POWER           reduce using rule 82 (term -> ID .)
    TIMES           reduce using rule 82 (term -> ID .)
    DIVIDE          reduce using rule 82 (term -> ID .)
    PLUS            reduce using rule 82 (term -> ID .)
    MINUS           reduce using rule 82 (term -> ID .)
    NUMBER_INT      reduce using rule 82 (term -> ID .)
    SEMICOLON       reduce using rule 82 (term -> ID .)
    RPAREN          reduce using rule 82 (term -> ID .)
    LPAREN          shift and go to state 96


state 59

    (83) term -> function_call_exp .

    GREATERTHAN     reduce using rule 83 (term -> function_call_exp .)
    GREATERTHANEQUAL reduce using rule 83 (term -> function_call_exp .)
    LESSTHAN        reduce using rule 83 (term -> function_call_exp .)
    LESSTHANEQUAL   reduce using rule 83 (term -> function_call_exp .)
    NOTEQUAL        reduce using rule 83 (term -> function_call_exp .)
    EQUAL           reduce using rule 83 (term -> function_call_exp .)
    OR              reduce using rule 83 (term -> function_call_exp .)
    THEN            reduce using rule 83 (term -> function_call_exp .)
    AND             reduce using rule 83 (term -> function_call_exp .)
    END             reduce using rule 83 (term -> function_call_exp .)
    IF              reduce using rule 83 (term -> function_call_exp .)
    PUTS            reduce using rule 83 (term -> function_call_exp .)
    RETURN          reduce using rule 83 (term -> function_call_exp .)
    ID              reduce using rule 83 (term -> function_call_exp .)
    LOOP            reduce using rule 83 (term -> function_call_exp .)
    FOR             reduce using rule 83 (term -> function_call_exp .)
    WHILE           reduce using rule 83 (term -> function_call_exp .)
    ELSIF           reduce using rule 83 (term -> function_call_exp .)
    ELSE            reduce using rule 83 (term -> function_call_exp .)
    POWER           reduce using rule 83 (term -> function_call_exp .)
    TIMES           reduce using rule 83 (term -> function_call_exp .)
    DIVIDE          reduce using rule 83 (term -> function_call_exp .)
    PLUS            reduce using rule 83 (term -> function_call_exp .)
    MINUS           reduce using rule 83 (term -> function_call_exp .)
    NUMBER_INT      reduce using rule 83 (term -> function_call_exp .)
    SEMICOLON       reduce using rule 83 (term -> function_call_exp .)
    RPAREN          reduce using rule 83 (term -> function_call_exp .)


state 60

    (45) puts -> PUTS LPAREN . STRING RPAREN SEMICOLON

    STRING          shift and go to state 97


state 61

    (85) return -> RETURN expression .
    (58) expression -> expression . AND or_exp

    END             reduce using rule 85 (return -> RETURN expression .)
    IF              reduce using rule 85 (return -> RETURN expression .)
    PUTS            reduce using rule 85 (return -> RETURN expression .)
    RETURN          reduce using rule 85 (return -> RETURN expression .)
    ID              reduce using rule 85 (return -> RETURN expression .)
    LOOP            reduce using rule 85 (return -> RETURN expression .)
    FOR             reduce using rule 85 (return -> RETURN expression .)
    WHILE           reduce using rule 85 (return -> RETURN expression .)
    ELSIF           reduce using rule 85 (return -> RETURN expression .)
    ELSE            reduce using rule 85 (return -> RETURN expression .)
    AND             shift and go to state 86


state 62

    (86) return -> RETURN op_arithmetic .
    (72) op_arithmetic -> op_arithmetic . PLUS factor
    (73) op_arithmetic -> op_arithmetic . MINUS factor

    END             reduce using rule 86 (return -> RETURN op_arithmetic .)
    IF              reduce using rule 86 (return -> RETURN op_arithmetic .)
    PUTS            reduce using rule 86 (return -> RETURN op_arithmetic .)
    RETURN          reduce using rule 86 (return -> RETURN op_arithmetic .)
    ID              reduce using rule 86 (return -> RETURN op_arithmetic .)
    LOOP            reduce using rule 86 (return -> RETURN op_arithmetic .)
    FOR             reduce using rule 86 (return -> RETURN op_arithmetic .)
    WHILE           reduce using rule 86 (return -> RETURN op_arithmetic .)
    ELSIF           reduce using rule 86 (return -> RETURN op_arithmetic .)
    ELSE            reduce using rule 86 (return -> RETURN op_arithmetic .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99


state 63

    (74) op_arithmetic -> factor .
    (75) factor -> factor . TIMES power
    (76) factor -> factor . DIVIDE power

    PLUS            reduce using rule 74 (op_arithmetic -> factor .)
    MINUS           reduce using rule 74 (op_arithmetic -> factor .)
    END             reduce using rule 74 (op_arithmetic -> factor .)
    IF              reduce using rule 74 (op_arithmetic -> factor .)
    PUTS            reduce using rule 74 (op_arithmetic -> factor .)
    RETURN          reduce using rule 74 (op_arithmetic -> factor .)
    ID              reduce using rule 74 (op_arithmetic -> factor .)
    LOOP            reduce using rule 74 (op_arithmetic -> factor .)
    FOR             reduce using rule 74 (op_arithmetic -> factor .)
    WHILE           reduce using rule 74 (op_arithmetic -> factor .)
    ELSIF           reduce using rule 74 (op_arithmetic -> factor .)
    ELSE            reduce using rule 74 (op_arithmetic -> factor .)
    SEMICOLON       reduce using rule 74 (op_arithmetic -> factor .)
    RPAREN          reduce using rule 74 (op_arithmetic -> factor .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101


state 64

    (77) factor -> power .
    (78) power -> power . POWER paren

    TIMES           reduce using rule 77 (factor -> power .)
    DIVIDE          reduce using rule 77 (factor -> power .)
    PLUS            reduce using rule 77 (factor -> power .)
    MINUS           reduce using rule 77 (factor -> power .)
    END             reduce using rule 77 (factor -> power .)
    IF              reduce using rule 77 (factor -> power .)
    PUTS            reduce using rule 77 (factor -> power .)
    RETURN          reduce using rule 77 (factor -> power .)
    ID              reduce using rule 77 (factor -> power .)
    LOOP            reduce using rule 77 (factor -> power .)
    FOR             reduce using rule 77 (factor -> power .)
    WHILE           reduce using rule 77 (factor -> power .)
    ELSIF           reduce using rule 77 (factor -> power .)
    ELSE            reduce using rule 77 (factor -> power .)
    SEMICOLON       reduce using rule 77 (factor -> power .)
    RPAREN          reduce using rule 77 (factor -> power .)
    POWER           shift and go to state 102


state 65

    (79) power -> paren .

    POWER           reduce using rule 79 (power -> paren .)
    TIMES           reduce using rule 79 (power -> paren .)
    DIVIDE          reduce using rule 79 (power -> paren .)
    PLUS            reduce using rule 79 (power -> paren .)
    MINUS           reduce using rule 79 (power -> paren .)
    END             reduce using rule 79 (power -> paren .)
    IF              reduce using rule 79 (power -> paren .)
    PUTS            reduce using rule 79 (power -> paren .)
    RETURN          reduce using rule 79 (power -> paren .)
    ID              reduce using rule 79 (power -> paren .)
    LOOP            reduce using rule 79 (power -> paren .)
    FOR             reduce using rule 79 (power -> paren .)
    WHILE           reduce using rule 79 (power -> paren .)
    ELSIF           reduce using rule 79 (power -> paren .)
    ELSE            reduce using rule 79 (power -> paren .)
    SEMICOLON       reduce using rule 79 (power -> paren .)
    RPAREN          reduce using rule 79 (power -> paren .)


state 66

    (64) bparen -> LPAREN . expression RPAREN
    (80) paren -> LPAREN . op_arithmetic RPAREN
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (72) op_arithmetic -> . op_arithmetic PLUS factor
    (73) op_arithmetic -> . op_arithmetic MINUS factor
    (74) op_arithmetic -> . factor
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (78) power -> . power POWER paren
    (79) power -> . paren
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 66
    ID              shift and go to state 58

    expression                     shift and go to state 95
    op_arithmetic                  shift and go to state 103
    or_exp                         shift and go to state 53
    factor                         shift and go to state 63
    comp_exp                       shift and go to state 54
    power                          shift and go to state 64
    bparen                         shift and go to state 55
    paren                          shift and go to state 65
    term                           shift and go to state 67
    function_call_exp              shift and go to state 59

state 67

    (65) bparen -> term .
    (81) paren -> term .

  ! reduce/reduce conflict for END resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for IF resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for PUTS resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for RETURN resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for ID resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for LOOP resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for FOR resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for WHILE resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for ELSIF resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for ELSE resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 65 (bparen -> term .)
  ! reduce/reduce conflict for RPAREN resolved using rule 65 (bparen -> term .)
    GREATERTHAN     reduce using rule 65 (bparen -> term .)
    GREATERTHANEQUAL reduce using rule 65 (bparen -> term .)
    LESSTHAN        reduce using rule 65 (bparen -> term .)
    LESSTHANEQUAL   reduce using rule 65 (bparen -> term .)
    NOTEQUAL        reduce using rule 65 (bparen -> term .)
    EQUAL           reduce using rule 65 (bparen -> term .)
    OR              reduce using rule 65 (bparen -> term .)
    AND             reduce using rule 65 (bparen -> term .)
    END             reduce using rule 65 (bparen -> term .)
    IF              reduce using rule 65 (bparen -> term .)
    PUTS            reduce using rule 65 (bparen -> term .)
    RETURN          reduce using rule 65 (bparen -> term .)
    ID              reduce using rule 65 (bparen -> term .)
    LOOP            reduce using rule 65 (bparen -> term .)
    FOR             reduce using rule 65 (bparen -> term .)
    WHILE           reduce using rule 65 (bparen -> term .)
    ELSIF           reduce using rule 65 (bparen -> term .)
    ELSE            reduce using rule 65 (bparen -> term .)
    SEMICOLON       reduce using rule 65 (bparen -> term .)
    RPAREN          reduce using rule 65 (bparen -> term .)
    POWER           reduce using rule 81 (paren -> term .)
    TIMES           reduce using rule 81 (paren -> term .)
    DIVIDE          reduce using rule 81 (paren -> term .)
    PLUS            reduce using rule 81 (paren -> term .)
    MINUS           reduce using rule 81 (paren -> term .)

  ! END             [ reduce using rule 81 (paren -> term .) ]
  ! IF              [ reduce using rule 81 (paren -> term .) ]
  ! PUTS            [ reduce using rule 81 (paren -> term .) ]
  ! RETURN          [ reduce using rule 81 (paren -> term .) ]
  ! ID              [ reduce using rule 81 (paren -> term .) ]
  ! LOOP            [ reduce using rule 81 (paren -> term .) ]
  ! FOR             [ reduce using rule 81 (paren -> term .) ]
  ! WHILE           [ reduce using rule 81 (paren -> term .) ]
  ! ELSIF           [ reduce using rule 81 (paren -> term .) ]
  ! ELSE            [ reduce using rule 81 (paren -> term .) ]
  ! SEMICOLON       [ reduce using rule 81 (paren -> term .) ]
  ! RPAREN          [ reduce using rule 81 (paren -> term .) ]


state 68

    (53) loop_statement -> LOOP cmd_loop . END LOOP
    (43) cmd_loop -> cmd_loop . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 104
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd                            shift and go to state 49
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 69

    (55) for_statement -> FOR ID . IN range LOOP cmd_loop END LOOP SEMICOLON

    IN              shift and go to state 105


state 70

    (54) while_statement -> WHILE expression . NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON
    (58) expression -> expression . AND or_exp

    NUMBER_INT      shift and go to state 106
    AND             shift and go to state 86


state 71

    (84) array -> TYPE ID IS . ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    ARRAY           shift and go to state 107


state 72

    (14) var -> var_loop ID COLON . TYPE

    TYPE            shift and go to state 108


state 73

    (16) var_loop -> var_loop ID COMMA .

    ID              reduce using rule 16 (var_loop -> var_loop ID COMMA .)


state 74

    (3) subprogram -> FUNCTION ID decl_param . IS decl body
    (4) subprogram -> FUNCTION ID decl_param . IS body

    IS              shift and go to state 109


state 75

    (18) decl_param -> LPAREN . param RPAREN
    (19) decl_param -> LPAREN . param RPAREN RETURN TYPE
    (20) param -> . ID COLON TYPE n_param

    ID              shift and go to state 111

    param                          shift and go to state 110

state 76

    (12) var -> ID COMMA TYPE ASSIGN . value
    (31) value -> . NUMBER_INT
    (32) value -> . NUMBER_FLOAT
    (33) value -> . NUMBER_EXPONENT
    (34) value -> . BOOLEAN
    (35) value -> . STRING
    (36) value -> . CHAR

    NUMBER_INT      shift and go to state 113
    NUMBER_FLOAT    shift and go to state 114
    NUMBER_EXPONENT shift and go to state 115
    BOOLEAN         shift and go to state 116
    STRING          shift and go to state 117
    CHAR            shift and go to state 118

    value                          shift and go to state 112

state 77

    (10) decl_loop -> var SEMICOLON decl_loop .

    BEGIN           reduce using rule 10 (decl_loop -> var SEMICOLON decl_loop .)


state 78

    (5) body -> BEGIN cmd_loop END ID . SEMICOLON

    SEMICOLON       shift and go to state 119


state 79

    (57) assign -> ID ASSIGN op_arithmetic . SEMICOLON
    (72) op_arithmetic -> op_arithmetic . PLUS factor
    (73) op_arithmetic -> op_arithmetic . MINUS factor

    SEMICOLON       shift and go to state 120
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99


state 80

    (80) paren -> LPAREN . op_arithmetic RPAREN
    (72) op_arithmetic -> . op_arithmetic PLUS factor
    (73) op_arithmetic -> . op_arithmetic MINUS factor
    (74) op_arithmetic -> . factor
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (78) power -> . power POWER paren
    (79) power -> . paren
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 80
    ID              shift and go to state 58

    op_arithmetic                  shift and go to state 103
    factor                         shift and go to state 63
    power                          shift and go to state 64
    paren                          shift and go to state 65
    term                           shift and go to state 81
    function_call_exp              shift and go to state 59

state 81

    (81) paren -> term .

    POWER           reduce using rule 81 (paren -> term .)
    TIMES           reduce using rule 81 (paren -> term .)
    DIVIDE          reduce using rule 81 (paren -> term .)
    SEMICOLON       reduce using rule 81 (paren -> term .)
    PLUS            reduce using rule 81 (paren -> term .)
    MINUS           reduce using rule 81 (paren -> term .)
    RPAREN          reduce using rule 81 (paren -> term .)
    END             reduce using rule 81 (paren -> term .)
    IF              reduce using rule 81 (paren -> term .)
    PUTS            reduce using rule 81 (paren -> term .)
    RETURN          reduce using rule 81 (paren -> term .)
    ID              reduce using rule 81 (paren -> term .)
    LOOP            reduce using rule 81 (paren -> term .)
    FOR             reduce using rule 81 (paren -> term .)
    WHILE           reduce using rule 81 (paren -> term .)
    ELSIF           reduce using rule 81 (paren -> term .)
    ELSE            reduce using rule 81 (paren -> term .)


state 82

    (23) function_call -> ID LPAREN param_pass . RPAREN SEMICOLON

    RPAREN          shift and go to state 121


state 83

    (25) param_pass -> expression . param_pass_loop
    (58) expression -> expression . AND or_exp
    (27) param_pass_loop -> . SEMICOLON expression param_pass_loop
    (28) param_pass_loop -> . SEMICOLON op_arithmetic param_pass_loop
    (29) param_pass_loop -> . SEMICOLON expression
    (30) param_pass_loop -> . SEMICOLON op_arithmetic

    AND             shift and go to state 86
    SEMICOLON       shift and go to state 123

    param_pass_loop                shift and go to state 122

state 84

    (26) param_pass -> op_arithmetic . param_pass_loop
    (72) op_arithmetic -> op_arithmetic . PLUS factor
    (73) op_arithmetic -> op_arithmetic . MINUS factor
    (27) param_pass_loop -> . SEMICOLON expression param_pass_loop
    (28) param_pass_loop -> . SEMICOLON op_arithmetic param_pass_loop
    (29) param_pass_loop -> . SEMICOLON expression
    (30) param_pass_loop -> . SEMICOLON op_arithmetic

    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    SEMICOLON       shift and go to state 123

    param_pass_loop                shift and go to state 124

state 85

    (46) if_statement -> IF expression THEN . cmd_loop if_statement_loop
    (43) cmd_loop -> . cmd_loop cmd
    (44) cmd_loop -> . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd_loop                       shift and go to state 125
    cmd                            shift and go to state 24
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 86

    (58) expression -> expression AND . or_exp
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    or_exp                         shift and go to state 126
    comp_exp                       shift and go to state 54
    bparen                         shift and go to state 55
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 87

    (60) or_exp -> or_exp OR . comp_exp
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    comp_exp                       shift and go to state 127
    bparen                         shift and go to state 55
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 88

    (62) comp_exp -> comp_exp comp_op . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    bparen                         shift and go to state 128
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 89

    (66) comp_op -> GREATERTHAN .

    LPAREN          reduce using rule 66 (comp_op -> GREATERTHAN .)
    ID              reduce using rule 66 (comp_op -> GREATERTHAN .)


state 90

    (67) comp_op -> GREATERTHANEQUAL .

    LPAREN          reduce using rule 67 (comp_op -> GREATERTHANEQUAL .)
    ID              reduce using rule 67 (comp_op -> GREATERTHANEQUAL .)


state 91

    (68) comp_op -> LESSTHAN .

    LPAREN          reduce using rule 68 (comp_op -> LESSTHAN .)
    ID              reduce using rule 68 (comp_op -> LESSTHAN .)


state 92

    (69) comp_op -> LESSTHANEQUAL .

    LPAREN          reduce using rule 69 (comp_op -> LESSTHANEQUAL .)
    ID              reduce using rule 69 (comp_op -> LESSTHANEQUAL .)


state 93

    (70) comp_op -> NOTEQUAL .

    LPAREN          reduce using rule 70 (comp_op -> NOTEQUAL .)
    ID              reduce using rule 70 (comp_op -> NOTEQUAL .)


state 94

    (71) comp_op -> EQUAL .

    LPAREN          reduce using rule 71 (comp_op -> EQUAL .)
    ID              reduce using rule 71 (comp_op -> EQUAL .)


state 95

    (64) bparen -> LPAREN expression . RPAREN
    (58) expression -> expression . AND or_exp

    RPAREN          shift and go to state 129
    AND             shift and go to state 86


state 96

    (24) function_call_exp -> ID LPAREN . param_pass RPAREN
    (25) param_pass -> . expression param_pass_loop
    (26) param_pass -> . op_arithmetic param_pass_loop
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (72) op_arithmetic -> . op_arithmetic PLUS factor
    (73) op_arithmetic -> . op_arithmetic MINUS factor
    (74) op_arithmetic -> . factor
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (78) power -> . power POWER paren
    (79) power -> . paren
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 66
    ID              shift and go to state 58

    param_pass                     shift and go to state 130
    expression                     shift and go to state 83
    op_arithmetic                  shift and go to state 84
    or_exp                         shift and go to state 53
    factor                         shift and go to state 63
    comp_exp                       shift and go to state 54
    power                          shift and go to state 64
    bparen                         shift and go to state 55
    paren                          shift and go to state 65
    term                           shift and go to state 67
    function_call_exp              shift and go to state 59

state 97

    (45) puts -> PUTS LPAREN STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 131


state 98

    (72) op_arithmetic -> op_arithmetic PLUS . factor
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (78) power -> . power POWER paren
    (79) power -> . paren
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 80
    ID              shift and go to state 58

    factor                         shift and go to state 132
    power                          shift and go to state 64
    paren                          shift and go to state 65
    term                           shift and go to state 81
    function_call_exp              shift and go to state 59

state 99

    (73) op_arithmetic -> op_arithmetic MINUS . factor
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (78) power -> . power POWER paren
    (79) power -> . paren
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 80
    ID              shift and go to state 58

    factor                         shift and go to state 133
    power                          shift and go to state 64
    paren                          shift and go to state 65
    term                           shift and go to state 81
    function_call_exp              shift and go to state 59

state 100

    (75) factor -> factor TIMES . power
    (78) power -> . power POWER paren
    (79) power -> . paren
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 80
    ID              shift and go to state 58

    power                          shift and go to state 134
    paren                          shift and go to state 65
    term                           shift and go to state 81
    function_call_exp              shift and go to state 59

state 101

    (76) factor -> factor DIVIDE . power
    (78) power -> . power POWER paren
    (79) power -> . paren
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 80
    ID              shift and go to state 58

    power                          shift and go to state 135
    paren                          shift and go to state 65
    term                           shift and go to state 81
    function_call_exp              shift and go to state 59

state 102

    (78) power -> power POWER . paren
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 80
    ID              shift and go to state 58

    paren                          shift and go to state 136
    term                           shift and go to state 81
    function_call_exp              shift and go to state 59

state 103

    (80) paren -> LPAREN op_arithmetic . RPAREN
    (72) op_arithmetic -> op_arithmetic . PLUS factor
    (73) op_arithmetic -> op_arithmetic . MINUS factor

    RPAREN          shift and go to state 137
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99


state 104

    (53) loop_statement -> LOOP cmd_loop END . LOOP

    LOOP            shift and go to state 138


state 105

    (55) for_statement -> FOR ID IN . range LOOP cmd_loop END LOOP SEMICOLON
    (56) range -> . ID DOTDOT ID

    ID              shift and go to state 139

    range                          shift and go to state 140

state 106

    (54) while_statement -> WHILE expression NUMBER_INT . LOOP cmd_loop END LOOP SEMICOLON

    LOOP            shift and go to state 141


state 107

    (84) array -> TYPE ID IS ARRAY . LPAREN range RPAREN OF TYPE SEMICOLON

    LPAREN          shift and go to state 142


state 108

    (14) var -> var_loop ID COLON TYPE .

    SEMICOLON       reduce using rule 14 (var -> var_loop ID COLON TYPE .)


state 109

    (3) subprogram -> FUNCTION ID decl_param IS . decl body
    (4) subprogram -> FUNCTION ID decl_param IS . body
    (6) decl -> . var SEMICOLON decl_loop
    (7) decl -> . subprogram decl_loop
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON
    (12) var -> . ID COMMA TYPE ASSIGN value
    (13) var -> . ID COLON TYPE
    (14) var -> . var_loop ID COLON TYPE
    (15) var -> . array
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (16) var_loop -> . var_loop ID COMMA
    (17) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           shift and go to state 10
    ID              shift and go to state 5
    FUNCTION        shift and go to state 14
    TYPE            shift and go to state 11

    decl                           shift and go to state 143
    body                           shift and go to state 144
    var                            shift and go to state 8
    subprogram                     shift and go to state 9
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 110

    (18) decl_param -> LPAREN param . RPAREN
    (19) decl_param -> LPAREN param . RPAREN RETURN TYPE

    RPAREN          shift and go to state 145


state 111

    (20) param -> ID . COLON TYPE n_param

    COLON           shift and go to state 146


state 112

    (12) var -> ID COMMA TYPE ASSIGN value .

    SEMICOLON       reduce using rule 12 (var -> ID COMMA TYPE ASSIGN value .)


state 113

    (31) value -> NUMBER_INT .

    SEMICOLON       reduce using rule 31 (value -> NUMBER_INT .)


state 114

    (32) value -> NUMBER_FLOAT .

    SEMICOLON       reduce using rule 32 (value -> NUMBER_FLOAT .)


state 115

    (33) value -> NUMBER_EXPONENT .

    SEMICOLON       reduce using rule 33 (value -> NUMBER_EXPONENT .)


state 116

    (34) value -> BOOLEAN .

    SEMICOLON       reduce using rule 34 (value -> BOOLEAN .)


state 117

    (35) value -> STRING .

    SEMICOLON       reduce using rule 35 (value -> STRING .)


state 118

    (36) value -> CHAR .

    SEMICOLON       reduce using rule 36 (value -> CHAR .)


state 119

    (5) body -> BEGIN cmd_loop END ID SEMICOLON .

    $end            reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    FUNCTION        reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    ID              reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    TYPE            reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    BEGIN           reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)


state 120

    (57) assign -> ID ASSIGN op_arithmetic SEMICOLON .

    END             reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    IF              reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    PUTS            reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    RETURN          reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ID              reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    LOOP            reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    FOR             reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    WHILE           reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSIF           reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSE            reduce using rule 57 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)


state 121

    (23) function_call -> ID LPAREN param_pass RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 147


state 122

    (25) param_pass -> expression param_pass_loop .

    RPAREN          reduce using rule 25 (param_pass -> expression param_pass_loop .)


state 123

    (27) param_pass_loop -> SEMICOLON . expression param_pass_loop
    (28) param_pass_loop -> SEMICOLON . op_arithmetic param_pass_loop
    (29) param_pass_loop -> SEMICOLON . expression
    (30) param_pass_loop -> SEMICOLON . op_arithmetic
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (72) op_arithmetic -> . op_arithmetic PLUS factor
    (73) op_arithmetic -> . op_arithmetic MINUS factor
    (74) op_arithmetic -> . factor
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (75) factor -> . factor TIMES power
    (76) factor -> . factor DIVIDE power
    (77) factor -> . power
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (78) power -> . power POWER paren
    (79) power -> . paren
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (80) paren -> . LPAREN op_arithmetic RPAREN
    (81) paren -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 66
    ID              shift and go to state 58

    expression                     shift and go to state 148
    op_arithmetic                  shift and go to state 149
    or_exp                         shift and go to state 53
    factor                         shift and go to state 63
    comp_exp                       shift and go to state 54
    power                          shift and go to state 64
    bparen                         shift and go to state 55
    paren                          shift and go to state 65
    term                           shift and go to state 67
    function_call_exp              shift and go to state 59

state 124

    (26) param_pass -> op_arithmetic param_pass_loop .

    RPAREN          reduce using rule 26 (param_pass -> op_arithmetic param_pass_loop .)


state 125

    (46) if_statement -> IF expression THEN cmd_loop . if_statement_loop
    (43) cmd_loop -> cmd_loop . cmd
    (47) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (48) if_statement_loop -> . ELSE expression cmd_loop END IF SEMICOLON
    (49) if_statement_loop -> . END IF SEMICOLON
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 151
    ELSE            shift and go to state 152
    END             shift and go to state 153
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    if_statement_loop              shift and go to state 150
    cmd                            shift and go to state 49
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 126

    (58) expression -> expression AND or_exp .
    (60) or_exp -> or_exp . OR comp_exp

    THEN            reduce using rule 58 (expression -> expression AND or_exp .)
    AND             reduce using rule 58 (expression -> expression AND or_exp .)
    END             reduce using rule 58 (expression -> expression AND or_exp .)
    IF              reduce using rule 58 (expression -> expression AND or_exp .)
    PUTS            reduce using rule 58 (expression -> expression AND or_exp .)
    RETURN          reduce using rule 58 (expression -> expression AND or_exp .)
    ID              reduce using rule 58 (expression -> expression AND or_exp .)
    LOOP            reduce using rule 58 (expression -> expression AND or_exp .)
    FOR             reduce using rule 58 (expression -> expression AND or_exp .)
    WHILE           reduce using rule 58 (expression -> expression AND or_exp .)
    ELSIF           reduce using rule 58 (expression -> expression AND or_exp .)
    ELSE            reduce using rule 58 (expression -> expression AND or_exp .)
    NUMBER_INT      reduce using rule 58 (expression -> expression AND or_exp .)
    SEMICOLON       reduce using rule 58 (expression -> expression AND or_exp .)
    RPAREN          reduce using rule 58 (expression -> expression AND or_exp .)
    OR              shift and go to state 87


state 127

    (60) or_exp -> or_exp OR comp_exp .
    (62) comp_exp -> comp_exp . comp_op bparen
    (66) comp_op -> . GREATERTHAN
    (67) comp_op -> . GREATERTHANEQUAL
    (68) comp_op -> . LESSTHAN
    (69) comp_op -> . LESSTHANEQUAL
    (70) comp_op -> . NOTEQUAL
    (71) comp_op -> . EQUAL

    OR              reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    THEN            reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    AND             reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    END             reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    IF              reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    PUTS            reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    RETURN          reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    ID              reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    LOOP            reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    FOR             reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    WHILE           reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    ELSIF           reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    ELSE            reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    NUMBER_INT      reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    SEMICOLON       reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    RPAREN          reduce using rule 60 (or_exp -> or_exp OR comp_exp .)
    GREATERTHAN     shift and go to state 89
    GREATERTHANEQUAL shift and go to state 90
    LESSTHAN        shift and go to state 91
    LESSTHANEQUAL   shift and go to state 92
    NOTEQUAL        shift and go to state 93
    EQUAL           shift and go to state 94

    comp_op                        shift and go to state 88

state 128

    (62) comp_exp -> comp_exp comp_op bparen .

    GREATERTHAN     reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    GREATERTHANEQUAL reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    LESSTHAN        reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    LESSTHANEQUAL   reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    NOTEQUAL        reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    EQUAL           reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    OR              reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    THEN            reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    AND             reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    END             reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    IF              reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    PUTS            reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    RETURN          reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    ID              reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    LOOP            reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    FOR             reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    WHILE           reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    ELSIF           reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    ELSE            reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    NUMBER_INT      reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    SEMICOLON       reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)
    RPAREN          reduce using rule 62 (comp_exp -> comp_exp comp_op bparen .)


state 129

    (64) bparen -> LPAREN expression RPAREN .

    GREATERTHAN     reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    GREATERTHANEQUAL reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    LESSTHAN        reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    LESSTHANEQUAL   reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    OR              reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    THEN            reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    AND             reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    END             reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    IF              reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    ID              reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    LOOP            reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    FOR             reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    ELSIF           reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    NUMBER_INT      reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 64 (bparen -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 64 (bparen -> LPAREN expression RPAREN .)


state 130

    (24) function_call_exp -> ID LPAREN param_pass . RPAREN

    RPAREN          shift and go to state 154


state 131

    (45) puts -> PUTS LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 155


state 132

    (72) op_arithmetic -> op_arithmetic PLUS factor .
    (75) factor -> factor . TIMES power
    (76) factor -> factor . DIVIDE power

    PLUS            reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    MINUS           reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    END             reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    IF              reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    PUTS            reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    RETURN          reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    ID              reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    LOOP            reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    FOR             reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    WHILE           reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    ELSIF           reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    ELSE            reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    SEMICOLON       reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    RPAREN          reduce using rule 72 (op_arithmetic -> op_arithmetic PLUS factor .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101


state 133

    (73) op_arithmetic -> op_arithmetic MINUS factor .
    (75) factor -> factor . TIMES power
    (76) factor -> factor . DIVIDE power

    PLUS            reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    MINUS           reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    END             reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    IF              reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    PUTS            reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    RETURN          reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    ID              reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    LOOP            reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    FOR             reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    WHILE           reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    ELSIF           reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    ELSE            reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    SEMICOLON       reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    RPAREN          reduce using rule 73 (op_arithmetic -> op_arithmetic MINUS factor .)
    TIMES           shift and go to state 100
    DIVIDE          shift and go to state 101


state 134

    (75) factor -> factor TIMES power .
    (78) power -> power . POWER paren

    TIMES           reduce using rule 75 (factor -> factor TIMES power .)
    DIVIDE          reduce using rule 75 (factor -> factor TIMES power .)
    PLUS            reduce using rule 75 (factor -> factor TIMES power .)
    MINUS           reduce using rule 75 (factor -> factor TIMES power .)
    END             reduce using rule 75 (factor -> factor TIMES power .)
    IF              reduce using rule 75 (factor -> factor TIMES power .)
    PUTS            reduce using rule 75 (factor -> factor TIMES power .)
    RETURN          reduce using rule 75 (factor -> factor TIMES power .)
    ID              reduce using rule 75 (factor -> factor TIMES power .)
    LOOP            reduce using rule 75 (factor -> factor TIMES power .)
    FOR             reduce using rule 75 (factor -> factor TIMES power .)
    WHILE           reduce using rule 75 (factor -> factor TIMES power .)
    ELSIF           reduce using rule 75 (factor -> factor TIMES power .)
    ELSE            reduce using rule 75 (factor -> factor TIMES power .)
    SEMICOLON       reduce using rule 75 (factor -> factor TIMES power .)
    RPAREN          reduce using rule 75 (factor -> factor TIMES power .)
    POWER           shift and go to state 102


state 135

    (76) factor -> factor DIVIDE power .
    (78) power -> power . POWER paren

    TIMES           reduce using rule 76 (factor -> factor DIVIDE power .)
    DIVIDE          reduce using rule 76 (factor -> factor DIVIDE power .)
    PLUS            reduce using rule 76 (factor -> factor DIVIDE power .)
    MINUS           reduce using rule 76 (factor -> factor DIVIDE power .)
    END             reduce using rule 76 (factor -> factor DIVIDE power .)
    IF              reduce using rule 76 (factor -> factor DIVIDE power .)
    PUTS            reduce using rule 76 (factor -> factor DIVIDE power .)
    RETURN          reduce using rule 76 (factor -> factor DIVIDE power .)
    ID              reduce using rule 76 (factor -> factor DIVIDE power .)
    LOOP            reduce using rule 76 (factor -> factor DIVIDE power .)
    FOR             reduce using rule 76 (factor -> factor DIVIDE power .)
    WHILE           reduce using rule 76 (factor -> factor DIVIDE power .)
    ELSIF           reduce using rule 76 (factor -> factor DIVIDE power .)
    ELSE            reduce using rule 76 (factor -> factor DIVIDE power .)
    SEMICOLON       reduce using rule 76 (factor -> factor DIVIDE power .)
    RPAREN          reduce using rule 76 (factor -> factor DIVIDE power .)
    POWER           shift and go to state 102


state 136

    (78) power -> power POWER paren .

    POWER           reduce using rule 78 (power -> power POWER paren .)
    TIMES           reduce using rule 78 (power -> power POWER paren .)
    DIVIDE          reduce using rule 78 (power -> power POWER paren .)
    PLUS            reduce using rule 78 (power -> power POWER paren .)
    MINUS           reduce using rule 78 (power -> power POWER paren .)
    END             reduce using rule 78 (power -> power POWER paren .)
    IF              reduce using rule 78 (power -> power POWER paren .)
    PUTS            reduce using rule 78 (power -> power POWER paren .)
    RETURN          reduce using rule 78 (power -> power POWER paren .)
    ID              reduce using rule 78 (power -> power POWER paren .)
    LOOP            reduce using rule 78 (power -> power POWER paren .)
    FOR             reduce using rule 78 (power -> power POWER paren .)
    WHILE           reduce using rule 78 (power -> power POWER paren .)
    ELSIF           reduce using rule 78 (power -> power POWER paren .)
    ELSE            reduce using rule 78 (power -> power POWER paren .)
    SEMICOLON       reduce using rule 78 (power -> power POWER paren .)
    RPAREN          reduce using rule 78 (power -> power POWER paren .)


state 137

    (80) paren -> LPAREN op_arithmetic RPAREN .

    POWER           reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    TIMES           reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    DIVIDE          reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    PLUS            reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    MINUS           reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    END             reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    IF              reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    PUTS            reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    RETURN          reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    ID              reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    LOOP            reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    FOR             reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    WHILE           reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    ELSIF           reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    ELSE            reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    SEMICOLON       reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)
    RPAREN          reduce using rule 80 (paren -> LPAREN op_arithmetic RPAREN .)


state 138

    (53) loop_statement -> LOOP cmd_loop END LOOP .

    END             reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    IF              reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    PUTS            reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    RETURN          reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    ID              reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    LOOP            reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    FOR             reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    WHILE           reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    ELSIF           reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)
    ELSE            reduce using rule 53 (loop_statement -> LOOP cmd_loop END LOOP .)


state 139

    (56) range -> ID . DOTDOT ID

    DOTDOT          shift and go to state 156


state 140

    (55) for_statement -> FOR ID IN range . LOOP cmd_loop END LOOP SEMICOLON

    LOOP            shift and go to state 157


state 141

    (54) while_statement -> WHILE expression NUMBER_INT LOOP . cmd_loop END LOOP SEMICOLON
    (43) cmd_loop -> . cmd_loop cmd
    (44) cmd_loop -> . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd_loop                       shift and go to state 158
    cmd                            shift and go to state 24
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 142

    (84) array -> TYPE ID IS ARRAY LPAREN . range RPAREN OF TYPE SEMICOLON
    (56) range -> . ID DOTDOT ID

    ID              shift and go to state 139

    range                          shift and go to state 159

state 143

    (3) subprogram -> FUNCTION ID decl_param IS decl . body
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 10

    body                           shift and go to state 160

state 144

    (4) subprogram -> FUNCTION ID decl_param IS body .

    FUNCTION        reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)
    ID              reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)
    TYPE            reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)
    BEGIN           reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)


state 145

    (18) decl_param -> LPAREN param RPAREN .
    (19) decl_param -> LPAREN param RPAREN . RETURN TYPE

    IS              reduce using rule 18 (decl_param -> LPAREN param RPAREN .)
    RETURN          shift and go to state 161


state 146

    (20) param -> ID COLON . TYPE n_param

    TYPE            shift and go to state 162


state 147

    (23) function_call -> ID LPAREN param_pass RPAREN SEMICOLON .

    END             reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    IF              reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    PUTS            reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    RETURN          reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ID              reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    LOOP            reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    FOR             reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    WHILE           reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ELSIF           reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ELSE            reduce using rule 23 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)


state 148

    (27) param_pass_loop -> SEMICOLON expression . param_pass_loop
    (29) param_pass_loop -> SEMICOLON expression .
    (58) expression -> expression . AND or_exp
    (27) param_pass_loop -> . SEMICOLON expression param_pass_loop
    (28) param_pass_loop -> . SEMICOLON op_arithmetic param_pass_loop
    (29) param_pass_loop -> . SEMICOLON expression
    (30) param_pass_loop -> . SEMICOLON op_arithmetic

    RPAREN          reduce using rule 29 (param_pass_loop -> SEMICOLON expression .)
    AND             shift and go to state 86
    SEMICOLON       shift and go to state 123

    param_pass_loop                shift and go to state 163

state 149

    (28) param_pass_loop -> SEMICOLON op_arithmetic . param_pass_loop
    (30) param_pass_loop -> SEMICOLON op_arithmetic .
    (72) op_arithmetic -> op_arithmetic . PLUS factor
    (73) op_arithmetic -> op_arithmetic . MINUS factor
    (27) param_pass_loop -> . SEMICOLON expression param_pass_loop
    (28) param_pass_loop -> . SEMICOLON op_arithmetic param_pass_loop
    (29) param_pass_loop -> . SEMICOLON expression
    (30) param_pass_loop -> . SEMICOLON op_arithmetic

    RPAREN          reduce using rule 30 (param_pass_loop -> SEMICOLON op_arithmetic .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    SEMICOLON       shift and go to state 123

    param_pass_loop                shift and go to state 164

state 150

    (46) if_statement -> IF expression THEN cmd_loop if_statement_loop .

    END             reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    IF              reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    PUTS            reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    RETURN          reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ID              reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    LOOP            reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    FOR             reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    WHILE           reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSE            reduce using rule 46 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)


state 151

    (47) if_statement_loop -> ELSIF . expression cmd_loop if_statement_loop
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    expression                     shift and go to state 165
    or_exp                         shift and go to state 53
    comp_exp                       shift and go to state 54
    bparen                         shift and go to state 55
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 152

    (48) if_statement_loop -> ELSE . expression cmd_loop END IF SEMICOLON
    (58) expression -> . expression AND or_exp
    (59) expression -> . or_exp
    (60) or_exp -> . or_exp OR comp_exp
    (61) or_exp -> . comp_exp
    (62) comp_exp -> . comp_exp comp_op bparen
    (63) comp_exp -> . bparen
    (64) bparen -> . LPAREN expression RPAREN
    (65) bparen -> . term
    (82) term -> . ID
    (83) term -> . function_call_exp
    (24) function_call_exp -> . ID LPAREN param_pass RPAREN

    LPAREN          shift and go to state 56
    ID              shift and go to state 58

    expression                     shift and go to state 166
    or_exp                         shift and go to state 53
    comp_exp                       shift and go to state 54
    bparen                         shift and go to state 55
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 153

    (49) if_statement_loop -> END . IF SEMICOLON

    IF              shift and go to state 167


state 154

    (24) function_call_exp -> ID LPAREN param_pass RPAREN .

    GREATERTHAN     reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    GREATERTHANEQUAL reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LESSTHAN        reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LESSTHANEQUAL   reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    NOTEQUAL        reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    EQUAL           reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    OR              reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    THEN            reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    AND             reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    END             reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    IF              reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    PUTS            reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    RETURN          reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    ID              reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LOOP            reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    FOR             reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    WHILE           reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    ELSIF           reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    ELSE            reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    POWER           reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    TIMES           reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    DIVIDE          reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    PLUS            reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    MINUS           reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    NUMBER_INT      reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    SEMICOLON       reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    RPAREN          reduce using rule 24 (function_call_exp -> ID LPAREN param_pass RPAREN .)


state 155

    (45) puts -> PUTS LPAREN STRING RPAREN SEMICOLON .

    END             reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    PUTS            reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ID              reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    LOOP            reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ELSIF           reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ELSE            reduce using rule 45 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)


state 156

    (56) range -> ID DOTDOT . ID

    ID              shift and go to state 168


state 157

    (55) for_statement -> FOR ID IN range LOOP . cmd_loop END LOOP SEMICOLON
    (43) cmd_loop -> . cmd_loop cmd
    (44) cmd_loop -> . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd_loop                       shift and go to state 169
    cmd                            shift and go to state 24
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 158

    (54) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop . END LOOP SEMICOLON
    (43) cmd_loop -> cmd_loop . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 170
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd                            shift and go to state 49
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 159

    (84) array -> TYPE ID IS ARRAY LPAREN range . RPAREN OF TYPE SEMICOLON

    RPAREN          shift and go to state 171


state 160

    (3) subprogram -> FUNCTION ID decl_param IS decl body .

    FUNCTION        reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)
    ID              reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)
    TYPE            reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)
    BEGIN           reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)


state 161

    (19) decl_param -> LPAREN param RPAREN RETURN . TYPE

    TYPE            shift and go to state 172


state 162

    (20) param -> ID COLON TYPE . n_param
    (21) n_param -> . SEMICOLON ID COLON TYPE n_param
    (22) n_param -> . SEMICOLON ID COLON TYPE

    SEMICOLON       shift and go to state 174

    n_param                        shift and go to state 173

state 163

    (27) param_pass_loop -> SEMICOLON expression param_pass_loop .

    RPAREN          reduce using rule 27 (param_pass_loop -> SEMICOLON expression param_pass_loop .)


state 164

    (28) param_pass_loop -> SEMICOLON op_arithmetic param_pass_loop .

    RPAREN          reduce using rule 28 (param_pass_loop -> SEMICOLON op_arithmetic param_pass_loop .)


state 165

    (47) if_statement_loop -> ELSIF expression . cmd_loop if_statement_loop
    (58) expression -> expression . AND or_exp
    (43) cmd_loop -> . cmd_loop cmd
    (44) cmd_loop -> . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    AND             shift and go to state 86
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd_loop                       shift and go to state 175
    cmd                            shift and go to state 24
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 166

    (48) if_statement_loop -> ELSE expression . cmd_loop END IF SEMICOLON
    (58) expression -> expression . AND or_exp
    (43) cmd_loop -> . cmd_loop cmd
    (44) cmd_loop -> . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    AND             shift and go to state 86
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd_loop                       shift and go to state 176
    cmd                            shift and go to state 24
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 167

    (49) if_statement_loop -> END IF . SEMICOLON

    SEMICOLON       shift and go to state 177


state 168

    (56) range -> ID DOTDOT ID .

    LOOP            reduce using rule 56 (range -> ID DOTDOT ID .)
    RPAREN          reduce using rule 56 (range -> ID DOTDOT ID .)


state 169

    (55) for_statement -> FOR ID IN range LOOP cmd_loop . END LOOP SEMICOLON
    (43) cmd_loop -> cmd_loop . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 178
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd                            shift and go to state 49
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 170

    (54) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 179


state 171

    (84) array -> TYPE ID IS ARRAY LPAREN range RPAREN . OF TYPE SEMICOLON

    OF              shift and go to state 180


state 172

    (19) decl_param -> LPAREN param RPAREN RETURN TYPE .

    IS              reduce using rule 19 (decl_param -> LPAREN param RPAREN RETURN TYPE .)


state 173

    (20) param -> ID COLON TYPE n_param .

    RPAREN          reduce using rule 20 (param -> ID COLON TYPE n_param .)


state 174

    (21) n_param -> SEMICOLON . ID COLON TYPE n_param
    (22) n_param -> SEMICOLON . ID COLON TYPE

    ID              shift and go to state 181


state 175

    (47) if_statement_loop -> ELSIF expression cmd_loop . if_statement_loop
    (43) cmd_loop -> cmd_loop . cmd
    (47) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (48) if_statement_loop -> . ELSE expression cmd_loop END IF SEMICOLON
    (49) if_statement_loop -> . END IF SEMICOLON
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 151
    ELSE            shift and go to state 152
    END             shift and go to state 153
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    if_statement_loop              shift and go to state 182
    cmd                            shift and go to state 49
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 176

    (48) if_statement_loop -> ELSE expression cmd_loop . END IF SEMICOLON
    (43) cmd_loop -> cmd_loop . cmd
    (37) cmd -> . if_statement
    (38) cmd -> . repeat_statement
    (39) cmd -> . puts
    (40) cmd -> . return
    (41) cmd -> . assign
    (42) cmd -> . function_call
    (46) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (50) repeat_statement -> . loop_statement
    (51) repeat_statement -> . for_statement
    (52) repeat_statement -> . while_statement
    (45) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (85) return -> . RETURN expression
    (86) return -> . RETURN op_arithmetic
    (57) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (23) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (53) loop_statement -> . LOOP cmd_loop END LOOP
    (55) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (54) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 183
    IF              shift and go to state 31
    PUTS            shift and go to state 35
    RETURN          shift and go to state 36
    ID              shift and go to state 23
    LOOP            shift and go to state 37
    FOR             shift and go to state 38
    WHILE           shift and go to state 39

    cmd                            shift and go to state 49
    if_statement                   shift and go to state 25
    repeat_statement               shift and go to state 26
    puts                           shift and go to state 27
    return                         shift and go to state 28
    assign                         shift and go to state 29
    function_call                  shift and go to state 30
    loop_statement                 shift and go to state 32
    for_statement                  shift and go to state 33
    while_statement                shift and go to state 34

state 177

    (49) if_statement_loop -> END IF SEMICOLON .

    END             reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    IF              reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    PUTS            reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    RETURN          reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    ID              reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    LOOP            reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    FOR             reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    WHILE           reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    ELSIF           reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)
    ELSE            reduce using rule 49 (if_statement_loop -> END IF SEMICOLON .)


state 178

    (55) for_statement -> FOR ID IN range LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 184


state 179

    (54) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 185


state 180

    (84) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF . TYPE SEMICOLON

    TYPE            shift and go to state 186


state 181

    (21) n_param -> SEMICOLON ID . COLON TYPE n_param
    (22) n_param -> SEMICOLON ID . COLON TYPE

    COLON           shift and go to state 187


state 182

    (47) if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .

    END             reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    IF              reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    PUTS            reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    RETURN          reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ID              reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    LOOP            reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    FOR             reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    WHILE           reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSE            reduce using rule 47 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)


state 183

    (48) if_statement_loop -> ELSE expression cmd_loop END . IF SEMICOLON

    IF              shift and go to state 188


state 184

    (55) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 189


state 185

    (54) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 54 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)


state 186

    (84) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE . SEMICOLON

    SEMICOLON       shift and go to state 190


state 187

    (21) n_param -> SEMICOLON ID COLON . TYPE n_param
    (22) n_param -> SEMICOLON ID COLON . TYPE

    TYPE            shift and go to state 191


state 188

    (48) if_statement_loop -> ELSE expression cmd_loop END IF . SEMICOLON

    SEMICOLON       shift and go to state 192


state 189

    (55) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 55 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)


state 190

    (84) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON .

    SEMICOLON       reduce using rule 84 (array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON .)


state 191

    (21) n_param -> SEMICOLON ID COLON TYPE . n_param
    (22) n_param -> SEMICOLON ID COLON TYPE .
    (21) n_param -> . SEMICOLON ID COLON TYPE n_param
    (22) n_param -> . SEMICOLON ID COLON TYPE

    RPAREN          reduce using rule 22 (n_param -> SEMICOLON ID COLON TYPE .)
    SEMICOLON       shift and go to state 174

    n_param                        shift and go to state 193

state 192

    (48) if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .

    END             reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    IF              reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    PUTS            reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    RETURN          reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    ID              reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    LOOP            reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    FOR             reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    WHILE           reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    ELSIF           reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    ELSE            reduce using rule 48 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)


state 193

    (21) n_param -> SEMICOLON ID COLON TYPE n_param .

    RPAREN          reduce using rule 21 (n_param -> SEMICOLON ID COLON TYPE n_param .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 67 resolved using rule (bparen -> term)
WARNING: rejected rule (paren -> term) in state 67
