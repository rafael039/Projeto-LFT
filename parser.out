Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOLEAN
    CHAR
    NUMBER_EXPONENT
    NUMBER_FLOAT
    NUMBER_INT

Grammar

Rule 0     S' -> program
Rule 1     program -> subprogram
Rule 2     program -> subprogram program
Rule 3     subprogram -> FUNCTION ID decl_param IS body
Rule 4     subprogram -> PROCEDURE ID IS decl body
Rule 5     subprogram -> PROCEDURE ID IS body
Rule 6     body -> BEGIN cmd_loop END ID SEMICOLON
Rule 7     decl -> var SEMICOLON decl
Rule 8     decl -> var SEMICOLON
Rule 9     var -> ID COMMA TYPE ASSIGN ID
Rule 10    var -> ID COLON TYPE
Rule 11    var -> var_loop ID COLON TYPE
Rule 12    var -> array
Rule 13    var_loop -> var_loop ID COMMA
Rule 14    var_loop -> ID COMMA
Rule 15    decl_param -> LPAREN param RPAREN
Rule 16    decl_param -> LPAREN param RPAREN RETURN TYPE
Rule 17    param -> ID COLON TYPE SEMICOLON param
Rule 18    param -> ID COLON TYPE SEMICOLON
Rule 19    function_call -> ID param_pass SEMICOLON
Rule 20    function_call -> ID LPAREN RPAREN SEMICOLON
Rule 21    function_call_exp -> ID param_pass
Rule 22    function_call_exp -> ID LPAREN RPAREN
Rule 23    param_pass -> expression COMMA param_pass
Rule 24    param_pass -> expression
Rule 25    cmd -> if_statement
Rule 26    cmd -> repeat_statement
Rule 27    cmd -> puts
Rule 28    cmd -> return
Rule 29    cmd -> assign
Rule 30    cmd -> function_call
Rule 31    cmd_loop -> cmd_loop cmd
Rule 32    cmd_loop -> cmd
Rule 33    puts -> PUTS LPAREN STRING RPAREN SEMICOLON
Rule 34    if_statement -> IF expression THEN cmd_loop if_statement_loop
Rule 35    if_statement_loop -> ELSIF expression cmd_loop if_statement_loop
Rule 36    if_statement_loop -> ELSE cmd_loop END IF SEMICOLON
Rule 37    if_statement_loop -> END IF SEMICOLON
Rule 38    repeat_statement -> loop_statement
Rule 39    repeat_statement -> for_statement
Rule 40    repeat_statement -> while_statement
Rule 41    loop_statement -> LOOP cmd_loop END LOOP SEMICOLON
Rule 42    while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON
Rule 43    for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
Rule 44    range -> ID DOTDOT ID
Rule 45    assign -> ID ASSIGN op_arithmetic SEMICOLON
Rule 46    expression -> expression AND or_exp
Rule 47    expression -> or_exp
Rule 48    or_exp -> or_exp OR comp_exp
Rule 49    or_exp -> comp_exp
Rule 50    comp_exp -> comp_exp comp_op op_arithmetic
Rule 51    comp_exp -> op_arithmetic
Rule 52    comp_op -> GREATERTHAN
Rule 53    comp_op -> GREATERTHANEQUAL
Rule 54    comp_op -> LESSTHAN
Rule 55    comp_op -> LESSTHANEQUAL
Rule 56    comp_op -> NOTEQUAL
Rule 57    comp_op -> EQUAL
Rule 58    op_arithmetic -> op_arithmetic PLUS factor
Rule 59    op_arithmetic -> op_arithmetic MINUS factor
Rule 60    op_arithmetic -> factor
Rule 61    factor -> factor TIMES power
Rule 62    factor -> factor DIVIDE power
Rule 63    factor -> power
Rule 64    power -> power POWER unary
Rule 65    power -> unary
Rule 66    unary -> PLUS term
Rule 67    unary -> MINUS term
Rule 68    unary -> term
Rule 69    term -> ID
Rule 70    term -> function_call_exp
Rule 71    term -> LPAREN expression RPAREN
Rule 72    array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON
Rule 73    return -> RETURN expression SEMICOLON

Terminals, with rules where they appear

AND                  : 46
ARRAY                : 72
ASSIGN               : 9 45
BEGIN                : 6
BOOLEAN              : 
CHAR                 : 
COLON                : 10 11 17 18
COMMA                : 9 13 14 23
DIVIDE               : 62
DOTDOT               : 44
ELSE                 : 36
ELSIF                : 35
END                  : 6 36 37 41 42 43
EQUAL                : 57
FOR                  : 43
FUNCTION             : 3
GREATERTHAN          : 52
GREATERTHANEQUAL     : 53
ID                   : 3 4 5 6 9 9 10 11 13 14 17 18 19 20 21 22 43 44 44 45 69 72
IF                   : 34 36 37
IN                   : 43
IS                   : 3 4 5 72
LESSTHAN             : 54
LESSTHANEQUAL        : 55
LOOP                 : 41 41 42 42 43 43
LPAREN               : 15 16 20 22 33 71 72
MINUS                : 59 67
NOTEQUAL             : 56
NUMBER_EXPONENT      : 
NUMBER_FLOAT         : 
NUMBER_INT           : 
OF                   : 72
OR                   : 48
PLUS                 : 58 66
POWER                : 64
PROCEDURE            : 4 5
PUTS                 : 33
RETURN               : 16 73
RPAREN               : 15 16 20 22 33 71 72
SEMICOLON            : 6 7 8 17 18 19 20 33 36 37 41 42 43 45 72 73
STRING               : 33
THEN                 : 34
TIMES                : 61
TYPE                 : 9 10 11 16 17 18 72 72
WHILE                : 42
error                : 

Nonterminals, with rules where they appear

array                : 12
assign               : 29
body                 : 3 4 5
cmd                  : 31 32
cmd_loop             : 6 31 34 35 36 41 42 43
comp_exp             : 48 49 50
comp_op              : 50
decl                 : 4 7
decl_param           : 3
expression           : 23 24 34 35 42 46 71 73
factor               : 58 59 60 61 62
for_statement        : 39
function_call        : 30
function_call_exp    : 70
if_statement         : 25
if_statement_loop    : 34 35
loop_statement       : 38
op_arithmetic        : 45 50 51 58 59
or_exp               : 46 47 48
param                : 15 16 17
param_pass           : 19 21 23
power                : 61 62 63 64
program              : 2 0
puts                 : 27
range                : 43 72
repeat_statement     : 26
return               : 28
subprogram           : 1 2
term                 : 66 67 68
unary                : 64 65
var                  : 7 8
var_loop             : 11 13
while_statement      : 40

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . subprogram
    (2) program -> . subprogram program
    (3) subprogram -> . FUNCTION ID decl_param IS body
    (4) subprogram -> . PROCEDURE ID IS decl body
    (5) subprogram -> . PROCEDURE ID IS body

    FUNCTION        shift and go to state 3
    PROCEDURE       shift and go to state 4

    program                        shift and go to state 1
    subprogram                     shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> subprogram .
    (2) program -> subprogram . program
    (1) program -> . subprogram
    (2) program -> . subprogram program
    (3) subprogram -> . FUNCTION ID decl_param IS body
    (4) subprogram -> . PROCEDURE ID IS decl body
    (5) subprogram -> . PROCEDURE ID IS body

    $end            reduce using rule 1 (program -> subprogram .)
    FUNCTION        shift and go to state 3
    PROCEDURE       shift and go to state 4

    subprogram                     shift and go to state 2
    program                        shift and go to state 5

state 3

    (3) subprogram -> FUNCTION . ID decl_param IS body

    ID              shift and go to state 6


state 4

    (4) subprogram -> PROCEDURE . ID IS decl body
    (5) subprogram -> PROCEDURE . ID IS body

    ID              shift and go to state 7


state 5

    (2) program -> subprogram program .

    $end            reduce using rule 2 (program -> subprogram program .)


state 6

    (3) subprogram -> FUNCTION ID . decl_param IS body
    (15) decl_param -> . LPAREN param RPAREN
    (16) decl_param -> . LPAREN param RPAREN RETURN TYPE

    LPAREN          shift and go to state 9

    decl_param                     shift and go to state 8

state 7

    (4) subprogram -> PROCEDURE ID . IS decl body
    (5) subprogram -> PROCEDURE ID . IS body

    IS              shift and go to state 10


state 8

    (3) subprogram -> FUNCTION ID decl_param . IS body

    IS              shift and go to state 11


state 9

    (15) decl_param -> LPAREN . param RPAREN
    (16) decl_param -> LPAREN . param RPAREN RETURN TYPE
    (17) param -> . ID COLON TYPE SEMICOLON param
    (18) param -> . ID COLON TYPE SEMICOLON

    ID              shift and go to state 13

    param                          shift and go to state 12

state 10

    (4) subprogram -> PROCEDURE ID IS . decl body
    (5) subprogram -> PROCEDURE ID IS . body
    (7) decl -> . var SEMICOLON decl
    (8) decl -> . var SEMICOLON
    (6) body -> . BEGIN cmd_loop END ID SEMICOLON
    (9) var -> . ID COMMA TYPE ASSIGN ID
    (10) var -> . ID COLON TYPE
    (11) var -> . var_loop ID COLON TYPE
    (12) var -> . array
    (13) var_loop -> . var_loop ID COMMA
    (14) var_loop -> . ID COMMA
    (72) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           shift and go to state 18
    ID              shift and go to state 14
    TYPE            shift and go to state 19

    decl                           shift and go to state 15
    body                           shift and go to state 16
    var                            shift and go to state 17
    var_loop                       shift and go to state 20
    array                          shift and go to state 21

state 11

    (3) subprogram -> FUNCTION ID decl_param IS . body
    (6) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 18

    body                           shift and go to state 22

state 12

    (15) decl_param -> LPAREN param . RPAREN
    (16) decl_param -> LPAREN param . RPAREN RETURN TYPE

    RPAREN          shift and go to state 23


state 13

    (17) param -> ID . COLON TYPE SEMICOLON param
    (18) param -> ID . COLON TYPE SEMICOLON

    COLON           shift and go to state 24


state 14

    (9) var -> ID . COMMA TYPE ASSIGN ID
    (10) var -> ID . COLON TYPE
    (14) var_loop -> ID . COMMA

    COMMA           shift and go to state 25
    COLON           shift and go to state 26


state 15

    (4) subprogram -> PROCEDURE ID IS decl . body
    (6) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 18

    body                           shift and go to state 27

state 16

    (5) subprogram -> PROCEDURE ID IS body .

    FUNCTION        reduce using rule 5 (subprogram -> PROCEDURE ID IS body .)
    PROCEDURE       reduce using rule 5 (subprogram -> PROCEDURE ID IS body .)
    $end            reduce using rule 5 (subprogram -> PROCEDURE ID IS body .)


state 17

    (7) decl -> var . SEMICOLON decl
    (8) decl -> var . SEMICOLON

    SEMICOLON       shift and go to state 28


state 18

    (6) body -> BEGIN . cmd_loop END ID SEMICOLON
    (31) cmd_loop -> . cmd_loop cmd
    (32) cmd_loop -> . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 29
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 19

    (72) array -> TYPE . ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    ID              shift and go to state 47


state 20

    (11) var -> var_loop . ID COLON TYPE
    (13) var_loop -> var_loop . ID COMMA

    ID              shift and go to state 48


state 21

    (12) var -> array .

    SEMICOLON       reduce using rule 12 (var -> array .)


state 22

    (3) subprogram -> FUNCTION ID decl_param IS body .

    FUNCTION        reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS body .)
    PROCEDURE       reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS body .)
    $end            reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS body .)


state 23

    (15) decl_param -> LPAREN param RPAREN .
    (16) decl_param -> LPAREN param RPAREN . RETURN TYPE

    IS              reduce using rule 15 (decl_param -> LPAREN param RPAREN .)
    RETURN          shift and go to state 49


state 24

    (17) param -> ID COLON . TYPE SEMICOLON param
    (18) param -> ID COLON . TYPE SEMICOLON

    TYPE            shift and go to state 50


state 25

    (9) var -> ID COMMA . TYPE ASSIGN ID
    (14) var_loop -> ID COMMA .

    TYPE            shift and go to state 51
    ID              reduce using rule 14 (var_loop -> ID COMMA .)


state 26

    (10) var -> ID COLON . TYPE

    TYPE            shift and go to state 52


state 27

    (4) subprogram -> PROCEDURE ID IS decl body .

    FUNCTION        reduce using rule 4 (subprogram -> PROCEDURE ID IS decl body .)
    PROCEDURE       reduce using rule 4 (subprogram -> PROCEDURE ID IS decl body .)
    $end            reduce using rule 4 (subprogram -> PROCEDURE ID IS decl body .)


state 28

    (7) decl -> var SEMICOLON . decl
    (8) decl -> var SEMICOLON .
    (7) decl -> . var SEMICOLON decl
    (8) decl -> . var SEMICOLON
    (9) var -> . ID COMMA TYPE ASSIGN ID
    (10) var -> . ID COLON TYPE
    (11) var -> . var_loop ID COLON TYPE
    (12) var -> . array
    (13) var_loop -> . var_loop ID COMMA
    (14) var_loop -> . ID COMMA
    (72) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           reduce using rule 8 (decl -> var SEMICOLON .)
    ID              shift and go to state 14
    TYPE            shift and go to state 19

    var                            shift and go to state 17
    decl                           shift and go to state 53
    var_loop                       shift and go to state 20
    array                          shift and go to state 21

state 29

    (6) body -> BEGIN cmd_loop . END ID SEMICOLON
    (31) cmd_loop -> cmd_loop . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 54
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 55
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 30

    (45) assign -> ID . ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> ID . param_pass SEMICOLON
    (20) function_call -> ID . LPAREN RPAREN SEMICOLON
    (23) param_pass -> . expression COMMA param_pass
    (24) param_pass -> . expression
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    ASSIGN          shift and go to state 57
    LPAREN          shift and go to state 60
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56

    op_arithmetic                  shift and go to state 58
    param_pass                     shift and go to state 59
    expression                     shift and go to state 61
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 31

    (32) cmd_loop -> cmd .

    END             reduce using rule 32 (cmd_loop -> cmd .)
    IF              reduce using rule 32 (cmd_loop -> cmd .)
    PUTS            reduce using rule 32 (cmd_loop -> cmd .)
    RETURN          reduce using rule 32 (cmd_loop -> cmd .)
    ID              reduce using rule 32 (cmd_loop -> cmd .)
    LOOP            reduce using rule 32 (cmd_loop -> cmd .)
    FOR             reduce using rule 32 (cmd_loop -> cmd .)
    WHILE           reduce using rule 32 (cmd_loop -> cmd .)
    ELSIF           reduce using rule 32 (cmd_loop -> cmd .)
    ELSE            reduce using rule 32 (cmd_loop -> cmd .)


state 32

    (25) cmd -> if_statement .

    END             reduce using rule 25 (cmd -> if_statement .)
    IF              reduce using rule 25 (cmd -> if_statement .)
    PUTS            reduce using rule 25 (cmd -> if_statement .)
    RETURN          reduce using rule 25 (cmd -> if_statement .)
    ID              reduce using rule 25 (cmd -> if_statement .)
    LOOP            reduce using rule 25 (cmd -> if_statement .)
    FOR             reduce using rule 25 (cmd -> if_statement .)
    WHILE           reduce using rule 25 (cmd -> if_statement .)
    ELSIF           reduce using rule 25 (cmd -> if_statement .)
    ELSE            reduce using rule 25 (cmd -> if_statement .)


state 33

    (26) cmd -> repeat_statement .

    END             reduce using rule 26 (cmd -> repeat_statement .)
    IF              reduce using rule 26 (cmd -> repeat_statement .)
    PUTS            reduce using rule 26 (cmd -> repeat_statement .)
    RETURN          reduce using rule 26 (cmd -> repeat_statement .)
    ID              reduce using rule 26 (cmd -> repeat_statement .)
    LOOP            reduce using rule 26 (cmd -> repeat_statement .)
    FOR             reduce using rule 26 (cmd -> repeat_statement .)
    WHILE           reduce using rule 26 (cmd -> repeat_statement .)
    ELSIF           reduce using rule 26 (cmd -> repeat_statement .)
    ELSE            reduce using rule 26 (cmd -> repeat_statement .)


state 34

    (27) cmd -> puts .

    END             reduce using rule 27 (cmd -> puts .)
    IF              reduce using rule 27 (cmd -> puts .)
    PUTS            reduce using rule 27 (cmd -> puts .)
    RETURN          reduce using rule 27 (cmd -> puts .)
    ID              reduce using rule 27 (cmd -> puts .)
    LOOP            reduce using rule 27 (cmd -> puts .)
    FOR             reduce using rule 27 (cmd -> puts .)
    WHILE           reduce using rule 27 (cmd -> puts .)
    ELSIF           reduce using rule 27 (cmd -> puts .)
    ELSE            reduce using rule 27 (cmd -> puts .)


state 35

    (28) cmd -> return .

    END             reduce using rule 28 (cmd -> return .)
    IF              reduce using rule 28 (cmd -> return .)
    PUTS            reduce using rule 28 (cmd -> return .)
    RETURN          reduce using rule 28 (cmd -> return .)
    ID              reduce using rule 28 (cmd -> return .)
    LOOP            reduce using rule 28 (cmd -> return .)
    FOR             reduce using rule 28 (cmd -> return .)
    WHILE           reduce using rule 28 (cmd -> return .)
    ELSIF           reduce using rule 28 (cmd -> return .)
    ELSE            reduce using rule 28 (cmd -> return .)


state 36

    (29) cmd -> assign .

    END             reduce using rule 29 (cmd -> assign .)
    IF              reduce using rule 29 (cmd -> assign .)
    PUTS            reduce using rule 29 (cmd -> assign .)
    RETURN          reduce using rule 29 (cmd -> assign .)
    ID              reduce using rule 29 (cmd -> assign .)
    LOOP            reduce using rule 29 (cmd -> assign .)
    FOR             reduce using rule 29 (cmd -> assign .)
    WHILE           reduce using rule 29 (cmd -> assign .)
    ELSIF           reduce using rule 29 (cmd -> assign .)
    ELSE            reduce using rule 29 (cmd -> assign .)


state 37

    (30) cmd -> function_call .

    END             reduce using rule 30 (cmd -> function_call .)
    IF              reduce using rule 30 (cmd -> function_call .)
    PUTS            reduce using rule 30 (cmd -> function_call .)
    RETURN          reduce using rule 30 (cmd -> function_call .)
    ID              reduce using rule 30 (cmd -> function_call .)
    LOOP            reduce using rule 30 (cmd -> function_call .)
    FOR             reduce using rule 30 (cmd -> function_call .)
    WHILE           reduce using rule 30 (cmd -> function_call .)
    ELSIF           reduce using rule 30 (cmd -> function_call .)
    ELSE            reduce using rule 30 (cmd -> function_call .)


state 38

    (34) if_statement -> IF . expression THEN cmd_loop if_statement_loop
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 71
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 39

    (38) repeat_statement -> loop_statement .

    END             reduce using rule 38 (repeat_statement -> loop_statement .)
    IF              reduce using rule 38 (repeat_statement -> loop_statement .)
    PUTS            reduce using rule 38 (repeat_statement -> loop_statement .)
    RETURN          reduce using rule 38 (repeat_statement -> loop_statement .)
    ID              reduce using rule 38 (repeat_statement -> loop_statement .)
    LOOP            reduce using rule 38 (repeat_statement -> loop_statement .)
    FOR             reduce using rule 38 (repeat_statement -> loop_statement .)
    WHILE           reduce using rule 38 (repeat_statement -> loop_statement .)
    ELSIF           reduce using rule 38 (repeat_statement -> loop_statement .)
    ELSE            reduce using rule 38 (repeat_statement -> loop_statement .)


state 40

    (39) repeat_statement -> for_statement .

    END             reduce using rule 39 (repeat_statement -> for_statement .)
    IF              reduce using rule 39 (repeat_statement -> for_statement .)
    PUTS            reduce using rule 39 (repeat_statement -> for_statement .)
    RETURN          reduce using rule 39 (repeat_statement -> for_statement .)
    ID              reduce using rule 39 (repeat_statement -> for_statement .)
    LOOP            reduce using rule 39 (repeat_statement -> for_statement .)
    FOR             reduce using rule 39 (repeat_statement -> for_statement .)
    WHILE           reduce using rule 39 (repeat_statement -> for_statement .)
    ELSIF           reduce using rule 39 (repeat_statement -> for_statement .)
    ELSE            reduce using rule 39 (repeat_statement -> for_statement .)


state 41

    (40) repeat_statement -> while_statement .

    END             reduce using rule 40 (repeat_statement -> while_statement .)
    IF              reduce using rule 40 (repeat_statement -> while_statement .)
    PUTS            reduce using rule 40 (repeat_statement -> while_statement .)
    RETURN          reduce using rule 40 (repeat_statement -> while_statement .)
    ID              reduce using rule 40 (repeat_statement -> while_statement .)
    LOOP            reduce using rule 40 (repeat_statement -> while_statement .)
    FOR             reduce using rule 40 (repeat_statement -> while_statement .)
    WHILE           reduce using rule 40 (repeat_statement -> while_statement .)
    ELSIF           reduce using rule 40 (repeat_statement -> while_statement .)
    ELSE            reduce using rule 40 (repeat_statement -> while_statement .)


state 42

    (33) puts -> PUTS . LPAREN STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 73


state 43

    (73) return -> RETURN . expression SEMICOLON
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 74
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 44

    (41) loop_statement -> LOOP . cmd_loop END LOOP SEMICOLON
    (31) cmd_loop -> . cmd_loop cmd
    (32) cmd_loop -> . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 75
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 45

    (43) for_statement -> FOR . ID IN range LOOP cmd_loop END LOOP SEMICOLON

    ID              shift and go to state 76


state 46

    (42) while_statement -> WHILE . expression LOOP cmd_loop END LOOP SEMICOLON
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 77
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 47

    (72) array -> TYPE ID . IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    IS              shift and go to state 78


state 48

    (11) var -> var_loop ID . COLON TYPE
    (13) var_loop -> var_loop ID . COMMA

    COLON           shift and go to state 79
    COMMA           shift and go to state 80


state 49

    (16) decl_param -> LPAREN param RPAREN RETURN . TYPE

    TYPE            shift and go to state 81


state 50

    (17) param -> ID COLON TYPE . SEMICOLON param
    (18) param -> ID COLON TYPE . SEMICOLON

    SEMICOLON       shift and go to state 82


state 51

    (9) var -> ID COMMA TYPE . ASSIGN ID

    ASSIGN          shift and go to state 83


state 52

    (10) var -> ID COLON TYPE .

    SEMICOLON       reduce using rule 10 (var -> ID COLON TYPE .)


state 53

    (7) decl -> var SEMICOLON decl .

    BEGIN           reduce using rule 7 (decl -> var SEMICOLON decl .)


state 54

    (6) body -> BEGIN cmd_loop END . ID SEMICOLON

    ID              shift and go to state 84


state 55

    (31) cmd_loop -> cmd_loop cmd .

    END             reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    IF              reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    PUTS            reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    RETURN          reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    ID              reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    LOOP            reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    FOR             reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    WHILE           reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    ELSIF           reduce using rule 31 (cmd_loop -> cmd_loop cmd .)
    ELSE            reduce using rule 31 (cmd_loop -> cmd_loop cmd .)


state 56

    (69) term -> ID .
    (21) function_call_exp -> ID . param_pass
    (22) function_call_exp -> ID . LPAREN RPAREN
    (23) param_pass -> . expression COMMA param_pass
    (24) param_pass -> . expression
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    POWER           reduce using rule 69 (term -> ID .)
    TIMES           reduce using rule 69 (term -> ID .)
    DIVIDE          reduce using rule 69 (term -> ID .)
    GREATERTHAN     reduce using rule 69 (term -> ID .)
    GREATERTHANEQUAL reduce using rule 69 (term -> ID .)
    LESSTHAN        reduce using rule 69 (term -> ID .)
    LESSTHANEQUAL   reduce using rule 69 (term -> ID .)
    NOTEQUAL        reduce using rule 69 (term -> ID .)
    EQUAL           reduce using rule 69 (term -> ID .)
    OR              reduce using rule 69 (term -> ID .)
    COMMA           reduce using rule 69 (term -> ID .)
    AND             reduce using rule 69 (term -> ID .)
    SEMICOLON       reduce using rule 69 (term -> ID .)
    THEN            reduce using rule 69 (term -> ID .)
    LOOP            reduce using rule 69 (term -> ID .)
    RPAREN          reduce using rule 69 (term -> ID .)
    IF              reduce using rule 69 (term -> ID .)
    PUTS            reduce using rule 69 (term -> ID .)
    RETURN          reduce using rule 69 (term -> ID .)
    FOR             reduce using rule 69 (term -> ID .)
    WHILE           reduce using rule 69 (term -> ID .)
    LPAREN          shift and go to state 86
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56

  ! PLUS            [ reduce using rule 69 (term -> ID .) ]
  ! MINUS           [ reduce using rule 69 (term -> ID .) ]
  ! ID              [ reduce using rule 69 (term -> ID .) ]

    param_pass                     shift and go to state 85
    expression                     shift and go to state 61
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 57

    (45) assign -> ID ASSIGN . op_arithmetic SEMICOLON
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    op_arithmetic                  shift and go to state 87
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 58

    (51) comp_exp -> op_arithmetic .
    (58) op_arithmetic -> op_arithmetic . PLUS factor
    (59) op_arithmetic -> op_arithmetic . MINUS factor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GREATERTHAN     reduce using rule 51 (comp_exp -> op_arithmetic .)
    GREATERTHANEQUAL reduce using rule 51 (comp_exp -> op_arithmetic .)
    LESSTHAN        reduce using rule 51 (comp_exp -> op_arithmetic .)
    LESSTHANEQUAL   reduce using rule 51 (comp_exp -> op_arithmetic .)
    NOTEQUAL        reduce using rule 51 (comp_exp -> op_arithmetic .)
    EQUAL           reduce using rule 51 (comp_exp -> op_arithmetic .)
    OR              reduce using rule 51 (comp_exp -> op_arithmetic .)
    COMMA           reduce using rule 51 (comp_exp -> op_arithmetic .)
    AND             reduce using rule 51 (comp_exp -> op_arithmetic .)
    SEMICOLON       reduce using rule 51 (comp_exp -> op_arithmetic .)
    THEN            reduce using rule 51 (comp_exp -> op_arithmetic .)
    LOOP            reduce using rule 51 (comp_exp -> op_arithmetic .)
    POWER           reduce using rule 51 (comp_exp -> op_arithmetic .)
    TIMES           reduce using rule 51 (comp_exp -> op_arithmetic .)
    DIVIDE          reduce using rule 51 (comp_exp -> op_arithmetic .)
    RPAREN          reduce using rule 51 (comp_exp -> op_arithmetic .)
    IF              reduce using rule 51 (comp_exp -> op_arithmetic .)
    PUTS            reduce using rule 51 (comp_exp -> op_arithmetic .)
    RETURN          reduce using rule 51 (comp_exp -> op_arithmetic .)
    ID              reduce using rule 51 (comp_exp -> op_arithmetic .)
    FOR             reduce using rule 51 (comp_exp -> op_arithmetic .)
    WHILE           reduce using rule 51 (comp_exp -> op_arithmetic .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 89

  ! PLUS            [ reduce using rule 51 (comp_exp -> op_arithmetic .) ]
  ! MINUS           [ reduce using rule 51 (comp_exp -> op_arithmetic .) ]


state 59

    (19) function_call -> ID param_pass . SEMICOLON

    SEMICOLON       shift and go to state 90


state 60

    (20) function_call -> ID LPAREN . RPAREN SEMICOLON
    (71) term -> LPAREN . expression RPAREN
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 91
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 92
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 61

    (23) param_pass -> expression . COMMA param_pass
    (24) param_pass -> expression .
    (46) expression -> expression . AND or_exp

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for AND resolved as shift
    COMMA           shift and go to state 93
    SEMICOLON       reduce using rule 24 (param_pass -> expression .)
    POWER           reduce using rule 24 (param_pass -> expression .)
    TIMES           reduce using rule 24 (param_pass -> expression .)
    DIVIDE          reduce using rule 24 (param_pass -> expression .)
    PLUS            reduce using rule 24 (param_pass -> expression .)
    MINUS           reduce using rule 24 (param_pass -> expression .)
    GREATERTHAN     reduce using rule 24 (param_pass -> expression .)
    GREATERTHANEQUAL reduce using rule 24 (param_pass -> expression .)
    LESSTHAN        reduce using rule 24 (param_pass -> expression .)
    LESSTHANEQUAL   reduce using rule 24 (param_pass -> expression .)
    NOTEQUAL        reduce using rule 24 (param_pass -> expression .)
    EQUAL           reduce using rule 24 (param_pass -> expression .)
    OR              reduce using rule 24 (param_pass -> expression .)
    THEN            reduce using rule 24 (param_pass -> expression .)
    LOOP            reduce using rule 24 (param_pass -> expression .)
    RPAREN          reduce using rule 24 (param_pass -> expression .)
    IF              reduce using rule 24 (param_pass -> expression .)
    PUTS            reduce using rule 24 (param_pass -> expression .)
    RETURN          reduce using rule 24 (param_pass -> expression .)
    ID              reduce using rule 24 (param_pass -> expression .)
    FOR             reduce using rule 24 (param_pass -> expression .)
    WHILE           reduce using rule 24 (param_pass -> expression .)
    AND             shift and go to state 94

  ! COMMA           [ reduce using rule 24 (param_pass -> expression .) ]
  ! AND             [ reduce using rule 24 (param_pass -> expression .) ]


state 62

    (47) expression -> or_exp .
    (48) or_exp -> or_exp . OR comp_exp

  ! shift/reduce conflict for OR resolved as shift
    COMMA           reduce using rule 47 (expression -> or_exp .)
    AND             reduce using rule 47 (expression -> or_exp .)
    SEMICOLON       reduce using rule 47 (expression -> or_exp .)
    THEN            reduce using rule 47 (expression -> or_exp .)
    LOOP            reduce using rule 47 (expression -> or_exp .)
    POWER           reduce using rule 47 (expression -> or_exp .)
    TIMES           reduce using rule 47 (expression -> or_exp .)
    DIVIDE          reduce using rule 47 (expression -> or_exp .)
    PLUS            reduce using rule 47 (expression -> or_exp .)
    MINUS           reduce using rule 47 (expression -> or_exp .)
    GREATERTHAN     reduce using rule 47 (expression -> or_exp .)
    GREATERTHANEQUAL reduce using rule 47 (expression -> or_exp .)
    LESSTHAN        reduce using rule 47 (expression -> or_exp .)
    LESSTHANEQUAL   reduce using rule 47 (expression -> or_exp .)
    NOTEQUAL        reduce using rule 47 (expression -> or_exp .)
    EQUAL           reduce using rule 47 (expression -> or_exp .)
    RPAREN          reduce using rule 47 (expression -> or_exp .)
    IF              reduce using rule 47 (expression -> or_exp .)
    PUTS            reduce using rule 47 (expression -> or_exp .)
    RETURN          reduce using rule 47 (expression -> or_exp .)
    ID              reduce using rule 47 (expression -> or_exp .)
    FOR             reduce using rule 47 (expression -> or_exp .)
    WHILE           reduce using rule 47 (expression -> or_exp .)
    OR              shift and go to state 95

  ! OR              [ reduce using rule 47 (expression -> or_exp .) ]


state 63

    (49) or_exp -> comp_exp .
    (50) comp_exp -> comp_exp . comp_op op_arithmetic
    (52) comp_op -> . GREATERTHAN
    (53) comp_op -> . GREATERTHANEQUAL
    (54) comp_op -> . LESSTHAN
    (55) comp_op -> . LESSTHANEQUAL
    (56) comp_op -> . NOTEQUAL
    (57) comp_op -> . EQUAL

  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for LESSTHANEQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
    OR              reduce using rule 49 (or_exp -> comp_exp .)
    COMMA           reduce using rule 49 (or_exp -> comp_exp .)
    AND             reduce using rule 49 (or_exp -> comp_exp .)
    SEMICOLON       reduce using rule 49 (or_exp -> comp_exp .)
    THEN            reduce using rule 49 (or_exp -> comp_exp .)
    LOOP            reduce using rule 49 (or_exp -> comp_exp .)
    POWER           reduce using rule 49 (or_exp -> comp_exp .)
    TIMES           reduce using rule 49 (or_exp -> comp_exp .)
    DIVIDE          reduce using rule 49 (or_exp -> comp_exp .)
    PLUS            reduce using rule 49 (or_exp -> comp_exp .)
    MINUS           reduce using rule 49 (or_exp -> comp_exp .)
    RPAREN          reduce using rule 49 (or_exp -> comp_exp .)
    IF              reduce using rule 49 (or_exp -> comp_exp .)
    PUTS            reduce using rule 49 (or_exp -> comp_exp .)
    RETURN          reduce using rule 49 (or_exp -> comp_exp .)
    ID              reduce using rule 49 (or_exp -> comp_exp .)
    FOR             reduce using rule 49 (or_exp -> comp_exp .)
    WHILE           reduce using rule 49 (or_exp -> comp_exp .)
    GREATERTHAN     shift and go to state 97
    GREATERTHANEQUAL shift and go to state 98
    LESSTHAN        shift and go to state 99
    LESSTHANEQUAL   shift and go to state 100
    NOTEQUAL        shift and go to state 101
    EQUAL           shift and go to state 102

  ! GREATERTHAN     [ reduce using rule 49 (or_exp -> comp_exp .) ]
  ! GREATERTHANEQUAL [ reduce using rule 49 (or_exp -> comp_exp .) ]
  ! LESSTHAN        [ reduce using rule 49 (or_exp -> comp_exp .) ]
  ! LESSTHANEQUAL   [ reduce using rule 49 (or_exp -> comp_exp .) ]
  ! NOTEQUAL        [ reduce using rule 49 (or_exp -> comp_exp .) ]
  ! EQUAL           [ reduce using rule 49 (or_exp -> comp_exp .) ]

    comp_op                        shift and go to state 96

state 64

    (66) unary -> PLUS . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    term                           shift and go to state 103
    function_call_exp              shift and go to state 70

state 65

    (60) op_arithmetic -> factor .
    (61) factor -> factor . TIMES power
    (62) factor -> factor . DIVIDE power

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 60 (op_arithmetic -> factor .)
    MINUS           reduce using rule 60 (op_arithmetic -> factor .)
    GREATERTHAN     reduce using rule 60 (op_arithmetic -> factor .)
    GREATERTHANEQUAL reduce using rule 60 (op_arithmetic -> factor .)
    LESSTHAN        reduce using rule 60 (op_arithmetic -> factor .)
    LESSTHANEQUAL   reduce using rule 60 (op_arithmetic -> factor .)
    NOTEQUAL        reduce using rule 60 (op_arithmetic -> factor .)
    EQUAL           reduce using rule 60 (op_arithmetic -> factor .)
    OR              reduce using rule 60 (op_arithmetic -> factor .)
    COMMA           reduce using rule 60 (op_arithmetic -> factor .)
    AND             reduce using rule 60 (op_arithmetic -> factor .)
    SEMICOLON       reduce using rule 60 (op_arithmetic -> factor .)
    THEN            reduce using rule 60 (op_arithmetic -> factor .)
    LOOP            reduce using rule 60 (op_arithmetic -> factor .)
    POWER           reduce using rule 60 (op_arithmetic -> factor .)
    RPAREN          reduce using rule 60 (op_arithmetic -> factor .)
    IF              reduce using rule 60 (op_arithmetic -> factor .)
    PUTS            reduce using rule 60 (op_arithmetic -> factor .)
    RETURN          reduce using rule 60 (op_arithmetic -> factor .)
    ID              reduce using rule 60 (op_arithmetic -> factor .)
    FOR             reduce using rule 60 (op_arithmetic -> factor .)
    WHILE           reduce using rule 60 (op_arithmetic -> factor .)
    TIMES           shift and go to state 104
    DIVIDE          shift and go to state 105

  ! TIMES           [ reduce using rule 60 (op_arithmetic -> factor .) ]
  ! DIVIDE          [ reduce using rule 60 (op_arithmetic -> factor .) ]


state 66

    (67) unary -> MINUS . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    term                           shift and go to state 106
    function_call_exp              shift and go to state 70

state 67

    (63) factor -> power .
    (64) power -> power . POWER unary

  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 63 (factor -> power .)
    DIVIDE          reduce using rule 63 (factor -> power .)
    PLUS            reduce using rule 63 (factor -> power .)
    MINUS           reduce using rule 63 (factor -> power .)
    GREATERTHAN     reduce using rule 63 (factor -> power .)
    GREATERTHANEQUAL reduce using rule 63 (factor -> power .)
    LESSTHAN        reduce using rule 63 (factor -> power .)
    LESSTHANEQUAL   reduce using rule 63 (factor -> power .)
    NOTEQUAL        reduce using rule 63 (factor -> power .)
    EQUAL           reduce using rule 63 (factor -> power .)
    OR              reduce using rule 63 (factor -> power .)
    COMMA           reduce using rule 63 (factor -> power .)
    AND             reduce using rule 63 (factor -> power .)
    SEMICOLON       reduce using rule 63 (factor -> power .)
    THEN            reduce using rule 63 (factor -> power .)
    LOOP            reduce using rule 63 (factor -> power .)
    RPAREN          reduce using rule 63 (factor -> power .)
    IF              reduce using rule 63 (factor -> power .)
    PUTS            reduce using rule 63 (factor -> power .)
    RETURN          reduce using rule 63 (factor -> power .)
    ID              reduce using rule 63 (factor -> power .)
    FOR             reduce using rule 63 (factor -> power .)
    WHILE           reduce using rule 63 (factor -> power .)
    POWER           shift and go to state 107

  ! POWER           [ reduce using rule 63 (factor -> power .) ]


state 68

    (65) power -> unary .

    POWER           reduce using rule 65 (power -> unary .)
    TIMES           reduce using rule 65 (power -> unary .)
    DIVIDE          reduce using rule 65 (power -> unary .)
    PLUS            reduce using rule 65 (power -> unary .)
    MINUS           reduce using rule 65 (power -> unary .)
    GREATERTHAN     reduce using rule 65 (power -> unary .)
    GREATERTHANEQUAL reduce using rule 65 (power -> unary .)
    LESSTHAN        reduce using rule 65 (power -> unary .)
    LESSTHANEQUAL   reduce using rule 65 (power -> unary .)
    NOTEQUAL        reduce using rule 65 (power -> unary .)
    EQUAL           reduce using rule 65 (power -> unary .)
    OR              reduce using rule 65 (power -> unary .)
    COMMA           reduce using rule 65 (power -> unary .)
    AND             reduce using rule 65 (power -> unary .)
    SEMICOLON       reduce using rule 65 (power -> unary .)
    THEN            reduce using rule 65 (power -> unary .)
    LOOP            reduce using rule 65 (power -> unary .)
    RPAREN          reduce using rule 65 (power -> unary .)
    IF              reduce using rule 65 (power -> unary .)
    PUTS            reduce using rule 65 (power -> unary .)
    RETURN          reduce using rule 65 (power -> unary .)
    ID              reduce using rule 65 (power -> unary .)
    FOR             reduce using rule 65 (power -> unary .)
    WHILE           reduce using rule 65 (power -> unary .)


state 69

    (68) unary -> term .

    POWER           reduce using rule 68 (unary -> term .)
    TIMES           reduce using rule 68 (unary -> term .)
    DIVIDE          reduce using rule 68 (unary -> term .)
    PLUS            reduce using rule 68 (unary -> term .)
    MINUS           reduce using rule 68 (unary -> term .)
    GREATERTHAN     reduce using rule 68 (unary -> term .)
    GREATERTHANEQUAL reduce using rule 68 (unary -> term .)
    LESSTHAN        reduce using rule 68 (unary -> term .)
    LESSTHANEQUAL   reduce using rule 68 (unary -> term .)
    NOTEQUAL        reduce using rule 68 (unary -> term .)
    EQUAL           reduce using rule 68 (unary -> term .)
    OR              reduce using rule 68 (unary -> term .)
    COMMA           reduce using rule 68 (unary -> term .)
    AND             reduce using rule 68 (unary -> term .)
    SEMICOLON       reduce using rule 68 (unary -> term .)
    THEN            reduce using rule 68 (unary -> term .)
    LOOP            reduce using rule 68 (unary -> term .)
    RPAREN          reduce using rule 68 (unary -> term .)
    IF              reduce using rule 68 (unary -> term .)
    PUTS            reduce using rule 68 (unary -> term .)
    RETURN          reduce using rule 68 (unary -> term .)
    ID              reduce using rule 68 (unary -> term .)
    FOR             reduce using rule 68 (unary -> term .)
    WHILE           reduce using rule 68 (unary -> term .)


state 70

    (70) term -> function_call_exp .

    POWER           reduce using rule 70 (term -> function_call_exp .)
    TIMES           reduce using rule 70 (term -> function_call_exp .)
    DIVIDE          reduce using rule 70 (term -> function_call_exp .)
    PLUS            reduce using rule 70 (term -> function_call_exp .)
    MINUS           reduce using rule 70 (term -> function_call_exp .)
    GREATERTHAN     reduce using rule 70 (term -> function_call_exp .)
    GREATERTHANEQUAL reduce using rule 70 (term -> function_call_exp .)
    LESSTHAN        reduce using rule 70 (term -> function_call_exp .)
    LESSTHANEQUAL   reduce using rule 70 (term -> function_call_exp .)
    NOTEQUAL        reduce using rule 70 (term -> function_call_exp .)
    EQUAL           reduce using rule 70 (term -> function_call_exp .)
    OR              reduce using rule 70 (term -> function_call_exp .)
    COMMA           reduce using rule 70 (term -> function_call_exp .)
    AND             reduce using rule 70 (term -> function_call_exp .)
    SEMICOLON       reduce using rule 70 (term -> function_call_exp .)
    THEN            reduce using rule 70 (term -> function_call_exp .)
    LOOP            reduce using rule 70 (term -> function_call_exp .)
    RPAREN          reduce using rule 70 (term -> function_call_exp .)
    IF              reduce using rule 70 (term -> function_call_exp .)
    PUTS            reduce using rule 70 (term -> function_call_exp .)
    RETURN          reduce using rule 70 (term -> function_call_exp .)
    ID              reduce using rule 70 (term -> function_call_exp .)
    FOR             reduce using rule 70 (term -> function_call_exp .)
    WHILE           reduce using rule 70 (term -> function_call_exp .)


state 71

    (34) if_statement -> IF expression . THEN cmd_loop if_statement_loop
    (46) expression -> expression . AND or_exp

    THEN            shift and go to state 108
    AND             shift and go to state 94


state 72

    (71) term -> LPAREN . expression RPAREN
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 92
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 73

    (33) puts -> PUTS LPAREN . STRING RPAREN SEMICOLON

    STRING          shift and go to state 109


state 74

    (73) return -> RETURN expression . SEMICOLON
    (46) expression -> expression . AND or_exp

    SEMICOLON       shift and go to state 110
    AND             shift and go to state 94


state 75

    (41) loop_statement -> LOOP cmd_loop . END LOOP SEMICOLON
    (31) cmd_loop -> cmd_loop . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 111
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 55
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 76

    (43) for_statement -> FOR ID . IN range LOOP cmd_loop END LOOP SEMICOLON

    IN              shift and go to state 112


state 77

    (42) while_statement -> WHILE expression . LOOP cmd_loop END LOOP SEMICOLON
    (46) expression -> expression . AND or_exp

    LOOP            shift and go to state 113
    AND             shift and go to state 94


state 78

    (72) array -> TYPE ID IS . ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    ARRAY           shift and go to state 114


state 79

    (11) var -> var_loop ID COLON . TYPE

    TYPE            shift and go to state 115


state 80

    (13) var_loop -> var_loop ID COMMA .

    ID              reduce using rule 13 (var_loop -> var_loop ID COMMA .)


state 81

    (16) decl_param -> LPAREN param RPAREN RETURN TYPE .

    IS              reduce using rule 16 (decl_param -> LPAREN param RPAREN RETURN TYPE .)


state 82

    (17) param -> ID COLON TYPE SEMICOLON . param
    (18) param -> ID COLON TYPE SEMICOLON .
    (17) param -> . ID COLON TYPE SEMICOLON param
    (18) param -> . ID COLON TYPE SEMICOLON

    RPAREN          reduce using rule 18 (param -> ID COLON TYPE SEMICOLON .)
    ID              shift and go to state 13

    param                          shift and go to state 116

state 83

    (9) var -> ID COMMA TYPE ASSIGN . ID

    ID              shift and go to state 117


state 84

    (6) body -> BEGIN cmd_loop END ID . SEMICOLON

    SEMICOLON       shift and go to state 118


state 85

    (21) function_call_exp -> ID param_pass .

    POWER           reduce using rule 21 (function_call_exp -> ID param_pass .)
    TIMES           reduce using rule 21 (function_call_exp -> ID param_pass .)
    DIVIDE          reduce using rule 21 (function_call_exp -> ID param_pass .)
    PLUS            reduce using rule 21 (function_call_exp -> ID param_pass .)
    MINUS           reduce using rule 21 (function_call_exp -> ID param_pass .)
    GREATERTHAN     reduce using rule 21 (function_call_exp -> ID param_pass .)
    GREATERTHANEQUAL reduce using rule 21 (function_call_exp -> ID param_pass .)
    LESSTHAN        reduce using rule 21 (function_call_exp -> ID param_pass .)
    LESSTHANEQUAL   reduce using rule 21 (function_call_exp -> ID param_pass .)
    NOTEQUAL        reduce using rule 21 (function_call_exp -> ID param_pass .)
    EQUAL           reduce using rule 21 (function_call_exp -> ID param_pass .)
    OR              reduce using rule 21 (function_call_exp -> ID param_pass .)
    COMMA           reduce using rule 21 (function_call_exp -> ID param_pass .)
    AND             reduce using rule 21 (function_call_exp -> ID param_pass .)
    SEMICOLON       reduce using rule 21 (function_call_exp -> ID param_pass .)
    THEN            reduce using rule 21 (function_call_exp -> ID param_pass .)
    LOOP            reduce using rule 21 (function_call_exp -> ID param_pass .)
    RPAREN          reduce using rule 21 (function_call_exp -> ID param_pass .)
    IF              reduce using rule 21 (function_call_exp -> ID param_pass .)
    PUTS            reduce using rule 21 (function_call_exp -> ID param_pass .)
    RETURN          reduce using rule 21 (function_call_exp -> ID param_pass .)
    ID              reduce using rule 21 (function_call_exp -> ID param_pass .)
    FOR             reduce using rule 21 (function_call_exp -> ID param_pass .)
    WHILE           reduce using rule 21 (function_call_exp -> ID param_pass .)


state 86

    (22) function_call_exp -> ID LPAREN . RPAREN
    (71) term -> LPAREN . expression RPAREN
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    RPAREN          shift and go to state 119
    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 92
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 87

    (45) assign -> ID ASSIGN op_arithmetic . SEMICOLON
    (58) op_arithmetic -> op_arithmetic . PLUS factor
    (59) op_arithmetic -> op_arithmetic . MINUS factor

    SEMICOLON       shift and go to state 120
    PLUS            shift and go to state 88
    MINUS           shift and go to state 89


state 88

    (58) op_arithmetic -> op_arithmetic PLUS . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    factor                         shift and go to state 121
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 89

    (59) op_arithmetic -> op_arithmetic MINUS . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    factor                         shift and go to state 122
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 90

    (19) function_call -> ID param_pass SEMICOLON .

    END             reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    IF              reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    PUTS            reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    RETURN          reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    ID              reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    LOOP            reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    FOR             reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    WHILE           reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    ELSIF           reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)
    ELSE            reduce using rule 19 (function_call -> ID param_pass SEMICOLON .)


state 91

    (20) function_call -> ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 123


state 92

    (71) term -> LPAREN expression . RPAREN
    (46) expression -> expression . AND or_exp

    RPAREN          shift and go to state 124
    AND             shift and go to state 94


state 93

    (23) param_pass -> expression COMMA . param_pass
    (23) param_pass -> . expression COMMA param_pass
    (24) param_pass -> . expression
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 61
    param_pass                     shift and go to state 125
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 94

    (46) expression -> expression AND . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    or_exp                         shift and go to state 126
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 95

    (48) or_exp -> or_exp OR . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    comp_exp                       shift and go to state 127
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 96

    (50) comp_exp -> comp_exp comp_op . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    op_arithmetic                  shift and go to state 128
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 97

    (52) comp_op -> GREATERTHAN .

    PLUS            reduce using rule 52 (comp_op -> GREATERTHAN .)
    MINUS           reduce using rule 52 (comp_op -> GREATERTHAN .)
    ID              reduce using rule 52 (comp_op -> GREATERTHAN .)
    LPAREN          reduce using rule 52 (comp_op -> GREATERTHAN .)


state 98

    (53) comp_op -> GREATERTHANEQUAL .

    PLUS            reduce using rule 53 (comp_op -> GREATERTHANEQUAL .)
    MINUS           reduce using rule 53 (comp_op -> GREATERTHANEQUAL .)
    ID              reduce using rule 53 (comp_op -> GREATERTHANEQUAL .)
    LPAREN          reduce using rule 53 (comp_op -> GREATERTHANEQUAL .)


state 99

    (54) comp_op -> LESSTHAN .

    PLUS            reduce using rule 54 (comp_op -> LESSTHAN .)
    MINUS           reduce using rule 54 (comp_op -> LESSTHAN .)
    ID              reduce using rule 54 (comp_op -> LESSTHAN .)
    LPAREN          reduce using rule 54 (comp_op -> LESSTHAN .)


state 100

    (55) comp_op -> LESSTHANEQUAL .

    PLUS            reduce using rule 55 (comp_op -> LESSTHANEQUAL .)
    MINUS           reduce using rule 55 (comp_op -> LESSTHANEQUAL .)
    ID              reduce using rule 55 (comp_op -> LESSTHANEQUAL .)
    LPAREN          reduce using rule 55 (comp_op -> LESSTHANEQUAL .)


state 101

    (56) comp_op -> NOTEQUAL .

    PLUS            reduce using rule 56 (comp_op -> NOTEQUAL .)
    MINUS           reduce using rule 56 (comp_op -> NOTEQUAL .)
    ID              reduce using rule 56 (comp_op -> NOTEQUAL .)
    LPAREN          reduce using rule 56 (comp_op -> NOTEQUAL .)


state 102

    (57) comp_op -> EQUAL .

    PLUS            reduce using rule 57 (comp_op -> EQUAL .)
    MINUS           reduce using rule 57 (comp_op -> EQUAL .)
    ID              reduce using rule 57 (comp_op -> EQUAL .)
    LPAREN          reduce using rule 57 (comp_op -> EQUAL .)


state 103

    (66) unary -> PLUS term .

    POWER           reduce using rule 66 (unary -> PLUS term .)
    TIMES           reduce using rule 66 (unary -> PLUS term .)
    DIVIDE          reduce using rule 66 (unary -> PLUS term .)
    PLUS            reduce using rule 66 (unary -> PLUS term .)
    MINUS           reduce using rule 66 (unary -> PLUS term .)
    GREATERTHAN     reduce using rule 66 (unary -> PLUS term .)
    GREATERTHANEQUAL reduce using rule 66 (unary -> PLUS term .)
    LESSTHAN        reduce using rule 66 (unary -> PLUS term .)
    LESSTHANEQUAL   reduce using rule 66 (unary -> PLUS term .)
    NOTEQUAL        reduce using rule 66 (unary -> PLUS term .)
    EQUAL           reduce using rule 66 (unary -> PLUS term .)
    OR              reduce using rule 66 (unary -> PLUS term .)
    COMMA           reduce using rule 66 (unary -> PLUS term .)
    AND             reduce using rule 66 (unary -> PLUS term .)
    SEMICOLON       reduce using rule 66 (unary -> PLUS term .)
    THEN            reduce using rule 66 (unary -> PLUS term .)
    LOOP            reduce using rule 66 (unary -> PLUS term .)
    RPAREN          reduce using rule 66 (unary -> PLUS term .)
    IF              reduce using rule 66 (unary -> PLUS term .)
    PUTS            reduce using rule 66 (unary -> PLUS term .)
    RETURN          reduce using rule 66 (unary -> PLUS term .)
    ID              reduce using rule 66 (unary -> PLUS term .)
    FOR             reduce using rule 66 (unary -> PLUS term .)
    WHILE           reduce using rule 66 (unary -> PLUS term .)


state 104

    (61) factor -> factor TIMES . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    power                          shift and go to state 129
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 105

    (62) factor -> factor DIVIDE . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    power                          shift and go to state 130
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 106

    (67) unary -> MINUS term .

    POWER           reduce using rule 67 (unary -> MINUS term .)
    TIMES           reduce using rule 67 (unary -> MINUS term .)
    DIVIDE          reduce using rule 67 (unary -> MINUS term .)
    PLUS            reduce using rule 67 (unary -> MINUS term .)
    MINUS           reduce using rule 67 (unary -> MINUS term .)
    GREATERTHAN     reduce using rule 67 (unary -> MINUS term .)
    GREATERTHANEQUAL reduce using rule 67 (unary -> MINUS term .)
    LESSTHAN        reduce using rule 67 (unary -> MINUS term .)
    LESSTHANEQUAL   reduce using rule 67 (unary -> MINUS term .)
    NOTEQUAL        reduce using rule 67 (unary -> MINUS term .)
    EQUAL           reduce using rule 67 (unary -> MINUS term .)
    OR              reduce using rule 67 (unary -> MINUS term .)
    COMMA           reduce using rule 67 (unary -> MINUS term .)
    AND             reduce using rule 67 (unary -> MINUS term .)
    SEMICOLON       reduce using rule 67 (unary -> MINUS term .)
    THEN            reduce using rule 67 (unary -> MINUS term .)
    LOOP            reduce using rule 67 (unary -> MINUS term .)
    RPAREN          reduce using rule 67 (unary -> MINUS term .)
    IF              reduce using rule 67 (unary -> MINUS term .)
    PUTS            reduce using rule 67 (unary -> MINUS term .)
    RETURN          reduce using rule 67 (unary -> MINUS term .)
    ID              reduce using rule 67 (unary -> MINUS term .)
    FOR             reduce using rule 67 (unary -> MINUS term .)
    WHILE           reduce using rule 67 (unary -> MINUS term .)


state 107

    (64) power -> power POWER . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    unary                          shift and go to state 131
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 108

    (34) if_statement -> IF expression THEN . cmd_loop if_statement_loop
    (31) cmd_loop -> . cmd_loop cmd
    (32) cmd_loop -> . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 132
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 109

    (33) puts -> PUTS LPAREN STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 133


state 110

    (73) return -> RETURN expression SEMICOLON .

    END             reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    IF              reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    PUTS            reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    ID              reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    LOOP            reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    ELSIF           reduce using rule 73 (return -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 73 (return -> RETURN expression SEMICOLON .)


state 111

    (41) loop_statement -> LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 134


state 112

    (43) for_statement -> FOR ID IN . range LOOP cmd_loop END LOOP SEMICOLON
    (44) range -> . ID DOTDOT ID

    ID              shift and go to state 135

    range                          shift and go to state 136

state 113

    (42) while_statement -> WHILE expression LOOP . cmd_loop END LOOP SEMICOLON
    (31) cmd_loop -> . cmd_loop cmd
    (32) cmd_loop -> . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 137
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 114

    (72) array -> TYPE ID IS ARRAY . LPAREN range RPAREN OF TYPE SEMICOLON

    LPAREN          shift and go to state 138


state 115

    (11) var -> var_loop ID COLON TYPE .

    SEMICOLON       reduce using rule 11 (var -> var_loop ID COLON TYPE .)


state 116

    (17) param -> ID COLON TYPE SEMICOLON param .

    RPAREN          reduce using rule 17 (param -> ID COLON TYPE SEMICOLON param .)


state 117

    (9) var -> ID COMMA TYPE ASSIGN ID .

    SEMICOLON       reduce using rule 9 (var -> ID COMMA TYPE ASSIGN ID .)


state 118

    (6) body -> BEGIN cmd_loop END ID SEMICOLON .

    FUNCTION        reduce using rule 6 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    PROCEDURE       reduce using rule 6 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    $end            reduce using rule 6 (body -> BEGIN cmd_loop END ID SEMICOLON .)


state 119

    (22) function_call_exp -> ID LPAREN RPAREN .

    POWER           reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    GREATERTHANEQUAL reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    LESSTHAN        reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    LESSTHANEQUAL   reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    EQUAL           reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    OR              reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    AND             reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    THEN            reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    LOOP            reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    IF              reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    PUTS            reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    ID              reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    FOR             reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 22 (function_call_exp -> ID LPAREN RPAREN .)


state 120

    (45) assign -> ID ASSIGN op_arithmetic SEMICOLON .

    END             reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    IF              reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    PUTS            reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    RETURN          reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ID              reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    LOOP            reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    FOR             reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    WHILE           reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSIF           reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSE            reduce using rule 45 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)


state 121

    (58) op_arithmetic -> op_arithmetic PLUS factor .
    (61) factor -> factor . TIMES power
    (62) factor -> factor . DIVIDE power

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    MINUS           reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    GREATERTHAN     reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    GREATERTHANEQUAL reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    LESSTHAN        reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    LESSTHANEQUAL   reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    NOTEQUAL        reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    EQUAL           reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    OR              reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    COMMA           reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    AND             reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    SEMICOLON       reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    THEN            reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    LOOP            reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    POWER           reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    RPAREN          reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    IF              reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    PUTS            reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    RETURN          reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    ID              reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    FOR             reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    WHILE           reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .)
    TIMES           shift and go to state 104
    DIVIDE          shift and go to state 105

  ! TIMES           [ reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .) ]
  ! DIVIDE          [ reduce using rule 58 (op_arithmetic -> op_arithmetic PLUS factor .) ]


state 122

    (59) op_arithmetic -> op_arithmetic MINUS factor .
    (61) factor -> factor . TIMES power
    (62) factor -> factor . DIVIDE power

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
    PLUS            reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    MINUS           reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    GREATERTHAN     reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    GREATERTHANEQUAL reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    LESSTHAN        reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    LESSTHANEQUAL   reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    NOTEQUAL        reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    EQUAL           reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    OR              reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    COMMA           reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    AND             reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    SEMICOLON       reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    THEN            reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    LOOP            reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    POWER           reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    RPAREN          reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    IF              reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    PUTS            reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    RETURN          reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    ID              reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    FOR             reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    WHILE           reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .)
    TIMES           shift and go to state 104
    DIVIDE          shift and go to state 105

  ! TIMES           [ reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .) ]
  ! DIVIDE          [ reduce using rule 59 (op_arithmetic -> op_arithmetic MINUS factor .) ]


state 123

    (20) function_call -> ID LPAREN RPAREN SEMICOLON .

    END             reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    PUTS            reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    LOOP            reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    ELSIF           reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 20 (function_call -> ID LPAREN RPAREN SEMICOLON .)


state 124

    (71) term -> LPAREN expression RPAREN .

    POWER           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 71 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 71 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    GREATERTHAN     reduce using rule 71 (term -> LPAREN expression RPAREN .)
    GREATERTHANEQUAL reduce using rule 71 (term -> LPAREN expression RPAREN .)
    LESSTHAN        reduce using rule 71 (term -> LPAREN expression RPAREN .)
    LESSTHANEQUAL   reduce using rule 71 (term -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 71 (term -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 71 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 71 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 71 (term -> LPAREN expression RPAREN .)
    THEN            reduce using rule 71 (term -> LPAREN expression RPAREN .)
    LOOP            reduce using rule 71 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 71 (term -> LPAREN expression RPAREN .)
    IF              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 71 (term -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 71 (term -> LPAREN expression RPAREN .)
    ID              reduce using rule 71 (term -> LPAREN expression RPAREN .)
    FOR             reduce using rule 71 (term -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 71 (term -> LPAREN expression RPAREN .)


state 125

    (23) param_pass -> expression COMMA param_pass .

    SEMICOLON       reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    POWER           reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    TIMES           reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    DIVIDE          reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    PLUS            reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    MINUS           reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    GREATERTHAN     reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    GREATERTHANEQUAL reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    LESSTHAN        reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    LESSTHANEQUAL   reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    NOTEQUAL        reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    EQUAL           reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    OR              reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    COMMA           reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    AND             reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    THEN            reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    LOOP            reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    RPAREN          reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    IF              reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    PUTS            reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    RETURN          reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    ID              reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    FOR             reduce using rule 23 (param_pass -> expression COMMA param_pass .)
    WHILE           reduce using rule 23 (param_pass -> expression COMMA param_pass .)


state 126

    (46) expression -> expression AND or_exp .
    (48) or_exp -> or_exp . OR comp_exp

  ! shift/reduce conflict for OR resolved as shift
    COMMA           reduce using rule 46 (expression -> expression AND or_exp .)
    AND             reduce using rule 46 (expression -> expression AND or_exp .)
    SEMICOLON       reduce using rule 46 (expression -> expression AND or_exp .)
    THEN            reduce using rule 46 (expression -> expression AND or_exp .)
    LOOP            reduce using rule 46 (expression -> expression AND or_exp .)
    POWER           reduce using rule 46 (expression -> expression AND or_exp .)
    TIMES           reduce using rule 46 (expression -> expression AND or_exp .)
    DIVIDE          reduce using rule 46 (expression -> expression AND or_exp .)
    PLUS            reduce using rule 46 (expression -> expression AND or_exp .)
    MINUS           reduce using rule 46 (expression -> expression AND or_exp .)
    GREATERTHAN     reduce using rule 46 (expression -> expression AND or_exp .)
    GREATERTHANEQUAL reduce using rule 46 (expression -> expression AND or_exp .)
    LESSTHAN        reduce using rule 46 (expression -> expression AND or_exp .)
    LESSTHANEQUAL   reduce using rule 46 (expression -> expression AND or_exp .)
    NOTEQUAL        reduce using rule 46 (expression -> expression AND or_exp .)
    EQUAL           reduce using rule 46 (expression -> expression AND or_exp .)
    RPAREN          reduce using rule 46 (expression -> expression AND or_exp .)
    IF              reduce using rule 46 (expression -> expression AND or_exp .)
    PUTS            reduce using rule 46 (expression -> expression AND or_exp .)
    RETURN          reduce using rule 46 (expression -> expression AND or_exp .)
    ID              reduce using rule 46 (expression -> expression AND or_exp .)
    FOR             reduce using rule 46 (expression -> expression AND or_exp .)
    WHILE           reduce using rule 46 (expression -> expression AND or_exp .)
    OR              shift and go to state 95

  ! OR              [ reduce using rule 46 (expression -> expression AND or_exp .) ]


state 127

    (48) or_exp -> or_exp OR comp_exp .
    (50) comp_exp -> comp_exp . comp_op op_arithmetic
    (52) comp_op -> . GREATERTHAN
    (53) comp_op -> . GREATERTHANEQUAL
    (54) comp_op -> . LESSTHAN
    (55) comp_op -> . LESSTHANEQUAL
    (56) comp_op -> . NOTEQUAL
    (57) comp_op -> . EQUAL

  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSTHAN resolved as shift
  ! shift/reduce conflict for LESSTHANEQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
    OR              reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    COMMA           reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    AND             reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    SEMICOLON       reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    THEN            reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    LOOP            reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    POWER           reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    TIMES           reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    DIVIDE          reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    PLUS            reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    MINUS           reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    RPAREN          reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    IF              reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    PUTS            reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    RETURN          reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    ID              reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    FOR             reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    WHILE           reduce using rule 48 (or_exp -> or_exp OR comp_exp .)
    GREATERTHAN     shift and go to state 97
    GREATERTHANEQUAL shift and go to state 98
    LESSTHAN        shift and go to state 99
    LESSTHANEQUAL   shift and go to state 100
    NOTEQUAL        shift and go to state 101
    EQUAL           shift and go to state 102

  ! GREATERTHAN     [ reduce using rule 48 (or_exp -> or_exp OR comp_exp .) ]
  ! GREATERTHANEQUAL [ reduce using rule 48 (or_exp -> or_exp OR comp_exp .) ]
  ! LESSTHAN        [ reduce using rule 48 (or_exp -> or_exp OR comp_exp .) ]
  ! LESSTHANEQUAL   [ reduce using rule 48 (or_exp -> or_exp OR comp_exp .) ]
  ! NOTEQUAL        [ reduce using rule 48 (or_exp -> or_exp OR comp_exp .) ]
  ! EQUAL           [ reduce using rule 48 (or_exp -> or_exp OR comp_exp .) ]

    comp_op                        shift and go to state 96

state 128

    (50) comp_exp -> comp_exp comp_op op_arithmetic .
    (58) op_arithmetic -> op_arithmetic . PLUS factor
    (59) op_arithmetic -> op_arithmetic . MINUS factor

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    GREATERTHAN     reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    GREATERTHANEQUAL reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LESSTHAN        reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LESSTHANEQUAL   reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    NOTEQUAL        reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    EQUAL           reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    OR              reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    COMMA           reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    AND             reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    SEMICOLON       reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    THEN            reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LOOP            reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    POWER           reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    TIMES           reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    DIVIDE          reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    RPAREN          reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    IF              reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    PUTS            reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    RETURN          reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    ID              reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    FOR             reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    WHILE           reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .)
    PLUS            shift and go to state 88
    MINUS           shift and go to state 89

  ! PLUS            [ reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .) ]
  ! MINUS           [ reduce using rule 50 (comp_exp -> comp_exp comp_op op_arithmetic .) ]


state 129

    (61) factor -> factor TIMES power .
    (64) power -> power . POWER unary

  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 61 (factor -> factor TIMES power .)
    DIVIDE          reduce using rule 61 (factor -> factor TIMES power .)
    PLUS            reduce using rule 61 (factor -> factor TIMES power .)
    MINUS           reduce using rule 61 (factor -> factor TIMES power .)
    GREATERTHAN     reduce using rule 61 (factor -> factor TIMES power .)
    GREATERTHANEQUAL reduce using rule 61 (factor -> factor TIMES power .)
    LESSTHAN        reduce using rule 61 (factor -> factor TIMES power .)
    LESSTHANEQUAL   reduce using rule 61 (factor -> factor TIMES power .)
    NOTEQUAL        reduce using rule 61 (factor -> factor TIMES power .)
    EQUAL           reduce using rule 61 (factor -> factor TIMES power .)
    OR              reduce using rule 61 (factor -> factor TIMES power .)
    COMMA           reduce using rule 61 (factor -> factor TIMES power .)
    AND             reduce using rule 61 (factor -> factor TIMES power .)
    SEMICOLON       reduce using rule 61 (factor -> factor TIMES power .)
    THEN            reduce using rule 61 (factor -> factor TIMES power .)
    LOOP            reduce using rule 61 (factor -> factor TIMES power .)
    RPAREN          reduce using rule 61 (factor -> factor TIMES power .)
    IF              reduce using rule 61 (factor -> factor TIMES power .)
    PUTS            reduce using rule 61 (factor -> factor TIMES power .)
    RETURN          reduce using rule 61 (factor -> factor TIMES power .)
    ID              reduce using rule 61 (factor -> factor TIMES power .)
    FOR             reduce using rule 61 (factor -> factor TIMES power .)
    WHILE           reduce using rule 61 (factor -> factor TIMES power .)
    POWER           shift and go to state 107

  ! POWER           [ reduce using rule 61 (factor -> factor TIMES power .) ]


state 130

    (62) factor -> factor DIVIDE power .
    (64) power -> power . POWER unary

  ! shift/reduce conflict for POWER resolved as shift
    TIMES           reduce using rule 62 (factor -> factor DIVIDE power .)
    DIVIDE          reduce using rule 62 (factor -> factor DIVIDE power .)
    PLUS            reduce using rule 62 (factor -> factor DIVIDE power .)
    MINUS           reduce using rule 62 (factor -> factor DIVIDE power .)
    GREATERTHAN     reduce using rule 62 (factor -> factor DIVIDE power .)
    GREATERTHANEQUAL reduce using rule 62 (factor -> factor DIVIDE power .)
    LESSTHAN        reduce using rule 62 (factor -> factor DIVIDE power .)
    LESSTHANEQUAL   reduce using rule 62 (factor -> factor DIVIDE power .)
    NOTEQUAL        reduce using rule 62 (factor -> factor DIVIDE power .)
    EQUAL           reduce using rule 62 (factor -> factor DIVIDE power .)
    OR              reduce using rule 62 (factor -> factor DIVIDE power .)
    COMMA           reduce using rule 62 (factor -> factor DIVIDE power .)
    AND             reduce using rule 62 (factor -> factor DIVIDE power .)
    SEMICOLON       reduce using rule 62 (factor -> factor DIVIDE power .)
    THEN            reduce using rule 62 (factor -> factor DIVIDE power .)
    LOOP            reduce using rule 62 (factor -> factor DIVIDE power .)
    RPAREN          reduce using rule 62 (factor -> factor DIVIDE power .)
    IF              reduce using rule 62 (factor -> factor DIVIDE power .)
    PUTS            reduce using rule 62 (factor -> factor DIVIDE power .)
    RETURN          reduce using rule 62 (factor -> factor DIVIDE power .)
    ID              reduce using rule 62 (factor -> factor DIVIDE power .)
    FOR             reduce using rule 62 (factor -> factor DIVIDE power .)
    WHILE           reduce using rule 62 (factor -> factor DIVIDE power .)
    POWER           shift and go to state 107

  ! POWER           [ reduce using rule 62 (factor -> factor DIVIDE power .) ]


state 131

    (64) power -> power POWER unary .

    POWER           reduce using rule 64 (power -> power POWER unary .)
    TIMES           reduce using rule 64 (power -> power POWER unary .)
    DIVIDE          reduce using rule 64 (power -> power POWER unary .)
    PLUS            reduce using rule 64 (power -> power POWER unary .)
    MINUS           reduce using rule 64 (power -> power POWER unary .)
    GREATERTHAN     reduce using rule 64 (power -> power POWER unary .)
    GREATERTHANEQUAL reduce using rule 64 (power -> power POWER unary .)
    LESSTHAN        reduce using rule 64 (power -> power POWER unary .)
    LESSTHANEQUAL   reduce using rule 64 (power -> power POWER unary .)
    NOTEQUAL        reduce using rule 64 (power -> power POWER unary .)
    EQUAL           reduce using rule 64 (power -> power POWER unary .)
    OR              reduce using rule 64 (power -> power POWER unary .)
    COMMA           reduce using rule 64 (power -> power POWER unary .)
    AND             reduce using rule 64 (power -> power POWER unary .)
    SEMICOLON       reduce using rule 64 (power -> power POWER unary .)
    THEN            reduce using rule 64 (power -> power POWER unary .)
    LOOP            reduce using rule 64 (power -> power POWER unary .)
    RPAREN          reduce using rule 64 (power -> power POWER unary .)
    IF              reduce using rule 64 (power -> power POWER unary .)
    PUTS            reduce using rule 64 (power -> power POWER unary .)
    RETURN          reduce using rule 64 (power -> power POWER unary .)
    ID              reduce using rule 64 (power -> power POWER unary .)
    FOR             reduce using rule 64 (power -> power POWER unary .)
    WHILE           reduce using rule 64 (power -> power POWER unary .)


state 132

    (34) if_statement -> IF expression THEN cmd_loop . if_statement_loop
    (31) cmd_loop -> cmd_loop . cmd
    (35) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (36) if_statement_loop -> . ELSE cmd_loop END IF SEMICOLON
    (37) if_statement_loop -> . END IF SEMICOLON
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 140
    ELSE            shift and go to state 141
    END             shift and go to state 142
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    if_statement_loop              shift and go to state 139
    cmd                            shift and go to state 55
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 133

    (33) puts -> PUTS LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 143


state 134

    (41) loop_statement -> LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 144


state 135

    (44) range -> ID . DOTDOT ID

    DOTDOT          shift and go to state 145


state 136

    (43) for_statement -> FOR ID IN range . LOOP cmd_loop END LOOP SEMICOLON

    LOOP            shift and go to state 146


state 137

    (42) while_statement -> WHILE expression LOOP cmd_loop . END LOOP SEMICOLON
    (31) cmd_loop -> cmd_loop . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 147
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 55
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 138

    (72) array -> TYPE ID IS ARRAY LPAREN . range RPAREN OF TYPE SEMICOLON
    (44) range -> . ID DOTDOT ID

    ID              shift and go to state 135

    range                          shift and go to state 148

state 139

    (34) if_statement -> IF expression THEN cmd_loop if_statement_loop .

    END             reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    IF              reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    PUTS            reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    RETURN          reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ID              reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    LOOP            reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    FOR             reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    WHILE           reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSE            reduce using rule 34 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)


state 140

    (35) if_statement_loop -> ELSIF . expression cmd_loop if_statement_loop
    (46) expression -> . expression AND or_exp
    (47) expression -> . or_exp
    (48) or_exp -> . or_exp OR comp_exp
    (49) or_exp -> . comp_exp
    (50) comp_exp -> . comp_exp comp_op op_arithmetic
    (51) comp_exp -> . op_arithmetic
    (58) op_arithmetic -> . op_arithmetic PLUS factor
    (59) op_arithmetic -> . op_arithmetic MINUS factor
    (60) op_arithmetic -> . factor
    (61) factor -> . factor TIMES power
    (62) factor -> . factor DIVIDE power
    (63) factor -> . power
    (64) power -> . power POWER unary
    (65) power -> . unary
    (66) unary -> . PLUS term
    (67) unary -> . MINUS term
    (68) unary -> . term
    (69) term -> . ID
    (70) term -> . function_call_exp
    (71) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID param_pass
    (22) function_call_exp -> . ID LPAREN RPAREN

    PLUS            shift and go to state 64
    MINUS           shift and go to state 66
    ID              shift and go to state 56
    LPAREN          shift and go to state 72

    expression                     shift and go to state 149
    or_exp                         shift and go to state 62
    comp_exp                       shift and go to state 63
    op_arithmetic                  shift and go to state 58
    factor                         shift and go to state 65
    power                          shift and go to state 67
    unary                          shift and go to state 68
    term                           shift and go to state 69
    function_call_exp              shift and go to state 70

state 141

    (36) if_statement_loop -> ELSE . cmd_loop END IF SEMICOLON
    (31) cmd_loop -> . cmd_loop cmd
    (32) cmd_loop -> . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 150
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 142

    (37) if_statement_loop -> END . IF SEMICOLON

    IF              shift and go to state 151


state 143

    (33) puts -> PUTS LPAREN STRING RPAREN SEMICOLON .

    END             reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    PUTS            reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ID              reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    LOOP            reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ELSIF           reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ELSE            reduce using rule 33 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)


state 144

    (41) loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 41 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)


state 145

    (44) range -> ID DOTDOT . ID

    ID              shift and go to state 152


state 146

    (43) for_statement -> FOR ID IN range LOOP . cmd_loop END LOOP SEMICOLON
    (31) cmd_loop -> . cmd_loop cmd
    (32) cmd_loop -> . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 153
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 147

    (42) while_statement -> WHILE expression LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 154


state 148

    (72) array -> TYPE ID IS ARRAY LPAREN range . RPAREN OF TYPE SEMICOLON

    RPAREN          shift and go to state 155


state 149

    (35) if_statement_loop -> ELSIF expression . cmd_loop if_statement_loop
    (46) expression -> expression . AND or_exp
    (31) cmd_loop -> . cmd_loop cmd
    (32) cmd_loop -> . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    AND             shift and go to state 94
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 156
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 150

    (36) if_statement_loop -> ELSE cmd_loop . END IF SEMICOLON
    (31) cmd_loop -> cmd_loop . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 157
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 55
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 151

    (37) if_statement_loop -> END IF . SEMICOLON

    SEMICOLON       shift and go to state 158


state 152

    (44) range -> ID DOTDOT ID .

    LOOP            reduce using rule 44 (range -> ID DOTDOT ID .)
    RPAREN          reduce using rule 44 (range -> ID DOTDOT ID .)


state 153

    (43) for_statement -> FOR ID IN range LOOP cmd_loop . END LOOP SEMICOLON
    (31) cmd_loop -> cmd_loop . cmd
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 159
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 55
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 154

    (42) while_statement -> WHILE expression LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 160


state 155

    (72) array -> TYPE ID IS ARRAY LPAREN range RPAREN . OF TYPE SEMICOLON

    OF              shift and go to state 161


state 156

    (35) if_statement_loop -> ELSIF expression cmd_loop . if_statement_loop
    (31) cmd_loop -> cmd_loop . cmd
    (35) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (36) if_statement_loop -> . ELSE cmd_loop END IF SEMICOLON
    (37) if_statement_loop -> . END IF SEMICOLON
    (25) cmd -> . if_statement
    (26) cmd -> . repeat_statement
    (27) cmd -> . puts
    (28) cmd -> . return
    (29) cmd -> . assign
    (30) cmd -> . function_call
    (34) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (38) repeat_statement -> . loop_statement
    (39) repeat_statement -> . for_statement
    (40) repeat_statement -> . while_statement
    (33) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (73) return -> . RETURN expression SEMICOLON
    (45) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (19) function_call -> . ID param_pass SEMICOLON
    (20) function_call -> . ID LPAREN RPAREN SEMICOLON
    (41) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (43) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (42) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 140
    ELSE            shift and go to state 141
    END             shift and go to state 142
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    if_statement_loop              shift and go to state 162
    cmd                            shift and go to state 55
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 157

    (36) if_statement_loop -> ELSE cmd_loop END . IF SEMICOLON

    IF              shift and go to state 163


state 158

    (37) if_statement_loop -> END IF SEMICOLON .

    END             reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    IF              reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    PUTS            reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    RETURN          reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    ID              reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    LOOP            reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    FOR             reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    WHILE           reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    ELSIF           reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)
    ELSE            reduce using rule 37 (if_statement_loop -> END IF SEMICOLON .)


state 159

    (43) for_statement -> FOR ID IN range LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 164


state 160

    (42) while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 42 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)


state 161

    (72) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF . TYPE SEMICOLON

    TYPE            shift and go to state 165


state 162

    (35) if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .

    END             reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    IF              reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    PUTS            reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    RETURN          reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ID              reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    LOOP            reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    FOR             reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    WHILE           reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSE            reduce using rule 35 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)


state 163

    (36) if_statement_loop -> ELSE cmd_loop END IF . SEMICOLON

    SEMICOLON       shift and go to state 166


state 164

    (43) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 167


state 165

    (72) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE . SEMICOLON

    SEMICOLON       shift and go to state 168


state 166

    (36) if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .

    END             reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    IF              reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    PUTS            reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    RETURN          reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    ID              reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    LOOP            reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    FOR             reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    WHILE           reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    ELSIF           reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    ELSE            reduce using rule 36 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)


state 167

    (43) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 43 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)


state 168

    (72) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON .

    SEMICOLON       reduce using rule 72 (array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 56 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 56 resolved as shift
WARNING: shift/reduce conflict for ID in state 56 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 58 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 58 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 61 resolved as shift
WARNING: shift/reduce conflict for AND in state 61 resolved as shift
WARNING: shift/reduce conflict for OR in state 62 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 63 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 63 resolved as shift
WARNING: shift/reduce conflict for LESSTHANEQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 63 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 65 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 65 resolved as shift
WARNING: shift/reduce conflict for POWER in state 67 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 127 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for LESSTHAN in state 127 resolved as shift
WARNING: shift/reduce conflict for LESSTHANEQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for POWER in state 129 resolved as shift
WARNING: shift/reduce conflict for POWER in state 130 resolved as shift
