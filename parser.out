Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOLEAN
    CHAR
    NUMBER_EXPONENT
    NUMBER_FLOAT

Grammar

Rule 0     S' -> program
Rule 1     program -> PROCEDURE ID IS decl body
Rule 2     program -> PROCEDURE ID IS body
Rule 3     subprogram -> FUNCTION ID decl_param IS decl body
Rule 4     subprogram -> FUNCTION ID decl_param IS body
Rule 5     body -> BEGIN cmd_loop END ID SEMICOLON
Rule 6     decl -> var SEMICOLON decl
Rule 7     decl -> var SEMICOLON
Rule 8     decl -> subprogram decl
Rule 9     decl -> subprogram
Rule 10    var -> ID COMMA TYPE ASSIGN ID
Rule 11    var -> ID COLON TYPE
Rule 12    var -> var_loop ID COLON TYPE
Rule 13    var -> array
Rule 14    var_loop -> var_loop ID COMMA
Rule 15    var_loop -> ID COMMA
Rule 16    decl_param -> LPAREN param RPAREN
Rule 17    decl_param -> LPAREN param RPAREN RETURN TYPE
Rule 18    param -> ID COLON TYPE SEMICOLON param
Rule 19    param -> ID COLON TYPE SEMICOLON
Rule 20    function_call -> ID LPAREN param_pass RPAREN SEMICOLON
Rule 21    function_call_exp -> ID LPAREN param_pass RPAREN
Rule 22    param_pass -> expression COMMA param_pass
Rule 23    param_pass -> expression
Rule 24    cmd -> if_statement
Rule 25    cmd -> repeat_statement
Rule 26    cmd -> puts
Rule 27    cmd -> return
Rule 28    cmd -> assign
Rule 29    cmd -> function_call
Rule 30    cmd_loop -> cmd_loop cmd
Rule 31    cmd_loop -> cmd
Rule 32    puts -> PUTS LPAREN STRING RPAREN SEMICOLON
Rule 33    if_statement -> IF expression THEN cmd_loop if_statement_loop
Rule 34    if_statement_loop -> ELSIF expression cmd_loop if_statement_loop
Rule 35    if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON
Rule 36    if_statement_loop -> END IF SEMICOLON
Rule 37    repeat_statement -> loop_statement
Rule 38    repeat_statement -> for_statement
Rule 39    repeat_statement -> while_statement
Rule 40    loop_statement -> LOOP cmd_loop END LOOP
Rule 41    while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON
Rule 42    for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
Rule 43    range -> ID DOTDOT ID
Rule 44    assign -> ID ASSIGN op_arithmetic SEMICOLON
Rule 45    expression -> expression AND or_exp
Rule 46    expression -> or_exp
Rule 47    or_exp -> or_exp OR comp_exp
Rule 48    or_exp -> comp_exp
Rule 49    comp_exp -> comp_exp comp_op op_arithmetic
Rule 50    comp_exp -> op_arithmetic
Rule 51    comp_op -> GREATERTHAN
Rule 52    comp_op -> GREATERTHANEQUAL
Rule 53    comp_op -> LESSTHAN
Rule 54    comp_op -> LESSTHANEQUAL
Rule 55    comp_op -> NOTEQUAL
Rule 56    comp_op -> EQUAL
Rule 57    op_arithmetic -> op_arithmetic PLUS factor
Rule 58    op_arithmetic -> op_arithmetic MINUS factor
Rule 59    op_arithmetic -> factor
Rule 60    factor -> factor TIMES power
Rule 61    factor -> factor DIVIDE power
Rule 62    factor -> power
Rule 63    power -> power POWER unary
Rule 64    power -> unary
Rule 65    unary -> PLUS term
Rule 66    unary -> MINUS term
Rule 67    unary -> term
Rule 68    term -> ID
Rule 69    term -> function_call_exp
Rule 70    term -> LPAREN expression RPAREN
Rule 71    array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON
Rule 72    return -> RETURN expression SEMICOLON

Terminals, with rules where they appear

AND                  : 45
ARRAY                : 71
ASSIGN               : 10 44
BEGIN                : 5
BOOLEAN              : 
CHAR                 : 
COLON                : 11 12 18 19
COMMA                : 10 14 15 22
DIVIDE               : 61
DOTDOT               : 43
ELSE                 : 35
ELSIF                : 34
END                  : 5 35 36 40 41 42
EQUAL                : 56
FOR                  : 42
FUNCTION             : 3 4
GREATERTHAN          : 51
GREATERTHANEQUAL     : 52
ID                   : 1 2 3 4 5 10 10 11 12 14 15 18 19 20 21 42 43 43 44 68 71
IF                   : 33 35 36
IN                   : 42
IS                   : 1 2 3 4 71
LESSTHAN             : 53
LESSTHANEQUAL        : 54
LOOP                 : 40 40 41 41 42 42
LPAREN               : 16 17 20 21 32 70 71
MINUS                : 58 66
NOTEQUAL             : 55
NUMBER_EXPONENT      : 
NUMBER_FLOAT         : 
NUMBER_INT           : 41
OF                   : 71
OR                   : 47
PLUS                 : 57 65
POWER                : 63
PROCEDURE            : 1 2
PUTS                 : 32
RETURN               : 17 72
RPAREN               : 16 17 20 21 32 70 71
SEMICOLON            : 5 6 7 18 19 20 32 35 36 41 42 44 71 72
STRING               : 32
THEN                 : 33
TIMES                : 60
TYPE                 : 10 11 12 17 18 19 71 71
WHILE                : 41
error                : 

Nonterminals, with rules where they appear

array                : 13
assign               : 28
body                 : 1 2 3 4
cmd                  : 30 31
cmd_loop             : 5 30 33 34 35 40 41 42
comp_exp             : 47 48 49
comp_op              : 49
decl                 : 1 3 6 8
decl_param           : 3 4
expression           : 22 23 33 34 35 41 45 70 72
factor               : 57 58 59 60 61
for_statement        : 38
function_call        : 29
function_call_exp    : 69
if_statement         : 24
if_statement_loop    : 33 34
loop_statement       : 37
op_arithmetic        : 44 49 50 57 58
or_exp               : 45 46 47
param                : 16 17 18
param_pass           : 20 21 22
power                : 60 61 62 63
program              : 0
puts                 : 26
range                : 42 71
repeat_statement     : 25
return               : 27
subprogram           : 8 9
term                 : 65 66 67
unary                : 63 64
var                  : 6 7
var_loop             : 12 14
while_statement      : 39

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROCEDURE ID IS decl body
    (2) program -> . PROCEDURE ID IS body

    PROCEDURE       shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROCEDURE . ID IS decl body
    (2) program -> PROCEDURE . ID IS body

    ID              shift and go to state 3


state 3

    (1) program -> PROCEDURE ID . IS decl body
    (2) program -> PROCEDURE ID . IS body

    IS              shift and go to state 4


state 4

    (1) program -> PROCEDURE ID IS . decl body
    (2) program -> PROCEDURE ID IS . body
    (6) decl -> . var SEMICOLON decl
    (7) decl -> . var SEMICOLON
    (8) decl -> . subprogram decl
    (9) decl -> . subprogram
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON
    (10) var -> . ID COMMA TYPE ASSIGN ID
    (11) var -> . ID COLON TYPE
    (12) var -> . var_loop ID COLON TYPE
    (13) var -> . array
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (14) var_loop -> . var_loop ID COMMA
    (15) var_loop -> . ID COMMA
    (71) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           shift and go to state 10
    ID              shift and go to state 5
    FUNCTION        shift and go to state 14
    TYPE            shift and go to state 11

    decl                           shift and go to state 6
    body                           shift and go to state 7
    var                            shift and go to state 8
    subprogram                     shift and go to state 9
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 5

    (10) var -> ID . COMMA TYPE ASSIGN ID
    (11) var -> ID . COLON TYPE
    (15) var_loop -> ID . COMMA

    COMMA           shift and go to state 15
    COLON           shift and go to state 16


state 6

    (1) program -> PROCEDURE ID IS decl . body
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 10

    body                           shift and go to state 17

state 7

    (2) program -> PROCEDURE ID IS body .

    $end            reduce using rule 2 (program -> PROCEDURE ID IS body .)


state 8

    (6) decl -> var . SEMICOLON decl
    (7) decl -> var . SEMICOLON

    SEMICOLON       shift and go to state 18


state 9

    (8) decl -> subprogram . decl
    (9) decl -> subprogram .
    (6) decl -> . var SEMICOLON decl
    (7) decl -> . var SEMICOLON
    (8) decl -> . subprogram decl
    (9) decl -> . subprogram
    (10) var -> . ID COMMA TYPE ASSIGN ID
    (11) var -> . ID COLON TYPE
    (12) var -> . var_loop ID COLON TYPE
    (13) var -> . array
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (14) var_loop -> . var_loop ID COMMA
    (15) var_loop -> . ID COMMA
    (71) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           reduce using rule 9 (decl -> subprogram .)
    ID              shift and go to state 5
    FUNCTION        shift and go to state 14
    TYPE            shift and go to state 11

    subprogram                     shift and go to state 9
    decl                           shift and go to state 19
    var                            shift and go to state 8
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 10

    (5) body -> BEGIN . cmd_loop END ID SEMICOLON
    (30) cmd_loop -> . cmd_loop cmd
    (31) cmd_loop -> . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd_loop                       shift and go to state 20
    cmd                            shift and go to state 22
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 11

    (71) array -> TYPE . ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    ID              shift and go to state 38


state 12

    (12) var -> var_loop . ID COLON TYPE
    (14) var_loop -> var_loop . ID COMMA

    ID              shift and go to state 39


state 13

    (13) var -> array .

    SEMICOLON       reduce using rule 13 (var -> array .)


state 14

    (3) subprogram -> FUNCTION . ID decl_param IS decl body
    (4) subprogram -> FUNCTION . ID decl_param IS body

    ID              shift and go to state 40


state 15

    (10) var -> ID COMMA . TYPE ASSIGN ID
    (15) var_loop -> ID COMMA .

    TYPE            shift and go to state 41
    ID              reduce using rule 15 (var_loop -> ID COMMA .)


state 16

    (11) var -> ID COLON . TYPE

    TYPE            shift and go to state 42


state 17

    (1) program -> PROCEDURE ID IS decl body .

    $end            reduce using rule 1 (program -> PROCEDURE ID IS decl body .)


state 18

    (6) decl -> var SEMICOLON . decl
    (7) decl -> var SEMICOLON .
    (6) decl -> . var SEMICOLON decl
    (7) decl -> . var SEMICOLON
    (8) decl -> . subprogram decl
    (9) decl -> . subprogram
    (10) var -> . ID COMMA TYPE ASSIGN ID
    (11) var -> . ID COLON TYPE
    (12) var -> . var_loop ID COLON TYPE
    (13) var -> . array
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (14) var_loop -> . var_loop ID COMMA
    (15) var_loop -> . ID COMMA
    (71) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           reduce using rule 7 (decl -> var SEMICOLON .)
    ID              shift and go to state 5
    FUNCTION        shift and go to state 14
    TYPE            shift and go to state 11

    var                            shift and go to state 8
    decl                           shift and go to state 43
    subprogram                     shift and go to state 9
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 19

    (8) decl -> subprogram decl .

    BEGIN           reduce using rule 8 (decl -> subprogram decl .)


state 20

    (5) body -> BEGIN cmd_loop . END ID SEMICOLON
    (30) cmd_loop -> cmd_loop . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 44
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd                            shift and go to state 45
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 21

    (44) assign -> ID . ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> ID . LPAREN param_pass RPAREN SEMICOLON

    ASSIGN          shift and go to state 46
    LPAREN          shift and go to state 47


state 22

    (31) cmd_loop -> cmd .

    END             reduce using rule 31 (cmd_loop -> cmd .)
    IF              reduce using rule 31 (cmd_loop -> cmd .)
    PUTS            reduce using rule 31 (cmd_loop -> cmd .)
    RETURN          reduce using rule 31 (cmd_loop -> cmd .)
    ID              reduce using rule 31 (cmd_loop -> cmd .)
    LOOP            reduce using rule 31 (cmd_loop -> cmd .)
    FOR             reduce using rule 31 (cmd_loop -> cmd .)
    WHILE           reduce using rule 31 (cmd_loop -> cmd .)
    ELSIF           reduce using rule 31 (cmd_loop -> cmd .)
    ELSE            reduce using rule 31 (cmd_loop -> cmd .)


state 23

    (24) cmd -> if_statement .

    END             reduce using rule 24 (cmd -> if_statement .)
    IF              reduce using rule 24 (cmd -> if_statement .)
    PUTS            reduce using rule 24 (cmd -> if_statement .)
    RETURN          reduce using rule 24 (cmd -> if_statement .)
    ID              reduce using rule 24 (cmd -> if_statement .)
    LOOP            reduce using rule 24 (cmd -> if_statement .)
    FOR             reduce using rule 24 (cmd -> if_statement .)
    WHILE           reduce using rule 24 (cmd -> if_statement .)
    ELSIF           reduce using rule 24 (cmd -> if_statement .)
    ELSE            reduce using rule 24 (cmd -> if_statement .)


state 24

    (25) cmd -> repeat_statement .

    END             reduce using rule 25 (cmd -> repeat_statement .)
    IF              reduce using rule 25 (cmd -> repeat_statement .)
    PUTS            reduce using rule 25 (cmd -> repeat_statement .)
    RETURN          reduce using rule 25 (cmd -> repeat_statement .)
    ID              reduce using rule 25 (cmd -> repeat_statement .)
    LOOP            reduce using rule 25 (cmd -> repeat_statement .)
    FOR             reduce using rule 25 (cmd -> repeat_statement .)
    WHILE           reduce using rule 25 (cmd -> repeat_statement .)
    ELSIF           reduce using rule 25 (cmd -> repeat_statement .)
    ELSE            reduce using rule 25 (cmd -> repeat_statement .)


state 25

    (26) cmd -> puts .

    END             reduce using rule 26 (cmd -> puts .)
    IF              reduce using rule 26 (cmd -> puts .)
    PUTS            reduce using rule 26 (cmd -> puts .)
    RETURN          reduce using rule 26 (cmd -> puts .)
    ID              reduce using rule 26 (cmd -> puts .)
    LOOP            reduce using rule 26 (cmd -> puts .)
    FOR             reduce using rule 26 (cmd -> puts .)
    WHILE           reduce using rule 26 (cmd -> puts .)
    ELSIF           reduce using rule 26 (cmd -> puts .)
    ELSE            reduce using rule 26 (cmd -> puts .)


state 26

    (27) cmd -> return .

    END             reduce using rule 27 (cmd -> return .)
    IF              reduce using rule 27 (cmd -> return .)
    PUTS            reduce using rule 27 (cmd -> return .)
    RETURN          reduce using rule 27 (cmd -> return .)
    ID              reduce using rule 27 (cmd -> return .)
    LOOP            reduce using rule 27 (cmd -> return .)
    FOR             reduce using rule 27 (cmd -> return .)
    WHILE           reduce using rule 27 (cmd -> return .)
    ELSIF           reduce using rule 27 (cmd -> return .)
    ELSE            reduce using rule 27 (cmd -> return .)


state 27

    (28) cmd -> assign .

    END             reduce using rule 28 (cmd -> assign .)
    IF              reduce using rule 28 (cmd -> assign .)
    PUTS            reduce using rule 28 (cmd -> assign .)
    RETURN          reduce using rule 28 (cmd -> assign .)
    ID              reduce using rule 28 (cmd -> assign .)
    LOOP            reduce using rule 28 (cmd -> assign .)
    FOR             reduce using rule 28 (cmd -> assign .)
    WHILE           reduce using rule 28 (cmd -> assign .)
    ELSIF           reduce using rule 28 (cmd -> assign .)
    ELSE            reduce using rule 28 (cmd -> assign .)


state 28

    (29) cmd -> function_call .

    END             reduce using rule 29 (cmd -> function_call .)
    IF              reduce using rule 29 (cmd -> function_call .)
    PUTS            reduce using rule 29 (cmd -> function_call .)
    RETURN          reduce using rule 29 (cmd -> function_call .)
    ID              reduce using rule 29 (cmd -> function_call .)
    LOOP            reduce using rule 29 (cmd -> function_call .)
    FOR             reduce using rule 29 (cmd -> function_call .)
    WHILE           reduce using rule 29 (cmd -> function_call .)
    ELSIF           reduce using rule 29 (cmd -> function_call .)
    ELSE            reduce using rule 29 (cmd -> function_call .)


state 29

    (33) if_statement -> IF . expression THEN cmd_loop if_statement_loop
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    expression                     shift and go to state 48
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 30

    (37) repeat_statement -> loop_statement .

    END             reduce using rule 37 (repeat_statement -> loop_statement .)
    IF              reduce using rule 37 (repeat_statement -> loop_statement .)
    PUTS            reduce using rule 37 (repeat_statement -> loop_statement .)
    RETURN          reduce using rule 37 (repeat_statement -> loop_statement .)
    ID              reduce using rule 37 (repeat_statement -> loop_statement .)
    LOOP            reduce using rule 37 (repeat_statement -> loop_statement .)
    FOR             reduce using rule 37 (repeat_statement -> loop_statement .)
    WHILE           reduce using rule 37 (repeat_statement -> loop_statement .)
    ELSIF           reduce using rule 37 (repeat_statement -> loop_statement .)
    ELSE            reduce using rule 37 (repeat_statement -> loop_statement .)


state 31

    (38) repeat_statement -> for_statement .

    END             reduce using rule 38 (repeat_statement -> for_statement .)
    IF              reduce using rule 38 (repeat_statement -> for_statement .)
    PUTS            reduce using rule 38 (repeat_statement -> for_statement .)
    RETURN          reduce using rule 38 (repeat_statement -> for_statement .)
    ID              reduce using rule 38 (repeat_statement -> for_statement .)
    LOOP            reduce using rule 38 (repeat_statement -> for_statement .)
    FOR             reduce using rule 38 (repeat_statement -> for_statement .)
    WHILE           reduce using rule 38 (repeat_statement -> for_statement .)
    ELSIF           reduce using rule 38 (repeat_statement -> for_statement .)
    ELSE            reduce using rule 38 (repeat_statement -> for_statement .)


state 32

    (39) repeat_statement -> while_statement .

    END             reduce using rule 39 (repeat_statement -> while_statement .)
    IF              reduce using rule 39 (repeat_statement -> while_statement .)
    PUTS            reduce using rule 39 (repeat_statement -> while_statement .)
    RETURN          reduce using rule 39 (repeat_statement -> while_statement .)
    ID              reduce using rule 39 (repeat_statement -> while_statement .)
    LOOP            reduce using rule 39 (repeat_statement -> while_statement .)
    FOR             reduce using rule 39 (repeat_statement -> while_statement .)
    WHILE           reduce using rule 39 (repeat_statement -> while_statement .)
    ELSIF           reduce using rule 39 (repeat_statement -> while_statement .)
    ELSE            reduce using rule 39 (repeat_statement -> while_statement .)


state 33

    (32) puts -> PUTS . LPAREN STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 61


state 34

    (72) return -> RETURN . expression SEMICOLON
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    expression                     shift and go to state 62
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 35

    (40) loop_statement -> LOOP . cmd_loop END LOOP
    (30) cmd_loop -> . cmd_loop cmd
    (31) cmd_loop -> . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd_loop                       shift and go to state 63
    cmd                            shift and go to state 22
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 36

    (42) for_statement -> FOR . ID IN range LOOP cmd_loop END LOOP SEMICOLON

    ID              shift and go to state 64


state 37

    (41) while_statement -> WHILE . expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    expression                     shift and go to state 65
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 38

    (71) array -> TYPE ID . IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    IS              shift and go to state 66


state 39

    (12) var -> var_loop ID . COLON TYPE
    (14) var_loop -> var_loop ID . COMMA

    COLON           shift and go to state 67
    COMMA           shift and go to state 68


state 40

    (3) subprogram -> FUNCTION ID . decl_param IS decl body
    (4) subprogram -> FUNCTION ID . decl_param IS body
    (16) decl_param -> . LPAREN param RPAREN
    (17) decl_param -> . LPAREN param RPAREN RETURN TYPE

    LPAREN          shift and go to state 70

    decl_param                     shift and go to state 69

state 41

    (10) var -> ID COMMA TYPE . ASSIGN ID

    ASSIGN          shift and go to state 71


state 42

    (11) var -> ID COLON TYPE .

    SEMICOLON       reduce using rule 11 (var -> ID COLON TYPE .)


state 43

    (6) decl -> var SEMICOLON decl .

    BEGIN           reduce using rule 6 (decl -> var SEMICOLON decl .)


state 44

    (5) body -> BEGIN cmd_loop END . ID SEMICOLON

    ID              shift and go to state 72


state 45

    (30) cmd_loop -> cmd_loop cmd .

    END             reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    IF              reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    PUTS            reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    RETURN          reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    ID              reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    LOOP            reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    FOR             reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    WHILE           reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    ELSIF           reduce using rule 30 (cmd_loop -> cmd_loop cmd .)
    ELSE            reduce using rule 30 (cmd_loop -> cmd_loop cmd .)


state 46

    (44) assign -> ID ASSIGN . op_arithmetic SEMICOLON
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    op_arithmetic                  shift and go to state 73
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 47

    (20) function_call -> ID LPAREN . param_pass RPAREN SEMICOLON
    (22) param_pass -> . expression COMMA param_pass
    (23) param_pass -> . expression
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    param_pass                     shift and go to state 74
    expression                     shift and go to state 75
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 48

    (33) if_statement -> IF expression . THEN cmd_loop if_statement_loop
    (45) expression -> expression . AND or_exp

    THEN            shift and go to state 76
    AND             shift and go to state 77


state 49

    (46) expression -> or_exp .
    (47) or_exp -> or_exp . OR comp_exp

    THEN            reduce using rule 46 (expression -> or_exp .)
    AND             reduce using rule 46 (expression -> or_exp .)
    SEMICOLON       reduce using rule 46 (expression -> or_exp .)
    NUMBER_INT      reduce using rule 46 (expression -> or_exp .)
    COMMA           reduce using rule 46 (expression -> or_exp .)
    RPAREN          reduce using rule 46 (expression -> or_exp .)
    IF              reduce using rule 46 (expression -> or_exp .)
    PUTS            reduce using rule 46 (expression -> or_exp .)
    RETURN          reduce using rule 46 (expression -> or_exp .)
    ID              reduce using rule 46 (expression -> or_exp .)
    LOOP            reduce using rule 46 (expression -> or_exp .)
    FOR             reduce using rule 46 (expression -> or_exp .)
    WHILE           reduce using rule 46 (expression -> or_exp .)
    OR              shift and go to state 78


state 50

    (48) or_exp -> comp_exp .
    (49) comp_exp -> comp_exp . comp_op op_arithmetic
    (51) comp_op -> . GREATERTHAN
    (52) comp_op -> . GREATERTHANEQUAL
    (53) comp_op -> . LESSTHAN
    (54) comp_op -> . LESSTHANEQUAL
    (55) comp_op -> . NOTEQUAL
    (56) comp_op -> . EQUAL

    OR              reduce using rule 48 (or_exp -> comp_exp .)
    THEN            reduce using rule 48 (or_exp -> comp_exp .)
    AND             reduce using rule 48 (or_exp -> comp_exp .)
    SEMICOLON       reduce using rule 48 (or_exp -> comp_exp .)
    NUMBER_INT      reduce using rule 48 (or_exp -> comp_exp .)
    COMMA           reduce using rule 48 (or_exp -> comp_exp .)
    RPAREN          reduce using rule 48 (or_exp -> comp_exp .)
    IF              reduce using rule 48 (or_exp -> comp_exp .)
    PUTS            reduce using rule 48 (or_exp -> comp_exp .)
    RETURN          reduce using rule 48 (or_exp -> comp_exp .)
    ID              reduce using rule 48 (or_exp -> comp_exp .)
    LOOP            reduce using rule 48 (or_exp -> comp_exp .)
    FOR             reduce using rule 48 (or_exp -> comp_exp .)
    WHILE           reduce using rule 48 (or_exp -> comp_exp .)
    GREATERTHAN     shift and go to state 80
    GREATERTHANEQUAL shift and go to state 81
    LESSTHAN        shift and go to state 82
    LESSTHANEQUAL   shift and go to state 83
    NOTEQUAL        shift and go to state 84
    EQUAL           shift and go to state 85

    comp_op                        shift and go to state 79

state 51

    (50) comp_exp -> op_arithmetic .
    (57) op_arithmetic -> op_arithmetic . PLUS factor
    (58) op_arithmetic -> op_arithmetic . MINUS factor

    GREATERTHAN     reduce using rule 50 (comp_exp -> op_arithmetic .)
    GREATERTHANEQUAL reduce using rule 50 (comp_exp -> op_arithmetic .)
    LESSTHAN        reduce using rule 50 (comp_exp -> op_arithmetic .)
    LESSTHANEQUAL   reduce using rule 50 (comp_exp -> op_arithmetic .)
    NOTEQUAL        reduce using rule 50 (comp_exp -> op_arithmetic .)
    EQUAL           reduce using rule 50 (comp_exp -> op_arithmetic .)
    OR              reduce using rule 50 (comp_exp -> op_arithmetic .)
    THEN            reduce using rule 50 (comp_exp -> op_arithmetic .)
    AND             reduce using rule 50 (comp_exp -> op_arithmetic .)
    SEMICOLON       reduce using rule 50 (comp_exp -> op_arithmetic .)
    NUMBER_INT      reduce using rule 50 (comp_exp -> op_arithmetic .)
    COMMA           reduce using rule 50 (comp_exp -> op_arithmetic .)
    RPAREN          reduce using rule 50 (comp_exp -> op_arithmetic .)
    IF              reduce using rule 50 (comp_exp -> op_arithmetic .)
    PUTS            reduce using rule 50 (comp_exp -> op_arithmetic .)
    RETURN          reduce using rule 50 (comp_exp -> op_arithmetic .)
    ID              reduce using rule 50 (comp_exp -> op_arithmetic .)
    LOOP            reduce using rule 50 (comp_exp -> op_arithmetic .)
    FOR             reduce using rule 50 (comp_exp -> op_arithmetic .)
    WHILE           reduce using rule 50 (comp_exp -> op_arithmetic .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 52

    (65) unary -> PLUS . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    term                           shift and go to state 88
    function_call_exp              shift and go to state 59

state 53

    (59) op_arithmetic -> factor .
    (60) factor -> factor . TIMES power
    (61) factor -> factor . DIVIDE power

    PLUS            reduce using rule 59 (op_arithmetic -> factor .)
    MINUS           reduce using rule 59 (op_arithmetic -> factor .)
    GREATERTHAN     reduce using rule 59 (op_arithmetic -> factor .)
    GREATERTHANEQUAL reduce using rule 59 (op_arithmetic -> factor .)
    LESSTHAN        reduce using rule 59 (op_arithmetic -> factor .)
    LESSTHANEQUAL   reduce using rule 59 (op_arithmetic -> factor .)
    NOTEQUAL        reduce using rule 59 (op_arithmetic -> factor .)
    EQUAL           reduce using rule 59 (op_arithmetic -> factor .)
    OR              reduce using rule 59 (op_arithmetic -> factor .)
    THEN            reduce using rule 59 (op_arithmetic -> factor .)
    AND             reduce using rule 59 (op_arithmetic -> factor .)
    SEMICOLON       reduce using rule 59 (op_arithmetic -> factor .)
    NUMBER_INT      reduce using rule 59 (op_arithmetic -> factor .)
    COMMA           reduce using rule 59 (op_arithmetic -> factor .)
    RPAREN          reduce using rule 59 (op_arithmetic -> factor .)
    IF              reduce using rule 59 (op_arithmetic -> factor .)
    PUTS            reduce using rule 59 (op_arithmetic -> factor .)
    RETURN          reduce using rule 59 (op_arithmetic -> factor .)
    ID              reduce using rule 59 (op_arithmetic -> factor .)
    LOOP            reduce using rule 59 (op_arithmetic -> factor .)
    FOR             reduce using rule 59 (op_arithmetic -> factor .)
    WHILE           reduce using rule 59 (op_arithmetic -> factor .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 54

    (66) unary -> MINUS . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    term                           shift and go to state 91
    function_call_exp              shift and go to state 59

state 55

    (62) factor -> power .
    (63) power -> power . POWER unary

    TIMES           reduce using rule 62 (factor -> power .)
    DIVIDE          reduce using rule 62 (factor -> power .)
    PLUS            reduce using rule 62 (factor -> power .)
    MINUS           reduce using rule 62 (factor -> power .)
    GREATERTHAN     reduce using rule 62 (factor -> power .)
    GREATERTHANEQUAL reduce using rule 62 (factor -> power .)
    LESSTHAN        reduce using rule 62 (factor -> power .)
    LESSTHANEQUAL   reduce using rule 62 (factor -> power .)
    NOTEQUAL        reduce using rule 62 (factor -> power .)
    EQUAL           reduce using rule 62 (factor -> power .)
    OR              reduce using rule 62 (factor -> power .)
    THEN            reduce using rule 62 (factor -> power .)
    AND             reduce using rule 62 (factor -> power .)
    SEMICOLON       reduce using rule 62 (factor -> power .)
    NUMBER_INT      reduce using rule 62 (factor -> power .)
    COMMA           reduce using rule 62 (factor -> power .)
    RPAREN          reduce using rule 62 (factor -> power .)
    IF              reduce using rule 62 (factor -> power .)
    PUTS            reduce using rule 62 (factor -> power .)
    RETURN          reduce using rule 62 (factor -> power .)
    ID              reduce using rule 62 (factor -> power .)
    LOOP            reduce using rule 62 (factor -> power .)
    FOR             reduce using rule 62 (factor -> power .)
    WHILE           reduce using rule 62 (factor -> power .)
    POWER           shift and go to state 92


state 56

    (64) power -> unary .

    POWER           reduce using rule 64 (power -> unary .)
    TIMES           reduce using rule 64 (power -> unary .)
    DIVIDE          reduce using rule 64 (power -> unary .)
    PLUS            reduce using rule 64 (power -> unary .)
    MINUS           reduce using rule 64 (power -> unary .)
    GREATERTHAN     reduce using rule 64 (power -> unary .)
    GREATERTHANEQUAL reduce using rule 64 (power -> unary .)
    LESSTHAN        reduce using rule 64 (power -> unary .)
    LESSTHANEQUAL   reduce using rule 64 (power -> unary .)
    NOTEQUAL        reduce using rule 64 (power -> unary .)
    EQUAL           reduce using rule 64 (power -> unary .)
    OR              reduce using rule 64 (power -> unary .)
    THEN            reduce using rule 64 (power -> unary .)
    AND             reduce using rule 64 (power -> unary .)
    SEMICOLON       reduce using rule 64 (power -> unary .)
    NUMBER_INT      reduce using rule 64 (power -> unary .)
    COMMA           reduce using rule 64 (power -> unary .)
    RPAREN          reduce using rule 64 (power -> unary .)
    IF              reduce using rule 64 (power -> unary .)
    PUTS            reduce using rule 64 (power -> unary .)
    RETURN          reduce using rule 64 (power -> unary .)
    ID              reduce using rule 64 (power -> unary .)
    LOOP            reduce using rule 64 (power -> unary .)
    FOR             reduce using rule 64 (power -> unary .)
    WHILE           reduce using rule 64 (power -> unary .)


state 57

    (67) unary -> term .

    POWER           reduce using rule 67 (unary -> term .)
    TIMES           reduce using rule 67 (unary -> term .)
    DIVIDE          reduce using rule 67 (unary -> term .)
    PLUS            reduce using rule 67 (unary -> term .)
    MINUS           reduce using rule 67 (unary -> term .)
    GREATERTHAN     reduce using rule 67 (unary -> term .)
    GREATERTHANEQUAL reduce using rule 67 (unary -> term .)
    LESSTHAN        reduce using rule 67 (unary -> term .)
    LESSTHANEQUAL   reduce using rule 67 (unary -> term .)
    NOTEQUAL        reduce using rule 67 (unary -> term .)
    EQUAL           reduce using rule 67 (unary -> term .)
    OR              reduce using rule 67 (unary -> term .)
    THEN            reduce using rule 67 (unary -> term .)
    AND             reduce using rule 67 (unary -> term .)
    SEMICOLON       reduce using rule 67 (unary -> term .)
    NUMBER_INT      reduce using rule 67 (unary -> term .)
    COMMA           reduce using rule 67 (unary -> term .)
    RPAREN          reduce using rule 67 (unary -> term .)
    IF              reduce using rule 67 (unary -> term .)
    PUTS            reduce using rule 67 (unary -> term .)
    RETURN          reduce using rule 67 (unary -> term .)
    ID              reduce using rule 67 (unary -> term .)
    LOOP            reduce using rule 67 (unary -> term .)
    FOR             reduce using rule 67 (unary -> term .)
    WHILE           reduce using rule 67 (unary -> term .)


state 58

    (68) term -> ID .
    (21) function_call_exp -> ID . LPAREN param_pass RPAREN

    POWER           reduce using rule 68 (term -> ID .)
    TIMES           reduce using rule 68 (term -> ID .)
    DIVIDE          reduce using rule 68 (term -> ID .)
    PLUS            reduce using rule 68 (term -> ID .)
    MINUS           reduce using rule 68 (term -> ID .)
    GREATERTHAN     reduce using rule 68 (term -> ID .)
    GREATERTHANEQUAL reduce using rule 68 (term -> ID .)
    LESSTHAN        reduce using rule 68 (term -> ID .)
    LESSTHANEQUAL   reduce using rule 68 (term -> ID .)
    NOTEQUAL        reduce using rule 68 (term -> ID .)
    EQUAL           reduce using rule 68 (term -> ID .)
    OR              reduce using rule 68 (term -> ID .)
    THEN            reduce using rule 68 (term -> ID .)
    AND             reduce using rule 68 (term -> ID .)
    SEMICOLON       reduce using rule 68 (term -> ID .)
    NUMBER_INT      reduce using rule 68 (term -> ID .)
    COMMA           reduce using rule 68 (term -> ID .)
    RPAREN          reduce using rule 68 (term -> ID .)
    IF              reduce using rule 68 (term -> ID .)
    PUTS            reduce using rule 68 (term -> ID .)
    RETURN          reduce using rule 68 (term -> ID .)
    ID              reduce using rule 68 (term -> ID .)
    LOOP            reduce using rule 68 (term -> ID .)
    FOR             reduce using rule 68 (term -> ID .)
    WHILE           reduce using rule 68 (term -> ID .)
    LPAREN          shift and go to state 93


state 59

    (69) term -> function_call_exp .

    POWER           reduce using rule 69 (term -> function_call_exp .)
    TIMES           reduce using rule 69 (term -> function_call_exp .)
    DIVIDE          reduce using rule 69 (term -> function_call_exp .)
    PLUS            reduce using rule 69 (term -> function_call_exp .)
    MINUS           reduce using rule 69 (term -> function_call_exp .)
    GREATERTHAN     reduce using rule 69 (term -> function_call_exp .)
    GREATERTHANEQUAL reduce using rule 69 (term -> function_call_exp .)
    LESSTHAN        reduce using rule 69 (term -> function_call_exp .)
    LESSTHANEQUAL   reduce using rule 69 (term -> function_call_exp .)
    NOTEQUAL        reduce using rule 69 (term -> function_call_exp .)
    EQUAL           reduce using rule 69 (term -> function_call_exp .)
    OR              reduce using rule 69 (term -> function_call_exp .)
    THEN            reduce using rule 69 (term -> function_call_exp .)
    AND             reduce using rule 69 (term -> function_call_exp .)
    SEMICOLON       reduce using rule 69 (term -> function_call_exp .)
    NUMBER_INT      reduce using rule 69 (term -> function_call_exp .)
    COMMA           reduce using rule 69 (term -> function_call_exp .)
    RPAREN          reduce using rule 69 (term -> function_call_exp .)
    IF              reduce using rule 69 (term -> function_call_exp .)
    PUTS            reduce using rule 69 (term -> function_call_exp .)
    RETURN          reduce using rule 69 (term -> function_call_exp .)
    ID              reduce using rule 69 (term -> function_call_exp .)
    LOOP            reduce using rule 69 (term -> function_call_exp .)
    FOR             reduce using rule 69 (term -> function_call_exp .)
    WHILE           reduce using rule 69 (term -> function_call_exp .)


state 60

    (70) term -> LPAREN . expression RPAREN
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    expression                     shift and go to state 94
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 61

    (32) puts -> PUTS LPAREN . STRING RPAREN SEMICOLON

    STRING          shift and go to state 95


state 62

    (72) return -> RETURN expression . SEMICOLON
    (45) expression -> expression . AND or_exp

    SEMICOLON       shift and go to state 96
    AND             shift and go to state 77


state 63

    (40) loop_statement -> LOOP cmd_loop . END LOOP
    (30) cmd_loop -> cmd_loop . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 97
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd                            shift and go to state 45
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 64

    (42) for_statement -> FOR ID . IN range LOOP cmd_loop END LOOP SEMICOLON

    IN              shift and go to state 98


state 65

    (41) while_statement -> WHILE expression . NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON
    (45) expression -> expression . AND or_exp

    NUMBER_INT      shift and go to state 99
    AND             shift and go to state 77


state 66

    (71) array -> TYPE ID IS . ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    ARRAY           shift and go to state 100


state 67

    (12) var -> var_loop ID COLON . TYPE

    TYPE            shift and go to state 101


state 68

    (14) var_loop -> var_loop ID COMMA .

    ID              reduce using rule 14 (var_loop -> var_loop ID COMMA .)


state 69

    (3) subprogram -> FUNCTION ID decl_param . IS decl body
    (4) subprogram -> FUNCTION ID decl_param . IS body

    IS              shift and go to state 102


state 70

    (16) decl_param -> LPAREN . param RPAREN
    (17) decl_param -> LPAREN . param RPAREN RETURN TYPE
    (18) param -> . ID COLON TYPE SEMICOLON param
    (19) param -> . ID COLON TYPE SEMICOLON

    ID              shift and go to state 104

    param                          shift and go to state 103

state 71

    (10) var -> ID COMMA TYPE ASSIGN . ID

    ID              shift and go to state 105


state 72

    (5) body -> BEGIN cmd_loop END ID . SEMICOLON

    SEMICOLON       shift and go to state 106


state 73

    (44) assign -> ID ASSIGN op_arithmetic . SEMICOLON
    (57) op_arithmetic -> op_arithmetic . PLUS factor
    (58) op_arithmetic -> op_arithmetic . MINUS factor

    SEMICOLON       shift and go to state 107
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 74

    (20) function_call -> ID LPAREN param_pass . RPAREN SEMICOLON

    RPAREN          shift and go to state 108


state 75

    (22) param_pass -> expression . COMMA param_pass
    (23) param_pass -> expression .
    (45) expression -> expression . AND or_exp

    COMMA           shift and go to state 109
    RPAREN          reduce using rule 23 (param_pass -> expression .)
    AND             shift and go to state 77


state 76

    (33) if_statement -> IF expression THEN . cmd_loop if_statement_loop
    (30) cmd_loop -> . cmd_loop cmd
    (31) cmd_loop -> . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd_loop                       shift and go to state 110
    cmd                            shift and go to state 22
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 77

    (45) expression -> expression AND . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    or_exp                         shift and go to state 111
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 78

    (47) or_exp -> or_exp OR . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    comp_exp                       shift and go to state 112
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 79

    (49) comp_exp -> comp_exp comp_op . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    op_arithmetic                  shift and go to state 113
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 80

    (51) comp_op -> GREATERTHAN .

    PLUS            reduce using rule 51 (comp_op -> GREATERTHAN .)
    MINUS           reduce using rule 51 (comp_op -> GREATERTHAN .)
    ID              reduce using rule 51 (comp_op -> GREATERTHAN .)
    LPAREN          reduce using rule 51 (comp_op -> GREATERTHAN .)


state 81

    (52) comp_op -> GREATERTHANEQUAL .

    PLUS            reduce using rule 52 (comp_op -> GREATERTHANEQUAL .)
    MINUS           reduce using rule 52 (comp_op -> GREATERTHANEQUAL .)
    ID              reduce using rule 52 (comp_op -> GREATERTHANEQUAL .)
    LPAREN          reduce using rule 52 (comp_op -> GREATERTHANEQUAL .)


state 82

    (53) comp_op -> LESSTHAN .

    PLUS            reduce using rule 53 (comp_op -> LESSTHAN .)
    MINUS           reduce using rule 53 (comp_op -> LESSTHAN .)
    ID              reduce using rule 53 (comp_op -> LESSTHAN .)
    LPAREN          reduce using rule 53 (comp_op -> LESSTHAN .)


state 83

    (54) comp_op -> LESSTHANEQUAL .

    PLUS            reduce using rule 54 (comp_op -> LESSTHANEQUAL .)
    MINUS           reduce using rule 54 (comp_op -> LESSTHANEQUAL .)
    ID              reduce using rule 54 (comp_op -> LESSTHANEQUAL .)
    LPAREN          reduce using rule 54 (comp_op -> LESSTHANEQUAL .)


state 84

    (55) comp_op -> NOTEQUAL .

    PLUS            reduce using rule 55 (comp_op -> NOTEQUAL .)
    MINUS           reduce using rule 55 (comp_op -> NOTEQUAL .)
    ID              reduce using rule 55 (comp_op -> NOTEQUAL .)
    LPAREN          reduce using rule 55 (comp_op -> NOTEQUAL .)


state 85

    (56) comp_op -> EQUAL .

    PLUS            reduce using rule 56 (comp_op -> EQUAL .)
    MINUS           reduce using rule 56 (comp_op -> EQUAL .)
    ID              reduce using rule 56 (comp_op -> EQUAL .)
    LPAREN          reduce using rule 56 (comp_op -> EQUAL .)


state 86

    (57) op_arithmetic -> op_arithmetic PLUS . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    factor                         shift and go to state 114
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 87

    (58) op_arithmetic -> op_arithmetic MINUS . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    factor                         shift and go to state 115
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 88

    (65) unary -> PLUS term .

    POWER           reduce using rule 65 (unary -> PLUS term .)
    TIMES           reduce using rule 65 (unary -> PLUS term .)
    DIVIDE          reduce using rule 65 (unary -> PLUS term .)
    PLUS            reduce using rule 65 (unary -> PLUS term .)
    MINUS           reduce using rule 65 (unary -> PLUS term .)
    GREATERTHAN     reduce using rule 65 (unary -> PLUS term .)
    GREATERTHANEQUAL reduce using rule 65 (unary -> PLUS term .)
    LESSTHAN        reduce using rule 65 (unary -> PLUS term .)
    LESSTHANEQUAL   reduce using rule 65 (unary -> PLUS term .)
    NOTEQUAL        reduce using rule 65 (unary -> PLUS term .)
    EQUAL           reduce using rule 65 (unary -> PLUS term .)
    OR              reduce using rule 65 (unary -> PLUS term .)
    THEN            reduce using rule 65 (unary -> PLUS term .)
    AND             reduce using rule 65 (unary -> PLUS term .)
    SEMICOLON       reduce using rule 65 (unary -> PLUS term .)
    NUMBER_INT      reduce using rule 65 (unary -> PLUS term .)
    COMMA           reduce using rule 65 (unary -> PLUS term .)
    RPAREN          reduce using rule 65 (unary -> PLUS term .)
    IF              reduce using rule 65 (unary -> PLUS term .)
    PUTS            reduce using rule 65 (unary -> PLUS term .)
    RETURN          reduce using rule 65 (unary -> PLUS term .)
    ID              reduce using rule 65 (unary -> PLUS term .)
    LOOP            reduce using rule 65 (unary -> PLUS term .)
    FOR             reduce using rule 65 (unary -> PLUS term .)
    WHILE           reduce using rule 65 (unary -> PLUS term .)


state 89

    (60) factor -> factor TIMES . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    power                          shift and go to state 116
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 90

    (61) factor -> factor DIVIDE . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    power                          shift and go to state 117
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 91

    (66) unary -> MINUS term .

    POWER           reduce using rule 66 (unary -> MINUS term .)
    TIMES           reduce using rule 66 (unary -> MINUS term .)
    DIVIDE          reduce using rule 66 (unary -> MINUS term .)
    PLUS            reduce using rule 66 (unary -> MINUS term .)
    MINUS           reduce using rule 66 (unary -> MINUS term .)
    GREATERTHAN     reduce using rule 66 (unary -> MINUS term .)
    GREATERTHANEQUAL reduce using rule 66 (unary -> MINUS term .)
    LESSTHAN        reduce using rule 66 (unary -> MINUS term .)
    LESSTHANEQUAL   reduce using rule 66 (unary -> MINUS term .)
    NOTEQUAL        reduce using rule 66 (unary -> MINUS term .)
    EQUAL           reduce using rule 66 (unary -> MINUS term .)
    OR              reduce using rule 66 (unary -> MINUS term .)
    THEN            reduce using rule 66 (unary -> MINUS term .)
    AND             reduce using rule 66 (unary -> MINUS term .)
    SEMICOLON       reduce using rule 66 (unary -> MINUS term .)
    NUMBER_INT      reduce using rule 66 (unary -> MINUS term .)
    COMMA           reduce using rule 66 (unary -> MINUS term .)
    RPAREN          reduce using rule 66 (unary -> MINUS term .)
    IF              reduce using rule 66 (unary -> MINUS term .)
    PUTS            reduce using rule 66 (unary -> MINUS term .)
    RETURN          reduce using rule 66 (unary -> MINUS term .)
    ID              reduce using rule 66 (unary -> MINUS term .)
    LOOP            reduce using rule 66 (unary -> MINUS term .)
    FOR             reduce using rule 66 (unary -> MINUS term .)
    WHILE           reduce using rule 66 (unary -> MINUS term .)


state 92

    (63) power -> power POWER . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    unary                          shift and go to state 118
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 93

    (21) function_call_exp -> ID LPAREN . param_pass RPAREN
    (22) param_pass -> . expression COMMA param_pass
    (23) param_pass -> . expression
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    param_pass                     shift and go to state 119
    expression                     shift and go to state 75
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 94

    (70) term -> LPAREN expression . RPAREN
    (45) expression -> expression . AND or_exp

    RPAREN          shift and go to state 120
    AND             shift and go to state 77


state 95

    (32) puts -> PUTS LPAREN STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 121


state 96

    (72) return -> RETURN expression SEMICOLON .

    END             reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    IF              reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    PUTS            reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    ID              reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    LOOP            reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    ELSIF           reduce using rule 72 (return -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 72 (return -> RETURN expression SEMICOLON .)


state 97

    (40) loop_statement -> LOOP cmd_loop END . LOOP

    LOOP            shift and go to state 122


state 98

    (42) for_statement -> FOR ID IN . range LOOP cmd_loop END LOOP SEMICOLON
    (43) range -> . ID DOTDOT ID

    ID              shift and go to state 123

    range                          shift and go to state 124

state 99

    (41) while_statement -> WHILE expression NUMBER_INT . LOOP cmd_loop END LOOP SEMICOLON

    LOOP            shift and go to state 125


state 100

    (71) array -> TYPE ID IS ARRAY . LPAREN range RPAREN OF TYPE SEMICOLON

    LPAREN          shift and go to state 126


state 101

    (12) var -> var_loop ID COLON TYPE .

    SEMICOLON       reduce using rule 12 (var -> var_loop ID COLON TYPE .)


state 102

    (3) subprogram -> FUNCTION ID decl_param IS . decl body
    (4) subprogram -> FUNCTION ID decl_param IS . body
    (6) decl -> . var SEMICOLON decl
    (7) decl -> . var SEMICOLON
    (8) decl -> . subprogram decl
    (9) decl -> . subprogram
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON
    (10) var -> . ID COMMA TYPE ASSIGN ID
    (11) var -> . ID COLON TYPE
    (12) var -> . var_loop ID COLON TYPE
    (13) var -> . array
    (3) subprogram -> . FUNCTION ID decl_param IS decl body
    (4) subprogram -> . FUNCTION ID decl_param IS body
    (14) var_loop -> . var_loop ID COMMA
    (15) var_loop -> . ID COMMA
    (71) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON

    BEGIN           shift and go to state 10
    ID              shift and go to state 5
    FUNCTION        shift and go to state 14
    TYPE            shift and go to state 11

    decl                           shift and go to state 127
    body                           shift and go to state 128
    var                            shift and go to state 8
    subprogram                     shift and go to state 9
    var_loop                       shift and go to state 12
    array                          shift and go to state 13

state 103

    (16) decl_param -> LPAREN param . RPAREN
    (17) decl_param -> LPAREN param . RPAREN RETURN TYPE

    RPAREN          shift and go to state 129


state 104

    (18) param -> ID . COLON TYPE SEMICOLON param
    (19) param -> ID . COLON TYPE SEMICOLON

    COLON           shift and go to state 130


state 105

    (10) var -> ID COMMA TYPE ASSIGN ID .

    SEMICOLON       reduce using rule 10 (var -> ID COMMA TYPE ASSIGN ID .)


state 106

    (5) body -> BEGIN cmd_loop END ID SEMICOLON .

    $end            reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    ID              reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    FUNCTION        reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    TYPE            reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    BEGIN           reduce using rule 5 (body -> BEGIN cmd_loop END ID SEMICOLON .)


state 107

    (44) assign -> ID ASSIGN op_arithmetic SEMICOLON .

    END             reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    IF              reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    PUTS            reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    RETURN          reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ID              reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    LOOP            reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    FOR             reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    WHILE           reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSIF           reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSE            reduce using rule 44 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)


state 108

    (20) function_call -> ID LPAREN param_pass RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 131


state 109

    (22) param_pass -> expression COMMA . param_pass
    (22) param_pass -> . expression COMMA param_pass
    (23) param_pass -> . expression
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    expression                     shift and go to state 75
    param_pass                     shift and go to state 132
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 110

    (33) if_statement -> IF expression THEN cmd_loop . if_statement_loop
    (30) cmd_loop -> cmd_loop . cmd
    (34) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (35) if_statement_loop -> . ELSE expression cmd_loop END IF SEMICOLON
    (36) if_statement_loop -> . END IF SEMICOLON
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 134
    ELSE            shift and go to state 135
    END             shift and go to state 136
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    if_statement_loop              shift and go to state 133
    cmd                            shift and go to state 45
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 111

    (45) expression -> expression AND or_exp .
    (47) or_exp -> or_exp . OR comp_exp

    THEN            reduce using rule 45 (expression -> expression AND or_exp .)
    AND             reduce using rule 45 (expression -> expression AND or_exp .)
    SEMICOLON       reduce using rule 45 (expression -> expression AND or_exp .)
    NUMBER_INT      reduce using rule 45 (expression -> expression AND or_exp .)
    COMMA           reduce using rule 45 (expression -> expression AND or_exp .)
    RPAREN          reduce using rule 45 (expression -> expression AND or_exp .)
    IF              reduce using rule 45 (expression -> expression AND or_exp .)
    PUTS            reduce using rule 45 (expression -> expression AND or_exp .)
    RETURN          reduce using rule 45 (expression -> expression AND or_exp .)
    ID              reduce using rule 45 (expression -> expression AND or_exp .)
    LOOP            reduce using rule 45 (expression -> expression AND or_exp .)
    FOR             reduce using rule 45 (expression -> expression AND or_exp .)
    WHILE           reduce using rule 45 (expression -> expression AND or_exp .)
    OR              shift and go to state 78


state 112

    (47) or_exp -> or_exp OR comp_exp .
    (49) comp_exp -> comp_exp . comp_op op_arithmetic
    (51) comp_op -> . GREATERTHAN
    (52) comp_op -> . GREATERTHANEQUAL
    (53) comp_op -> . LESSTHAN
    (54) comp_op -> . LESSTHANEQUAL
    (55) comp_op -> . NOTEQUAL
    (56) comp_op -> . EQUAL

    OR              reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    THEN            reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    AND             reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    SEMICOLON       reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    NUMBER_INT      reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    COMMA           reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    RPAREN          reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    IF              reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    PUTS            reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    RETURN          reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    ID              reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    LOOP            reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    FOR             reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    WHILE           reduce using rule 47 (or_exp -> or_exp OR comp_exp .)
    GREATERTHAN     shift and go to state 80
    GREATERTHANEQUAL shift and go to state 81
    LESSTHAN        shift and go to state 82
    LESSTHANEQUAL   shift and go to state 83
    NOTEQUAL        shift and go to state 84
    EQUAL           shift and go to state 85

    comp_op                        shift and go to state 79

state 113

    (49) comp_exp -> comp_exp comp_op op_arithmetic .
    (57) op_arithmetic -> op_arithmetic . PLUS factor
    (58) op_arithmetic -> op_arithmetic . MINUS factor

    GREATERTHAN     reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    GREATERTHANEQUAL reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LESSTHAN        reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LESSTHANEQUAL   reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    NOTEQUAL        reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    EQUAL           reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    OR              reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    THEN            reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    AND             reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    SEMICOLON       reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    NUMBER_INT      reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    COMMA           reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    RPAREN          reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    IF              reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    PUTS            reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    RETURN          reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    ID              reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LOOP            reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    FOR             reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    WHILE           reduce using rule 49 (comp_exp -> comp_exp comp_op op_arithmetic .)
    PLUS            shift and go to state 86
    MINUS           shift and go to state 87


state 114

    (57) op_arithmetic -> op_arithmetic PLUS factor .
    (60) factor -> factor . TIMES power
    (61) factor -> factor . DIVIDE power

    PLUS            reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    MINUS           reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    GREATERTHAN     reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    GREATERTHANEQUAL reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    LESSTHAN        reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    LESSTHANEQUAL   reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    NOTEQUAL        reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    EQUAL           reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    OR              reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    THEN            reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    AND             reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    SEMICOLON       reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    NUMBER_INT      reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    COMMA           reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    RPAREN          reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    IF              reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    PUTS            reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    RETURN          reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    ID              reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    LOOP            reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    FOR             reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    WHILE           reduce using rule 57 (op_arithmetic -> op_arithmetic PLUS factor .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 115

    (58) op_arithmetic -> op_arithmetic MINUS factor .
    (60) factor -> factor . TIMES power
    (61) factor -> factor . DIVIDE power

    PLUS            reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    MINUS           reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    GREATERTHAN     reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    GREATERTHANEQUAL reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    LESSTHAN        reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    LESSTHANEQUAL   reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    NOTEQUAL        reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    EQUAL           reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    OR              reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    THEN            reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    AND             reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    SEMICOLON       reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    NUMBER_INT      reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    COMMA           reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    RPAREN          reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    IF              reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    PUTS            reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    RETURN          reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    ID              reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    LOOP            reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    FOR             reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    WHILE           reduce using rule 58 (op_arithmetic -> op_arithmetic MINUS factor .)
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90


state 116

    (60) factor -> factor TIMES power .
    (63) power -> power . POWER unary

    TIMES           reduce using rule 60 (factor -> factor TIMES power .)
    DIVIDE          reduce using rule 60 (factor -> factor TIMES power .)
    PLUS            reduce using rule 60 (factor -> factor TIMES power .)
    MINUS           reduce using rule 60 (factor -> factor TIMES power .)
    GREATERTHAN     reduce using rule 60 (factor -> factor TIMES power .)
    GREATERTHANEQUAL reduce using rule 60 (factor -> factor TIMES power .)
    LESSTHAN        reduce using rule 60 (factor -> factor TIMES power .)
    LESSTHANEQUAL   reduce using rule 60 (factor -> factor TIMES power .)
    NOTEQUAL        reduce using rule 60 (factor -> factor TIMES power .)
    EQUAL           reduce using rule 60 (factor -> factor TIMES power .)
    OR              reduce using rule 60 (factor -> factor TIMES power .)
    THEN            reduce using rule 60 (factor -> factor TIMES power .)
    AND             reduce using rule 60 (factor -> factor TIMES power .)
    SEMICOLON       reduce using rule 60 (factor -> factor TIMES power .)
    NUMBER_INT      reduce using rule 60 (factor -> factor TIMES power .)
    COMMA           reduce using rule 60 (factor -> factor TIMES power .)
    RPAREN          reduce using rule 60 (factor -> factor TIMES power .)
    IF              reduce using rule 60 (factor -> factor TIMES power .)
    PUTS            reduce using rule 60 (factor -> factor TIMES power .)
    RETURN          reduce using rule 60 (factor -> factor TIMES power .)
    ID              reduce using rule 60 (factor -> factor TIMES power .)
    LOOP            reduce using rule 60 (factor -> factor TIMES power .)
    FOR             reduce using rule 60 (factor -> factor TIMES power .)
    WHILE           reduce using rule 60 (factor -> factor TIMES power .)
    POWER           shift and go to state 92


state 117

    (61) factor -> factor DIVIDE power .
    (63) power -> power . POWER unary

    TIMES           reduce using rule 61 (factor -> factor DIVIDE power .)
    DIVIDE          reduce using rule 61 (factor -> factor DIVIDE power .)
    PLUS            reduce using rule 61 (factor -> factor DIVIDE power .)
    MINUS           reduce using rule 61 (factor -> factor DIVIDE power .)
    GREATERTHAN     reduce using rule 61 (factor -> factor DIVIDE power .)
    GREATERTHANEQUAL reduce using rule 61 (factor -> factor DIVIDE power .)
    LESSTHAN        reduce using rule 61 (factor -> factor DIVIDE power .)
    LESSTHANEQUAL   reduce using rule 61 (factor -> factor DIVIDE power .)
    NOTEQUAL        reduce using rule 61 (factor -> factor DIVIDE power .)
    EQUAL           reduce using rule 61 (factor -> factor DIVIDE power .)
    OR              reduce using rule 61 (factor -> factor DIVIDE power .)
    THEN            reduce using rule 61 (factor -> factor DIVIDE power .)
    AND             reduce using rule 61 (factor -> factor DIVIDE power .)
    SEMICOLON       reduce using rule 61 (factor -> factor DIVIDE power .)
    NUMBER_INT      reduce using rule 61 (factor -> factor DIVIDE power .)
    COMMA           reduce using rule 61 (factor -> factor DIVIDE power .)
    RPAREN          reduce using rule 61 (factor -> factor DIVIDE power .)
    IF              reduce using rule 61 (factor -> factor DIVIDE power .)
    PUTS            reduce using rule 61 (factor -> factor DIVIDE power .)
    RETURN          reduce using rule 61 (factor -> factor DIVIDE power .)
    ID              reduce using rule 61 (factor -> factor DIVIDE power .)
    LOOP            reduce using rule 61 (factor -> factor DIVIDE power .)
    FOR             reduce using rule 61 (factor -> factor DIVIDE power .)
    WHILE           reduce using rule 61 (factor -> factor DIVIDE power .)
    POWER           shift and go to state 92


state 118

    (63) power -> power POWER unary .

    POWER           reduce using rule 63 (power -> power POWER unary .)
    TIMES           reduce using rule 63 (power -> power POWER unary .)
    DIVIDE          reduce using rule 63 (power -> power POWER unary .)
    PLUS            reduce using rule 63 (power -> power POWER unary .)
    MINUS           reduce using rule 63 (power -> power POWER unary .)
    GREATERTHAN     reduce using rule 63 (power -> power POWER unary .)
    GREATERTHANEQUAL reduce using rule 63 (power -> power POWER unary .)
    LESSTHAN        reduce using rule 63 (power -> power POWER unary .)
    LESSTHANEQUAL   reduce using rule 63 (power -> power POWER unary .)
    NOTEQUAL        reduce using rule 63 (power -> power POWER unary .)
    EQUAL           reduce using rule 63 (power -> power POWER unary .)
    OR              reduce using rule 63 (power -> power POWER unary .)
    THEN            reduce using rule 63 (power -> power POWER unary .)
    AND             reduce using rule 63 (power -> power POWER unary .)
    SEMICOLON       reduce using rule 63 (power -> power POWER unary .)
    NUMBER_INT      reduce using rule 63 (power -> power POWER unary .)
    COMMA           reduce using rule 63 (power -> power POWER unary .)
    RPAREN          reduce using rule 63 (power -> power POWER unary .)
    IF              reduce using rule 63 (power -> power POWER unary .)
    PUTS            reduce using rule 63 (power -> power POWER unary .)
    RETURN          reduce using rule 63 (power -> power POWER unary .)
    ID              reduce using rule 63 (power -> power POWER unary .)
    LOOP            reduce using rule 63 (power -> power POWER unary .)
    FOR             reduce using rule 63 (power -> power POWER unary .)
    WHILE           reduce using rule 63 (power -> power POWER unary .)


state 119

    (21) function_call_exp -> ID LPAREN param_pass . RPAREN

    RPAREN          shift and go to state 137


state 120

    (70) term -> LPAREN expression RPAREN .

    POWER           reduce using rule 70 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 70 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 70 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 70 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 70 (term -> LPAREN expression RPAREN .)
    GREATERTHAN     reduce using rule 70 (term -> LPAREN expression RPAREN .)
    GREATERTHANEQUAL reduce using rule 70 (term -> LPAREN expression RPAREN .)
    LESSTHAN        reduce using rule 70 (term -> LPAREN expression RPAREN .)
    LESSTHANEQUAL   reduce using rule 70 (term -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 70 (term -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 70 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 70 (term -> LPAREN expression RPAREN .)
    THEN            reduce using rule 70 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 70 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 70 (term -> LPAREN expression RPAREN .)
    NUMBER_INT      reduce using rule 70 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 70 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 70 (term -> LPAREN expression RPAREN .)
    IF              reduce using rule 70 (term -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 70 (term -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 70 (term -> LPAREN expression RPAREN .)
    ID              reduce using rule 70 (term -> LPAREN expression RPAREN .)
    LOOP            reduce using rule 70 (term -> LPAREN expression RPAREN .)
    FOR             reduce using rule 70 (term -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 70 (term -> LPAREN expression RPAREN .)


state 121

    (32) puts -> PUTS LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 138


state 122

    (40) loop_statement -> LOOP cmd_loop END LOOP .

    END             reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    IF              reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    PUTS            reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    RETURN          reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    ID              reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    LOOP            reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    FOR             reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    WHILE           reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    ELSIF           reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)
    ELSE            reduce using rule 40 (loop_statement -> LOOP cmd_loop END LOOP .)


state 123

    (43) range -> ID . DOTDOT ID

    DOTDOT          shift and go to state 139


state 124

    (42) for_statement -> FOR ID IN range . LOOP cmd_loop END LOOP SEMICOLON

    LOOP            shift and go to state 140


state 125

    (41) while_statement -> WHILE expression NUMBER_INT LOOP . cmd_loop END LOOP SEMICOLON
    (30) cmd_loop -> . cmd_loop cmd
    (31) cmd_loop -> . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd_loop                       shift and go to state 141
    cmd                            shift and go to state 22
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 126

    (71) array -> TYPE ID IS ARRAY LPAREN . range RPAREN OF TYPE SEMICOLON
    (43) range -> . ID DOTDOT ID

    ID              shift and go to state 123

    range                          shift and go to state 142

state 127

    (3) subprogram -> FUNCTION ID decl_param IS decl . body
    (5) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 10

    body                           shift and go to state 143

state 128

    (4) subprogram -> FUNCTION ID decl_param IS body .

    ID              reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)
    FUNCTION        reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)
    TYPE            reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)
    BEGIN           reduce using rule 4 (subprogram -> FUNCTION ID decl_param IS body .)


state 129

    (16) decl_param -> LPAREN param RPAREN .
    (17) decl_param -> LPAREN param RPAREN . RETURN TYPE

    IS              reduce using rule 16 (decl_param -> LPAREN param RPAREN .)
    RETURN          shift and go to state 144


state 130

    (18) param -> ID COLON . TYPE SEMICOLON param
    (19) param -> ID COLON . TYPE SEMICOLON

    TYPE            shift and go to state 145


state 131

    (20) function_call -> ID LPAREN param_pass RPAREN SEMICOLON .

    END             reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    IF              reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    PUTS            reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    RETURN          reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ID              reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    LOOP            reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    FOR             reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    WHILE           reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ELSIF           reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ELSE            reduce using rule 20 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)


state 132

    (22) param_pass -> expression COMMA param_pass .

    RPAREN          reduce using rule 22 (param_pass -> expression COMMA param_pass .)


state 133

    (33) if_statement -> IF expression THEN cmd_loop if_statement_loop .

    END             reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    IF              reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    PUTS            reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    RETURN          reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ID              reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    LOOP            reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    FOR             reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    WHILE           reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSE            reduce using rule 33 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)


state 134

    (34) if_statement_loop -> ELSIF . expression cmd_loop if_statement_loop
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    expression                     shift and go to state 146
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 135

    (35) if_statement_loop -> ELSE . expression cmd_loop END IF SEMICOLON
    (45) expression -> . expression AND or_exp
    (46) expression -> . or_exp
    (47) or_exp -> . or_exp OR comp_exp
    (48) or_exp -> . comp_exp
    (49) comp_exp -> . comp_exp comp_op op_arithmetic
    (50) comp_exp -> . op_arithmetic
    (57) op_arithmetic -> . op_arithmetic PLUS factor
    (58) op_arithmetic -> . op_arithmetic MINUS factor
    (59) op_arithmetic -> . factor
    (60) factor -> . factor TIMES power
    (61) factor -> . factor DIVIDE power
    (62) factor -> . power
    (63) power -> . power POWER unary
    (64) power -> . unary
    (65) unary -> . PLUS term
    (66) unary -> . MINUS term
    (67) unary -> . term
    (68) term -> . ID
    (69) term -> . function_call_exp
    (70) term -> . LPAREN expression RPAREN
    (21) function_call_exp -> . ID LPAREN param_pass RPAREN

    PLUS            shift and go to state 52
    MINUS           shift and go to state 54
    ID              shift and go to state 58
    LPAREN          shift and go to state 60

    expression                     shift and go to state 147
    or_exp                         shift and go to state 49
    comp_exp                       shift and go to state 50
    op_arithmetic                  shift and go to state 51
    factor                         shift and go to state 53
    power                          shift and go to state 55
    unary                          shift and go to state 56
    term                           shift and go to state 57
    function_call_exp              shift and go to state 59

state 136

    (36) if_statement_loop -> END . IF SEMICOLON

    IF              shift and go to state 148


state 137

    (21) function_call_exp -> ID LPAREN param_pass RPAREN .

    POWER           reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    TIMES           reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    DIVIDE          reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    PLUS            reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    MINUS           reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    GREATERTHAN     reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    GREATERTHANEQUAL reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LESSTHAN        reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LESSTHANEQUAL   reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    NOTEQUAL        reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    EQUAL           reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    OR              reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    THEN            reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    AND             reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    SEMICOLON       reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    NUMBER_INT      reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    COMMA           reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    RPAREN          reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    IF              reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    PUTS            reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    RETURN          reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    ID              reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LOOP            reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    FOR             reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    WHILE           reduce using rule 21 (function_call_exp -> ID LPAREN param_pass RPAREN .)


state 138

    (32) puts -> PUTS LPAREN STRING RPAREN SEMICOLON .

    END             reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    IF              reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    PUTS            reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    RETURN          reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ID              reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    LOOP            reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    FOR             reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    WHILE           reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ELSIF           reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)
    ELSE            reduce using rule 32 (puts -> PUTS LPAREN STRING RPAREN SEMICOLON .)


state 139

    (43) range -> ID DOTDOT . ID

    ID              shift and go to state 149


state 140

    (42) for_statement -> FOR ID IN range LOOP . cmd_loop END LOOP SEMICOLON
    (30) cmd_loop -> . cmd_loop cmd
    (31) cmd_loop -> . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd_loop                       shift and go to state 150
    cmd                            shift and go to state 22
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 141

    (41) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop . END LOOP SEMICOLON
    (30) cmd_loop -> cmd_loop . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 151
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd                            shift and go to state 45
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 142

    (71) array -> TYPE ID IS ARRAY LPAREN range . RPAREN OF TYPE SEMICOLON

    RPAREN          shift and go to state 152


state 143

    (3) subprogram -> FUNCTION ID decl_param IS decl body .

    ID              reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)
    FUNCTION        reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)
    TYPE            reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)
    BEGIN           reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS decl body .)


state 144

    (17) decl_param -> LPAREN param RPAREN RETURN . TYPE

    TYPE            shift and go to state 153


state 145

    (18) param -> ID COLON TYPE . SEMICOLON param
    (19) param -> ID COLON TYPE . SEMICOLON

    SEMICOLON       shift and go to state 154


state 146

    (34) if_statement_loop -> ELSIF expression . cmd_loop if_statement_loop
    (45) expression -> expression . AND or_exp
    (30) cmd_loop -> . cmd_loop cmd
    (31) cmd_loop -> . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    AND             shift and go to state 77
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd_loop                       shift and go to state 155
    cmd                            shift and go to state 22
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 147

    (35) if_statement_loop -> ELSE expression . cmd_loop END IF SEMICOLON
    (45) expression -> expression . AND or_exp
    (30) cmd_loop -> . cmd_loop cmd
    (31) cmd_loop -> . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    AND             shift and go to state 77
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd_loop                       shift and go to state 156
    cmd                            shift and go to state 22
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 148

    (36) if_statement_loop -> END IF . SEMICOLON

    SEMICOLON       shift and go to state 157


state 149

    (43) range -> ID DOTDOT ID .

    LOOP            reduce using rule 43 (range -> ID DOTDOT ID .)
    RPAREN          reduce using rule 43 (range -> ID DOTDOT ID .)


state 150

    (42) for_statement -> FOR ID IN range LOOP cmd_loop . END LOOP SEMICOLON
    (30) cmd_loop -> cmd_loop . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 158
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd                            shift and go to state 45
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 151

    (41) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 159


state 152

    (71) array -> TYPE ID IS ARRAY LPAREN range RPAREN . OF TYPE SEMICOLON

    OF              shift and go to state 160


state 153

    (17) decl_param -> LPAREN param RPAREN RETURN TYPE .

    IS              reduce using rule 17 (decl_param -> LPAREN param RPAREN RETURN TYPE .)


state 154

    (18) param -> ID COLON TYPE SEMICOLON . param
    (19) param -> ID COLON TYPE SEMICOLON .
    (18) param -> . ID COLON TYPE SEMICOLON param
    (19) param -> . ID COLON TYPE SEMICOLON

    RPAREN          reduce using rule 19 (param -> ID COLON TYPE SEMICOLON .)
    ID              shift and go to state 104

    param                          shift and go to state 161

state 155

    (34) if_statement_loop -> ELSIF expression cmd_loop . if_statement_loop
    (30) cmd_loop -> cmd_loop . cmd
    (34) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (35) if_statement_loop -> . ELSE expression cmd_loop END IF SEMICOLON
    (36) if_statement_loop -> . END IF SEMICOLON
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 134
    ELSE            shift and go to state 135
    END             shift and go to state 136
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    if_statement_loop              shift and go to state 162
    cmd                            shift and go to state 45
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 156

    (35) if_statement_loop -> ELSE expression cmd_loop . END IF SEMICOLON
    (30) cmd_loop -> cmd_loop . cmd
    (24) cmd -> . if_statement
    (25) cmd -> . repeat_statement
    (26) cmd -> . puts
    (27) cmd -> . return
    (28) cmd -> . assign
    (29) cmd -> . function_call
    (33) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (37) repeat_statement -> . loop_statement
    (38) repeat_statement -> . for_statement
    (39) repeat_statement -> . while_statement
    (32) puts -> . PUTS LPAREN STRING RPAREN SEMICOLON
    (72) return -> . RETURN expression SEMICOLON
    (44) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (20) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (40) loop_statement -> . LOOP cmd_loop END LOOP
    (42) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (41) while_statement -> . WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 163
    IF              shift and go to state 29
    PUTS            shift and go to state 33
    RETURN          shift and go to state 34
    ID              shift and go to state 21
    LOOP            shift and go to state 35
    FOR             shift and go to state 36
    WHILE           shift and go to state 37

    cmd                            shift and go to state 45
    if_statement                   shift and go to state 23
    repeat_statement               shift and go to state 24
    puts                           shift and go to state 25
    return                         shift and go to state 26
    assign                         shift and go to state 27
    function_call                  shift and go to state 28
    loop_statement                 shift and go to state 30
    for_statement                  shift and go to state 31
    while_statement                shift and go to state 32

state 157

    (36) if_statement_loop -> END IF SEMICOLON .

    END             reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    IF              reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    PUTS            reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    RETURN          reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    ID              reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    LOOP            reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    FOR             reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    WHILE           reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    ELSIF           reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)
    ELSE            reduce using rule 36 (if_statement_loop -> END IF SEMICOLON .)


state 158

    (42) for_statement -> FOR ID IN range LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 164


state 159

    (41) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 165


state 160

    (71) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF . TYPE SEMICOLON

    TYPE            shift and go to state 166


state 161

    (18) param -> ID COLON TYPE SEMICOLON param .

    RPAREN          reduce using rule 18 (param -> ID COLON TYPE SEMICOLON param .)


state 162

    (34) if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .

    END             reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    IF              reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    PUTS            reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    RETURN          reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ID              reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    LOOP            reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    FOR             reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    WHILE           reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSE            reduce using rule 34 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)


state 163

    (35) if_statement_loop -> ELSE expression cmd_loop END . IF SEMICOLON

    IF              shift and go to state 167


state 164

    (42) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 168


state 165

    (41) while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 41 (while_statement -> WHILE expression NUMBER_INT LOOP cmd_loop END LOOP SEMICOLON .)


state 166

    (71) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE . SEMICOLON

    SEMICOLON       shift and go to state 169


state 167

    (35) if_statement_loop -> ELSE expression cmd_loop END IF . SEMICOLON

    SEMICOLON       shift and go to state 170


state 168

    (42) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 42 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)


state 169

    (71) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON .

    SEMICOLON       reduce using rule 71 (array -> TYPE ID IS ARRAY LPAREN range RPAREN OF TYPE SEMICOLON .)


state 170

    (35) if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .

    END             reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    IF              reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    PUTS            reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    RETURN          reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    ID              reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    LOOP            reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    FOR             reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    WHILE           reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    ELSIF           reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)
    ELSE            reduce using rule 35 (if_statement_loop -> ELSE expression cmd_loop END IF SEMICOLON .)

