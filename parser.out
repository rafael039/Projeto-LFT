Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> subprogram
Rule 2     program -> subprogram program
Rule 3     subprogram -> FUNCTION ID decl_param IS body
Rule 4     subprogram -> PROCEDURE ID IS decl body
Rule 5     subprogram -> PROCEDURE ID IS body
Rule 6     body -> BEGIN cmd_loop END ID SEMICOLON
Rule 7     decl -> var SEMICOLON decl
Rule 8     decl -> var SEMICOLON
Rule 9     var -> ID COLON type ASSIGN term
Rule 10    var -> ID COLON type
Rule 11    var -> var_loop ID COLON type
Rule 12    var -> array
Rule 13    var_loop -> var_loop ID COMMA
Rule 14    var_loop -> ID COMMA
Rule 15    type -> BOOLEAN
Rule 16    type -> CHARACTER
Rule 17    type -> FLOAT
Rule 18    type -> INTEGER
Rule 19    type -> STRING
Rule 20    decl_param -> LPAREN param RPAREN
Rule 21    decl_param -> LPAREN param RPAREN RETURN type
Rule 22    param -> ID COLON type SEMICOLON param
Rule 23    param -> ID COLON type SEMICOLON
Rule 24    function_call -> ID LPAREN param_pass RPAREN SEMICOLON
Rule 25    function_call -> ID LPAREN RPAREN SEMICOLON
Rule 26    function_call_exp -> ID LPAREN param_pass RPAREN
Rule 27    function_call_exp -> ID LPAREN RPAREN
Rule 28    param_pass -> expression COMMA param_pass
Rule 29    param_pass -> expression
Rule 30    cmd -> if_statement
Rule 31    cmd -> repeat_statement
Rule 32    cmd -> puts
Rule 33    cmd -> return
Rule 34    cmd -> assign
Rule 35    cmd -> function_call
Rule 36    cmd_loop -> cmd_loop cmd
Rule 37    cmd_loop -> cmd
Rule 38    puts -> PUTS LPAREN STR RPAREN SEMICOLON
Rule 39    if_statement -> IF expression THEN cmd_loop if_statement_loop
Rule 40    if_statement_loop -> ELSIF expression cmd_loop if_statement_loop
Rule 41    if_statement_loop -> ELSE cmd_loop END IF SEMICOLON
Rule 42    if_statement_loop -> END IF SEMICOLON
Rule 43    repeat_statement -> loop_statement
Rule 44    repeat_statement -> for_statement
Rule 45    repeat_statement -> while_statement
Rule 46    loop_statement -> LOOP cmd_loop END LOOP SEMICOLON
Rule 47    while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON
Rule 48    for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
Rule 49    range -> NUMBER_INT DOTDOT NUMBER_INT
Rule 50    assign -> ID ASSIGN op_arithmetic SEMICOLON
Rule 51    expression -> expression AND or_exp
Rule 52    expression -> or_exp
Rule 53    or_exp -> or_exp OR comp_exp
Rule 54    or_exp -> comp_exp
Rule 55    comp_exp -> comp_exp comp_op op_arithmetic
Rule 56    comp_exp -> op_arithmetic
Rule 57    comp_op -> GREATERTHAN
Rule 58    comp_op -> GREATERTHANEQUAL
Rule 59    comp_op -> LESSTHAN
Rule 60    comp_op -> LESSTHANEQUAL
Rule 61    comp_op -> NOTEQUAL
Rule 62    comp_op -> EQUAL
Rule 63    op_arithmetic -> op_arithmetic PLUS factor
Rule 64    op_arithmetic -> op_arithmetic MINUS factor
Rule 65    op_arithmetic -> factor
Rule 66    factor -> factor TIMES power
Rule 67    factor -> factor DIVIDE power
Rule 68    factor -> power
Rule 69    power -> power POWER unary
Rule 70    power -> unary
Rule 71    unary -> PLUS term
Rule 72    unary -> MINUS term
Rule 73    unary -> term
Rule 74    term -> ID
Rule 75    term -> function_call_exp
Rule 76    term -> LPAREN expression RPAREN
Rule 77    term -> literal
Rule 78    literal -> CHAR
Rule 79    literal -> NUMBER_FLOAT
Rule 80    literal -> NUMBER_INT
Rule 81    literal -> STR
Rule 82    literal -> TRUE
Rule 83    literal -> FALSE
Rule 84    array -> TYPE ID IS ARRAY LPAREN range RPAREN OF type
Rule 85    return -> RETURN expression SEMICOLON

Terminals, with rules where they appear

AND                  : 51
ARRAY                : 84
ASSIGN               : 9 50
BEGIN                : 6
BOOLEAN              : 15
CHAR                 : 78
CHARACTER            : 16
COLON                : 9 10 11 22 23
COMMA                : 13 14 28
DIVIDE               : 67
DOTDOT               : 49
ELSE                 : 41
ELSIF                : 40
END                  : 6 41 42 46 47 48
EQUAL                : 62
FALSE                : 83
FLOAT                : 17
FOR                  : 48
FUNCTION             : 3
GREATERTHAN          : 57
GREATERTHANEQUAL     : 58
ID                   : 3 4 5 6 9 10 11 13 14 22 23 24 25 26 27 48 50 74 84
IF                   : 39 41 42
IN                   : 48
INTEGER              : 18
IS                   : 3 4 5 84
LESSTHAN             : 59
LESSTHANEQUAL        : 60
LOOP                 : 46 46 47 47 48 48
LPAREN               : 20 21 24 25 26 27 38 76 84
MINUS                : 64 72
NOTEQUAL             : 61
NUMBER_FLOAT         : 79
NUMBER_INT           : 49 49 80
OF                   : 84
OR                   : 53
PLUS                 : 63 71
POWER                : 69
PROCEDURE            : 4 5
PUTS                 : 38
RETURN               : 21 85
RPAREN               : 20 21 24 25 26 27 38 76 84
SEMICOLON            : 6 7 8 22 23 24 25 38 41 42 46 47 48 50 85
STR                  : 38 81
STRING               : 19
THEN                 : 39
TIMES                : 66
TRUE                 : 82
TYPE                 : 84
WHILE                : 47
error                : 

Nonterminals, with rules where they appear

array                : 12
assign               : 34
body                 : 3 4 5
cmd                  : 36 37
cmd_loop             : 6 36 39 40 41 46 47 48
comp_exp             : 53 54 55
comp_op              : 55
decl                 : 4 7
decl_param           : 3
expression           : 28 29 39 40 47 51 76 85
factor               : 63 64 65 66 67
for_statement        : 44
function_call        : 35
function_call_exp    : 75
if_statement         : 30
if_statement_loop    : 39 40
literal              : 77
loop_statement       : 43
op_arithmetic        : 50 55 56 63 64
or_exp               : 51 52 53
param                : 20 21 22
param_pass           : 24 26 28
power                : 66 67 68 69
program              : 2 0
puts                 : 32
range                : 48 84
repeat_statement     : 31
return               : 33
subprogram           : 1 2
term                 : 9 71 72 73
type                 : 9 10 11 21 22 23 84
unary                : 69 70
var                  : 7 8
var_loop             : 11 13
while_statement      : 45

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . subprogram
    (2) program -> . subprogram program
    (3) subprogram -> . FUNCTION ID decl_param IS body
    (4) subprogram -> . PROCEDURE ID IS decl body
    (5) subprogram -> . PROCEDURE ID IS body

    FUNCTION        shift and go to state 3
    PROCEDURE       shift and go to state 4

    program                        shift and go to state 1
    subprogram                     shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> subprogram .
    (2) program -> subprogram . program
    (1) program -> . subprogram
    (2) program -> . subprogram program
    (3) subprogram -> . FUNCTION ID decl_param IS body
    (4) subprogram -> . PROCEDURE ID IS decl body
    (5) subprogram -> . PROCEDURE ID IS body

    $end            reduce using rule 1 (program -> subprogram .)
    FUNCTION        shift and go to state 3
    PROCEDURE       shift and go to state 4

    subprogram                     shift and go to state 2
    program                        shift and go to state 5

state 3

    (3) subprogram -> FUNCTION . ID decl_param IS body

    ID              shift and go to state 6


state 4

    (4) subprogram -> PROCEDURE . ID IS decl body
    (5) subprogram -> PROCEDURE . ID IS body

    ID              shift and go to state 7


state 5

    (2) program -> subprogram program .

    $end            reduce using rule 2 (program -> subprogram program .)


state 6

    (3) subprogram -> FUNCTION ID . decl_param IS body
    (20) decl_param -> . LPAREN param RPAREN
    (21) decl_param -> . LPAREN param RPAREN RETURN type

    LPAREN          shift and go to state 9

    decl_param                     shift and go to state 8

state 7

    (4) subprogram -> PROCEDURE ID . IS decl body
    (5) subprogram -> PROCEDURE ID . IS body

    IS              shift and go to state 10


state 8

    (3) subprogram -> FUNCTION ID decl_param . IS body

    IS              shift and go to state 11


state 9

    (20) decl_param -> LPAREN . param RPAREN
    (21) decl_param -> LPAREN . param RPAREN RETURN type
    (22) param -> . ID COLON type SEMICOLON param
    (23) param -> . ID COLON type SEMICOLON

    ID              shift and go to state 13

    param                          shift and go to state 12

state 10

    (4) subprogram -> PROCEDURE ID IS . decl body
    (5) subprogram -> PROCEDURE ID IS . body
    (7) decl -> . var SEMICOLON decl
    (8) decl -> . var SEMICOLON
    (6) body -> . BEGIN cmd_loop END ID SEMICOLON
    (9) var -> . ID COLON type ASSIGN term
    (10) var -> . ID COLON type
    (11) var -> . var_loop ID COLON type
    (12) var -> . array
    (13) var_loop -> . var_loop ID COMMA
    (14) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF type

    BEGIN           shift and go to state 18
    ID              shift and go to state 14
    TYPE            shift and go to state 21

    decl                           shift and go to state 15
    body                           shift and go to state 16
    var                            shift and go to state 17
    var_loop                       shift and go to state 19
    array                          shift and go to state 20

state 11

    (3) subprogram -> FUNCTION ID decl_param IS . body
    (6) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 18

    body                           shift and go to state 22

state 12

    (20) decl_param -> LPAREN param . RPAREN
    (21) decl_param -> LPAREN param . RPAREN RETURN type

    RPAREN          shift and go to state 23


state 13

    (22) param -> ID . COLON type SEMICOLON param
    (23) param -> ID . COLON type SEMICOLON

    COLON           shift and go to state 24


state 14

    (9) var -> ID . COLON type ASSIGN term
    (10) var -> ID . COLON type
    (14) var_loop -> ID . COMMA

    COLON           shift and go to state 25
    COMMA           shift and go to state 26


state 15

    (4) subprogram -> PROCEDURE ID IS decl . body
    (6) body -> . BEGIN cmd_loop END ID SEMICOLON

    BEGIN           shift and go to state 18

    body                           shift and go to state 27

state 16

    (5) subprogram -> PROCEDURE ID IS body .

    FUNCTION        reduce using rule 5 (subprogram -> PROCEDURE ID IS body .)
    PROCEDURE       reduce using rule 5 (subprogram -> PROCEDURE ID IS body .)
    $end            reduce using rule 5 (subprogram -> PROCEDURE ID IS body .)


state 17

    (7) decl -> var . SEMICOLON decl
    (8) decl -> var . SEMICOLON

    SEMICOLON       shift and go to state 28


state 18

    (6) body -> BEGIN . cmd_loop END ID SEMICOLON
    (36) cmd_loop -> . cmd_loop cmd
    (37) cmd_loop -> . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 29
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 19

    (11) var -> var_loop . ID COLON type
    (13) var_loop -> var_loop . ID COMMA

    ID              shift and go to state 47


state 20

    (12) var -> array .

    SEMICOLON       reduce using rule 12 (var -> array .)


state 21

    (84) array -> TYPE . ID IS ARRAY LPAREN range RPAREN OF type

    ID              shift and go to state 48


state 22

    (3) subprogram -> FUNCTION ID decl_param IS body .

    FUNCTION        reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS body .)
    PROCEDURE       reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS body .)
    $end            reduce using rule 3 (subprogram -> FUNCTION ID decl_param IS body .)


state 23

    (20) decl_param -> LPAREN param RPAREN .
    (21) decl_param -> LPAREN param RPAREN . RETURN type

    IS              reduce using rule 20 (decl_param -> LPAREN param RPAREN .)
    RETURN          shift and go to state 49


state 24

    (22) param -> ID COLON . type SEMICOLON param
    (23) param -> ID COLON . type SEMICOLON
    (15) type -> . BOOLEAN
    (16) type -> . CHARACTER
    (17) type -> . FLOAT
    (18) type -> . INTEGER
    (19) type -> . STRING

    BOOLEAN         shift and go to state 51
    CHARACTER       shift and go to state 52
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55

    type                           shift and go to state 50

state 25

    (9) var -> ID COLON . type ASSIGN term
    (10) var -> ID COLON . type
    (15) type -> . BOOLEAN
    (16) type -> . CHARACTER
    (17) type -> . FLOAT
    (18) type -> . INTEGER
    (19) type -> . STRING

    BOOLEAN         shift and go to state 51
    CHARACTER       shift and go to state 52
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55

    type                           shift and go to state 56

state 26

    (14) var_loop -> ID COMMA .

    ID              reduce using rule 14 (var_loop -> ID COMMA .)


state 27

    (4) subprogram -> PROCEDURE ID IS decl body .

    FUNCTION        reduce using rule 4 (subprogram -> PROCEDURE ID IS decl body .)
    PROCEDURE       reduce using rule 4 (subprogram -> PROCEDURE ID IS decl body .)
    $end            reduce using rule 4 (subprogram -> PROCEDURE ID IS decl body .)


state 28

    (7) decl -> var SEMICOLON . decl
    (8) decl -> var SEMICOLON .
    (7) decl -> . var SEMICOLON decl
    (8) decl -> . var SEMICOLON
    (9) var -> . ID COLON type ASSIGN term
    (10) var -> . ID COLON type
    (11) var -> . var_loop ID COLON type
    (12) var -> . array
    (13) var_loop -> . var_loop ID COMMA
    (14) var_loop -> . ID COMMA
    (84) array -> . TYPE ID IS ARRAY LPAREN range RPAREN OF type

    BEGIN           reduce using rule 8 (decl -> var SEMICOLON .)
    ID              shift and go to state 14
    TYPE            shift and go to state 21

    var                            shift and go to state 17
    decl                           shift and go to state 57
    var_loop                       shift and go to state 19
    array                          shift and go to state 20

state 29

    (6) body -> BEGIN cmd_loop . END ID SEMICOLON
    (36) cmd_loop -> cmd_loop . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 58
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 59
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 30

    (50) assign -> ID . ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> ID . LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> ID . LPAREN RPAREN SEMICOLON

    ASSIGN          shift and go to state 60
    LPAREN          shift and go to state 61


state 31

    (37) cmd_loop -> cmd .

    END             reduce using rule 37 (cmd_loop -> cmd .)
    IF              reduce using rule 37 (cmd_loop -> cmd .)
    PUTS            reduce using rule 37 (cmd_loop -> cmd .)
    RETURN          reduce using rule 37 (cmd_loop -> cmd .)
    ID              reduce using rule 37 (cmd_loop -> cmd .)
    LOOP            reduce using rule 37 (cmd_loop -> cmd .)
    FOR             reduce using rule 37 (cmd_loop -> cmd .)
    WHILE           reduce using rule 37 (cmd_loop -> cmd .)
    ELSIF           reduce using rule 37 (cmd_loop -> cmd .)
    ELSE            reduce using rule 37 (cmd_loop -> cmd .)


state 32

    (30) cmd -> if_statement .

    END             reduce using rule 30 (cmd -> if_statement .)
    IF              reduce using rule 30 (cmd -> if_statement .)
    PUTS            reduce using rule 30 (cmd -> if_statement .)
    RETURN          reduce using rule 30 (cmd -> if_statement .)
    ID              reduce using rule 30 (cmd -> if_statement .)
    LOOP            reduce using rule 30 (cmd -> if_statement .)
    FOR             reduce using rule 30 (cmd -> if_statement .)
    WHILE           reduce using rule 30 (cmd -> if_statement .)
    ELSIF           reduce using rule 30 (cmd -> if_statement .)
    ELSE            reduce using rule 30 (cmd -> if_statement .)


state 33

    (31) cmd -> repeat_statement .

    END             reduce using rule 31 (cmd -> repeat_statement .)
    IF              reduce using rule 31 (cmd -> repeat_statement .)
    PUTS            reduce using rule 31 (cmd -> repeat_statement .)
    RETURN          reduce using rule 31 (cmd -> repeat_statement .)
    ID              reduce using rule 31 (cmd -> repeat_statement .)
    LOOP            reduce using rule 31 (cmd -> repeat_statement .)
    FOR             reduce using rule 31 (cmd -> repeat_statement .)
    WHILE           reduce using rule 31 (cmd -> repeat_statement .)
    ELSIF           reduce using rule 31 (cmd -> repeat_statement .)
    ELSE            reduce using rule 31 (cmd -> repeat_statement .)


state 34

    (32) cmd -> puts .

    END             reduce using rule 32 (cmd -> puts .)
    IF              reduce using rule 32 (cmd -> puts .)
    PUTS            reduce using rule 32 (cmd -> puts .)
    RETURN          reduce using rule 32 (cmd -> puts .)
    ID              reduce using rule 32 (cmd -> puts .)
    LOOP            reduce using rule 32 (cmd -> puts .)
    FOR             reduce using rule 32 (cmd -> puts .)
    WHILE           reduce using rule 32 (cmd -> puts .)
    ELSIF           reduce using rule 32 (cmd -> puts .)
    ELSE            reduce using rule 32 (cmd -> puts .)


state 35

    (33) cmd -> return .

    END             reduce using rule 33 (cmd -> return .)
    IF              reduce using rule 33 (cmd -> return .)
    PUTS            reduce using rule 33 (cmd -> return .)
    RETURN          reduce using rule 33 (cmd -> return .)
    ID              reduce using rule 33 (cmd -> return .)
    LOOP            reduce using rule 33 (cmd -> return .)
    FOR             reduce using rule 33 (cmd -> return .)
    WHILE           reduce using rule 33 (cmd -> return .)
    ELSIF           reduce using rule 33 (cmd -> return .)
    ELSE            reduce using rule 33 (cmd -> return .)


state 36

    (34) cmd -> assign .

    END             reduce using rule 34 (cmd -> assign .)
    IF              reduce using rule 34 (cmd -> assign .)
    PUTS            reduce using rule 34 (cmd -> assign .)
    RETURN          reduce using rule 34 (cmd -> assign .)
    ID              reduce using rule 34 (cmd -> assign .)
    LOOP            reduce using rule 34 (cmd -> assign .)
    FOR             reduce using rule 34 (cmd -> assign .)
    WHILE           reduce using rule 34 (cmd -> assign .)
    ELSIF           reduce using rule 34 (cmd -> assign .)
    ELSE            reduce using rule 34 (cmd -> assign .)


state 37

    (35) cmd -> function_call .

    END             reduce using rule 35 (cmd -> function_call .)
    IF              reduce using rule 35 (cmd -> function_call .)
    PUTS            reduce using rule 35 (cmd -> function_call .)
    RETURN          reduce using rule 35 (cmd -> function_call .)
    ID              reduce using rule 35 (cmd -> function_call .)
    LOOP            reduce using rule 35 (cmd -> function_call .)
    FOR             reduce using rule 35 (cmd -> function_call .)
    WHILE           reduce using rule 35 (cmd -> function_call .)
    ELSIF           reduce using rule 35 (cmd -> function_call .)
    ELSE            reduce using rule 35 (cmd -> function_call .)


state 38

    (39) if_statement -> IF . expression THEN cmd_loop if_statement_loop
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    expression                     shift and go to state 62
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 39

    (43) repeat_statement -> loop_statement .

    END             reduce using rule 43 (repeat_statement -> loop_statement .)
    IF              reduce using rule 43 (repeat_statement -> loop_statement .)
    PUTS            reduce using rule 43 (repeat_statement -> loop_statement .)
    RETURN          reduce using rule 43 (repeat_statement -> loop_statement .)
    ID              reduce using rule 43 (repeat_statement -> loop_statement .)
    LOOP            reduce using rule 43 (repeat_statement -> loop_statement .)
    FOR             reduce using rule 43 (repeat_statement -> loop_statement .)
    WHILE           reduce using rule 43 (repeat_statement -> loop_statement .)
    ELSIF           reduce using rule 43 (repeat_statement -> loop_statement .)
    ELSE            reduce using rule 43 (repeat_statement -> loop_statement .)


state 40

    (44) repeat_statement -> for_statement .

    END             reduce using rule 44 (repeat_statement -> for_statement .)
    IF              reduce using rule 44 (repeat_statement -> for_statement .)
    PUTS            reduce using rule 44 (repeat_statement -> for_statement .)
    RETURN          reduce using rule 44 (repeat_statement -> for_statement .)
    ID              reduce using rule 44 (repeat_statement -> for_statement .)
    LOOP            reduce using rule 44 (repeat_statement -> for_statement .)
    FOR             reduce using rule 44 (repeat_statement -> for_statement .)
    WHILE           reduce using rule 44 (repeat_statement -> for_statement .)
    ELSIF           reduce using rule 44 (repeat_statement -> for_statement .)
    ELSE            reduce using rule 44 (repeat_statement -> for_statement .)


state 41

    (45) repeat_statement -> while_statement .

    END             reduce using rule 45 (repeat_statement -> while_statement .)
    IF              reduce using rule 45 (repeat_statement -> while_statement .)
    PUTS            reduce using rule 45 (repeat_statement -> while_statement .)
    RETURN          reduce using rule 45 (repeat_statement -> while_statement .)
    ID              reduce using rule 45 (repeat_statement -> while_statement .)
    LOOP            reduce using rule 45 (repeat_statement -> while_statement .)
    FOR             reduce using rule 45 (repeat_statement -> while_statement .)
    WHILE           reduce using rule 45 (repeat_statement -> while_statement .)
    ELSIF           reduce using rule 45 (repeat_statement -> while_statement .)
    ELSE            reduce using rule 45 (repeat_statement -> while_statement .)


state 42

    (38) puts -> PUTS . LPAREN STR RPAREN SEMICOLON

    LPAREN          shift and go to state 82


state 43

    (85) return -> RETURN . expression SEMICOLON
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    expression                     shift and go to state 83
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 44

    (46) loop_statement -> LOOP . cmd_loop END LOOP SEMICOLON
    (36) cmd_loop -> . cmd_loop cmd
    (37) cmd_loop -> . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 84
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 45

    (48) for_statement -> FOR . ID IN range LOOP cmd_loop END LOOP SEMICOLON

    ID              shift and go to state 85


state 46

    (47) while_statement -> WHILE . expression LOOP cmd_loop END LOOP SEMICOLON
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    expression                     shift and go to state 86
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 47

    (11) var -> var_loop ID . COLON type
    (13) var_loop -> var_loop ID . COMMA

    COLON           shift and go to state 87
    COMMA           shift and go to state 88


state 48

    (84) array -> TYPE ID . IS ARRAY LPAREN range RPAREN OF type

    IS              shift and go to state 89


state 49

    (21) decl_param -> LPAREN param RPAREN RETURN . type
    (15) type -> . BOOLEAN
    (16) type -> . CHARACTER
    (17) type -> . FLOAT
    (18) type -> . INTEGER
    (19) type -> . STRING

    BOOLEAN         shift and go to state 51
    CHARACTER       shift and go to state 52
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55

    type                           shift and go to state 90

state 50

    (22) param -> ID COLON type . SEMICOLON param
    (23) param -> ID COLON type . SEMICOLON

    SEMICOLON       shift and go to state 91


state 51

    (15) type -> BOOLEAN .

    SEMICOLON       reduce using rule 15 (type -> BOOLEAN .)
    ASSIGN          reduce using rule 15 (type -> BOOLEAN .)
    IS              reduce using rule 15 (type -> BOOLEAN .)


state 52

    (16) type -> CHARACTER .

    SEMICOLON       reduce using rule 16 (type -> CHARACTER .)
    ASSIGN          reduce using rule 16 (type -> CHARACTER .)
    IS              reduce using rule 16 (type -> CHARACTER .)


state 53

    (17) type -> FLOAT .

    SEMICOLON       reduce using rule 17 (type -> FLOAT .)
    ASSIGN          reduce using rule 17 (type -> FLOAT .)
    IS              reduce using rule 17 (type -> FLOAT .)


state 54

    (18) type -> INTEGER .

    SEMICOLON       reduce using rule 18 (type -> INTEGER .)
    ASSIGN          reduce using rule 18 (type -> INTEGER .)
    IS              reduce using rule 18 (type -> INTEGER .)


state 55

    (19) type -> STRING .

    SEMICOLON       reduce using rule 19 (type -> STRING .)
    ASSIGN          reduce using rule 19 (type -> STRING .)
    IS              reduce using rule 19 (type -> STRING .)


state 56

    (9) var -> ID COLON type . ASSIGN term
    (10) var -> ID COLON type .

    ASSIGN          shift and go to state 92
    SEMICOLON       reduce using rule 10 (var -> ID COLON type .)


state 57

    (7) decl -> var SEMICOLON decl .

    BEGIN           reduce using rule 7 (decl -> var SEMICOLON decl .)


state 58

    (6) body -> BEGIN cmd_loop END . ID SEMICOLON

    ID              shift and go to state 93


state 59

    (36) cmd_loop -> cmd_loop cmd .

    END             reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    IF              reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    PUTS            reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    RETURN          reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    ID              reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    LOOP            reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    FOR             reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    WHILE           reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    ELSIF           reduce using rule 36 (cmd_loop -> cmd_loop cmd .)
    ELSE            reduce using rule 36 (cmd_loop -> cmd_loop cmd .)


state 60

    (50) assign -> ID ASSIGN . op_arithmetic SEMICOLON
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    op_arithmetic                  shift and go to state 94
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 61

    (24) function_call -> ID LPAREN . param_pass RPAREN SEMICOLON
    (25) function_call -> ID LPAREN . RPAREN SEMICOLON
    (28) param_pass -> . expression COMMA param_pass
    (29) param_pass -> . expression
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    RPAREN          shift and go to state 96
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    param_pass                     shift and go to state 95
    expression                     shift and go to state 97
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 62

    (39) if_statement -> IF expression . THEN cmd_loop if_statement_loop
    (51) expression -> expression . AND or_exp

    THEN            shift and go to state 98
    AND             shift and go to state 99


state 63

    (52) expression -> or_exp .
    (53) or_exp -> or_exp . OR comp_exp

    THEN            reduce using rule 52 (expression -> or_exp .)
    AND             reduce using rule 52 (expression -> or_exp .)
    SEMICOLON       reduce using rule 52 (expression -> or_exp .)
    LOOP            reduce using rule 52 (expression -> or_exp .)
    COMMA           reduce using rule 52 (expression -> or_exp .)
    RPAREN          reduce using rule 52 (expression -> or_exp .)
    IF              reduce using rule 52 (expression -> or_exp .)
    PUTS            reduce using rule 52 (expression -> or_exp .)
    RETURN          reduce using rule 52 (expression -> or_exp .)
    ID              reduce using rule 52 (expression -> or_exp .)
    FOR             reduce using rule 52 (expression -> or_exp .)
    WHILE           reduce using rule 52 (expression -> or_exp .)
    OR              shift and go to state 100


state 64

    (54) or_exp -> comp_exp .
    (55) comp_exp -> comp_exp . comp_op op_arithmetic
    (57) comp_op -> . GREATERTHAN
    (58) comp_op -> . GREATERTHANEQUAL
    (59) comp_op -> . LESSTHAN
    (60) comp_op -> . LESSTHANEQUAL
    (61) comp_op -> . NOTEQUAL
    (62) comp_op -> . EQUAL

    OR              reduce using rule 54 (or_exp -> comp_exp .)
    THEN            reduce using rule 54 (or_exp -> comp_exp .)
    AND             reduce using rule 54 (or_exp -> comp_exp .)
    SEMICOLON       reduce using rule 54 (or_exp -> comp_exp .)
    LOOP            reduce using rule 54 (or_exp -> comp_exp .)
    COMMA           reduce using rule 54 (or_exp -> comp_exp .)
    RPAREN          reduce using rule 54 (or_exp -> comp_exp .)
    IF              reduce using rule 54 (or_exp -> comp_exp .)
    PUTS            reduce using rule 54 (or_exp -> comp_exp .)
    RETURN          reduce using rule 54 (or_exp -> comp_exp .)
    ID              reduce using rule 54 (or_exp -> comp_exp .)
    FOR             reduce using rule 54 (or_exp -> comp_exp .)
    WHILE           reduce using rule 54 (or_exp -> comp_exp .)
    GREATERTHAN     shift and go to state 102
    GREATERTHANEQUAL shift and go to state 103
    LESSTHAN        shift and go to state 104
    LESSTHANEQUAL   shift and go to state 105
    NOTEQUAL        shift and go to state 106
    EQUAL           shift and go to state 107

    comp_op                        shift and go to state 101

state 65

    (56) comp_exp -> op_arithmetic .
    (63) op_arithmetic -> op_arithmetic . PLUS factor
    (64) op_arithmetic -> op_arithmetic . MINUS factor

    GREATERTHAN     reduce using rule 56 (comp_exp -> op_arithmetic .)
    GREATERTHANEQUAL reduce using rule 56 (comp_exp -> op_arithmetic .)
    LESSTHAN        reduce using rule 56 (comp_exp -> op_arithmetic .)
    LESSTHANEQUAL   reduce using rule 56 (comp_exp -> op_arithmetic .)
    NOTEQUAL        reduce using rule 56 (comp_exp -> op_arithmetic .)
    EQUAL           reduce using rule 56 (comp_exp -> op_arithmetic .)
    OR              reduce using rule 56 (comp_exp -> op_arithmetic .)
    THEN            reduce using rule 56 (comp_exp -> op_arithmetic .)
    AND             reduce using rule 56 (comp_exp -> op_arithmetic .)
    SEMICOLON       reduce using rule 56 (comp_exp -> op_arithmetic .)
    LOOP            reduce using rule 56 (comp_exp -> op_arithmetic .)
    COMMA           reduce using rule 56 (comp_exp -> op_arithmetic .)
    RPAREN          reduce using rule 56 (comp_exp -> op_arithmetic .)
    IF              reduce using rule 56 (comp_exp -> op_arithmetic .)
    PUTS            reduce using rule 56 (comp_exp -> op_arithmetic .)
    RETURN          reduce using rule 56 (comp_exp -> op_arithmetic .)
    ID              reduce using rule 56 (comp_exp -> op_arithmetic .)
    FOR             reduce using rule 56 (comp_exp -> op_arithmetic .)
    WHILE           reduce using rule 56 (comp_exp -> op_arithmetic .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109


state 66

    (71) unary -> PLUS . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    term                           shift and go to state 110
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 67

    (65) op_arithmetic -> factor .
    (66) factor -> factor . TIMES power
    (67) factor -> factor . DIVIDE power

    PLUS            reduce using rule 65 (op_arithmetic -> factor .)
    MINUS           reduce using rule 65 (op_arithmetic -> factor .)
    GREATERTHAN     reduce using rule 65 (op_arithmetic -> factor .)
    GREATERTHANEQUAL reduce using rule 65 (op_arithmetic -> factor .)
    LESSTHAN        reduce using rule 65 (op_arithmetic -> factor .)
    LESSTHANEQUAL   reduce using rule 65 (op_arithmetic -> factor .)
    NOTEQUAL        reduce using rule 65 (op_arithmetic -> factor .)
    EQUAL           reduce using rule 65 (op_arithmetic -> factor .)
    OR              reduce using rule 65 (op_arithmetic -> factor .)
    THEN            reduce using rule 65 (op_arithmetic -> factor .)
    AND             reduce using rule 65 (op_arithmetic -> factor .)
    SEMICOLON       reduce using rule 65 (op_arithmetic -> factor .)
    LOOP            reduce using rule 65 (op_arithmetic -> factor .)
    COMMA           reduce using rule 65 (op_arithmetic -> factor .)
    RPAREN          reduce using rule 65 (op_arithmetic -> factor .)
    IF              reduce using rule 65 (op_arithmetic -> factor .)
    PUTS            reduce using rule 65 (op_arithmetic -> factor .)
    RETURN          reduce using rule 65 (op_arithmetic -> factor .)
    ID              reduce using rule 65 (op_arithmetic -> factor .)
    FOR             reduce using rule 65 (op_arithmetic -> factor .)
    WHILE           reduce using rule 65 (op_arithmetic -> factor .)
    TIMES           shift and go to state 111
    DIVIDE          shift and go to state 112


state 68

    (72) unary -> MINUS . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    term                           shift and go to state 113
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 69

    (68) factor -> power .
    (69) power -> power . POWER unary

    TIMES           reduce using rule 68 (factor -> power .)
    DIVIDE          reduce using rule 68 (factor -> power .)
    PLUS            reduce using rule 68 (factor -> power .)
    MINUS           reduce using rule 68 (factor -> power .)
    GREATERTHAN     reduce using rule 68 (factor -> power .)
    GREATERTHANEQUAL reduce using rule 68 (factor -> power .)
    LESSTHAN        reduce using rule 68 (factor -> power .)
    LESSTHANEQUAL   reduce using rule 68 (factor -> power .)
    NOTEQUAL        reduce using rule 68 (factor -> power .)
    EQUAL           reduce using rule 68 (factor -> power .)
    OR              reduce using rule 68 (factor -> power .)
    THEN            reduce using rule 68 (factor -> power .)
    AND             reduce using rule 68 (factor -> power .)
    SEMICOLON       reduce using rule 68 (factor -> power .)
    LOOP            reduce using rule 68 (factor -> power .)
    COMMA           reduce using rule 68 (factor -> power .)
    RPAREN          reduce using rule 68 (factor -> power .)
    IF              reduce using rule 68 (factor -> power .)
    PUTS            reduce using rule 68 (factor -> power .)
    RETURN          reduce using rule 68 (factor -> power .)
    ID              reduce using rule 68 (factor -> power .)
    FOR             reduce using rule 68 (factor -> power .)
    WHILE           reduce using rule 68 (factor -> power .)
    POWER           shift and go to state 114


state 70

    (70) power -> unary .

    POWER           reduce using rule 70 (power -> unary .)
    TIMES           reduce using rule 70 (power -> unary .)
    DIVIDE          reduce using rule 70 (power -> unary .)
    PLUS            reduce using rule 70 (power -> unary .)
    MINUS           reduce using rule 70 (power -> unary .)
    GREATERTHAN     reduce using rule 70 (power -> unary .)
    GREATERTHANEQUAL reduce using rule 70 (power -> unary .)
    LESSTHAN        reduce using rule 70 (power -> unary .)
    LESSTHANEQUAL   reduce using rule 70 (power -> unary .)
    NOTEQUAL        reduce using rule 70 (power -> unary .)
    EQUAL           reduce using rule 70 (power -> unary .)
    OR              reduce using rule 70 (power -> unary .)
    THEN            reduce using rule 70 (power -> unary .)
    AND             reduce using rule 70 (power -> unary .)
    SEMICOLON       reduce using rule 70 (power -> unary .)
    LOOP            reduce using rule 70 (power -> unary .)
    COMMA           reduce using rule 70 (power -> unary .)
    RPAREN          reduce using rule 70 (power -> unary .)
    IF              reduce using rule 70 (power -> unary .)
    PUTS            reduce using rule 70 (power -> unary .)
    RETURN          reduce using rule 70 (power -> unary .)
    ID              reduce using rule 70 (power -> unary .)
    FOR             reduce using rule 70 (power -> unary .)
    WHILE           reduce using rule 70 (power -> unary .)


state 71

    (73) unary -> term .

    POWER           reduce using rule 73 (unary -> term .)
    TIMES           reduce using rule 73 (unary -> term .)
    DIVIDE          reduce using rule 73 (unary -> term .)
    PLUS            reduce using rule 73 (unary -> term .)
    MINUS           reduce using rule 73 (unary -> term .)
    GREATERTHAN     reduce using rule 73 (unary -> term .)
    GREATERTHANEQUAL reduce using rule 73 (unary -> term .)
    LESSTHAN        reduce using rule 73 (unary -> term .)
    LESSTHANEQUAL   reduce using rule 73 (unary -> term .)
    NOTEQUAL        reduce using rule 73 (unary -> term .)
    EQUAL           reduce using rule 73 (unary -> term .)
    OR              reduce using rule 73 (unary -> term .)
    THEN            reduce using rule 73 (unary -> term .)
    AND             reduce using rule 73 (unary -> term .)
    SEMICOLON       reduce using rule 73 (unary -> term .)
    LOOP            reduce using rule 73 (unary -> term .)
    COMMA           reduce using rule 73 (unary -> term .)
    RPAREN          reduce using rule 73 (unary -> term .)
    IF              reduce using rule 73 (unary -> term .)
    PUTS            reduce using rule 73 (unary -> term .)
    RETURN          reduce using rule 73 (unary -> term .)
    ID              reduce using rule 73 (unary -> term .)
    FOR             reduce using rule 73 (unary -> term .)
    WHILE           reduce using rule 73 (unary -> term .)


state 72

    (74) term -> ID .
    (26) function_call_exp -> ID . LPAREN param_pass RPAREN
    (27) function_call_exp -> ID . LPAREN RPAREN

    POWER           reduce using rule 74 (term -> ID .)
    TIMES           reduce using rule 74 (term -> ID .)
    DIVIDE          reduce using rule 74 (term -> ID .)
    PLUS            reduce using rule 74 (term -> ID .)
    MINUS           reduce using rule 74 (term -> ID .)
    GREATERTHAN     reduce using rule 74 (term -> ID .)
    GREATERTHANEQUAL reduce using rule 74 (term -> ID .)
    LESSTHAN        reduce using rule 74 (term -> ID .)
    LESSTHANEQUAL   reduce using rule 74 (term -> ID .)
    NOTEQUAL        reduce using rule 74 (term -> ID .)
    EQUAL           reduce using rule 74 (term -> ID .)
    OR              reduce using rule 74 (term -> ID .)
    THEN            reduce using rule 74 (term -> ID .)
    AND             reduce using rule 74 (term -> ID .)
    SEMICOLON       reduce using rule 74 (term -> ID .)
    LOOP            reduce using rule 74 (term -> ID .)
    COMMA           reduce using rule 74 (term -> ID .)
    RPAREN          reduce using rule 74 (term -> ID .)
    IF              reduce using rule 74 (term -> ID .)
    PUTS            reduce using rule 74 (term -> ID .)
    RETURN          reduce using rule 74 (term -> ID .)
    ID              reduce using rule 74 (term -> ID .)
    FOR             reduce using rule 74 (term -> ID .)
    WHILE           reduce using rule 74 (term -> ID .)
    LPAREN          shift and go to state 115


state 73

    (75) term -> function_call_exp .

    POWER           reduce using rule 75 (term -> function_call_exp .)
    TIMES           reduce using rule 75 (term -> function_call_exp .)
    DIVIDE          reduce using rule 75 (term -> function_call_exp .)
    PLUS            reduce using rule 75 (term -> function_call_exp .)
    MINUS           reduce using rule 75 (term -> function_call_exp .)
    GREATERTHAN     reduce using rule 75 (term -> function_call_exp .)
    GREATERTHANEQUAL reduce using rule 75 (term -> function_call_exp .)
    LESSTHAN        reduce using rule 75 (term -> function_call_exp .)
    LESSTHANEQUAL   reduce using rule 75 (term -> function_call_exp .)
    NOTEQUAL        reduce using rule 75 (term -> function_call_exp .)
    EQUAL           reduce using rule 75 (term -> function_call_exp .)
    OR              reduce using rule 75 (term -> function_call_exp .)
    THEN            reduce using rule 75 (term -> function_call_exp .)
    AND             reduce using rule 75 (term -> function_call_exp .)
    SEMICOLON       reduce using rule 75 (term -> function_call_exp .)
    LOOP            reduce using rule 75 (term -> function_call_exp .)
    COMMA           reduce using rule 75 (term -> function_call_exp .)
    RPAREN          reduce using rule 75 (term -> function_call_exp .)
    IF              reduce using rule 75 (term -> function_call_exp .)
    PUTS            reduce using rule 75 (term -> function_call_exp .)
    RETURN          reduce using rule 75 (term -> function_call_exp .)
    ID              reduce using rule 75 (term -> function_call_exp .)
    FOR             reduce using rule 75 (term -> function_call_exp .)
    WHILE           reduce using rule 75 (term -> function_call_exp .)


state 74

    (76) term -> LPAREN . expression RPAREN
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    expression                     shift and go to state 116
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 75

    (77) term -> literal .

    POWER           reduce using rule 77 (term -> literal .)
    TIMES           reduce using rule 77 (term -> literal .)
    DIVIDE          reduce using rule 77 (term -> literal .)
    PLUS            reduce using rule 77 (term -> literal .)
    MINUS           reduce using rule 77 (term -> literal .)
    GREATERTHAN     reduce using rule 77 (term -> literal .)
    GREATERTHANEQUAL reduce using rule 77 (term -> literal .)
    LESSTHAN        reduce using rule 77 (term -> literal .)
    LESSTHANEQUAL   reduce using rule 77 (term -> literal .)
    NOTEQUAL        reduce using rule 77 (term -> literal .)
    EQUAL           reduce using rule 77 (term -> literal .)
    OR              reduce using rule 77 (term -> literal .)
    THEN            reduce using rule 77 (term -> literal .)
    AND             reduce using rule 77 (term -> literal .)
    SEMICOLON       reduce using rule 77 (term -> literal .)
    LOOP            reduce using rule 77 (term -> literal .)
    COMMA           reduce using rule 77 (term -> literal .)
    RPAREN          reduce using rule 77 (term -> literal .)
    IF              reduce using rule 77 (term -> literal .)
    PUTS            reduce using rule 77 (term -> literal .)
    RETURN          reduce using rule 77 (term -> literal .)
    ID              reduce using rule 77 (term -> literal .)
    FOR             reduce using rule 77 (term -> literal .)
    WHILE           reduce using rule 77 (term -> literal .)


state 76

    (78) literal -> CHAR .

    POWER           reduce using rule 78 (literal -> CHAR .)
    TIMES           reduce using rule 78 (literal -> CHAR .)
    DIVIDE          reduce using rule 78 (literal -> CHAR .)
    PLUS            reduce using rule 78 (literal -> CHAR .)
    MINUS           reduce using rule 78 (literal -> CHAR .)
    GREATERTHAN     reduce using rule 78 (literal -> CHAR .)
    GREATERTHANEQUAL reduce using rule 78 (literal -> CHAR .)
    LESSTHAN        reduce using rule 78 (literal -> CHAR .)
    LESSTHANEQUAL   reduce using rule 78 (literal -> CHAR .)
    NOTEQUAL        reduce using rule 78 (literal -> CHAR .)
    EQUAL           reduce using rule 78 (literal -> CHAR .)
    OR              reduce using rule 78 (literal -> CHAR .)
    THEN            reduce using rule 78 (literal -> CHAR .)
    AND             reduce using rule 78 (literal -> CHAR .)
    SEMICOLON       reduce using rule 78 (literal -> CHAR .)
    LOOP            reduce using rule 78 (literal -> CHAR .)
    COMMA           reduce using rule 78 (literal -> CHAR .)
    RPAREN          reduce using rule 78 (literal -> CHAR .)
    IF              reduce using rule 78 (literal -> CHAR .)
    PUTS            reduce using rule 78 (literal -> CHAR .)
    RETURN          reduce using rule 78 (literal -> CHAR .)
    ID              reduce using rule 78 (literal -> CHAR .)
    FOR             reduce using rule 78 (literal -> CHAR .)
    WHILE           reduce using rule 78 (literal -> CHAR .)


state 77

    (79) literal -> NUMBER_FLOAT .

    POWER           reduce using rule 79 (literal -> NUMBER_FLOAT .)
    TIMES           reduce using rule 79 (literal -> NUMBER_FLOAT .)
    DIVIDE          reduce using rule 79 (literal -> NUMBER_FLOAT .)
    PLUS            reduce using rule 79 (literal -> NUMBER_FLOAT .)
    MINUS           reduce using rule 79 (literal -> NUMBER_FLOAT .)
    GREATERTHAN     reduce using rule 79 (literal -> NUMBER_FLOAT .)
    GREATERTHANEQUAL reduce using rule 79 (literal -> NUMBER_FLOAT .)
    LESSTHAN        reduce using rule 79 (literal -> NUMBER_FLOAT .)
    LESSTHANEQUAL   reduce using rule 79 (literal -> NUMBER_FLOAT .)
    NOTEQUAL        reduce using rule 79 (literal -> NUMBER_FLOAT .)
    EQUAL           reduce using rule 79 (literal -> NUMBER_FLOAT .)
    OR              reduce using rule 79 (literal -> NUMBER_FLOAT .)
    THEN            reduce using rule 79 (literal -> NUMBER_FLOAT .)
    AND             reduce using rule 79 (literal -> NUMBER_FLOAT .)
    SEMICOLON       reduce using rule 79 (literal -> NUMBER_FLOAT .)
    LOOP            reduce using rule 79 (literal -> NUMBER_FLOAT .)
    COMMA           reduce using rule 79 (literal -> NUMBER_FLOAT .)
    RPAREN          reduce using rule 79 (literal -> NUMBER_FLOAT .)
    IF              reduce using rule 79 (literal -> NUMBER_FLOAT .)
    PUTS            reduce using rule 79 (literal -> NUMBER_FLOAT .)
    RETURN          reduce using rule 79 (literal -> NUMBER_FLOAT .)
    ID              reduce using rule 79 (literal -> NUMBER_FLOAT .)
    FOR             reduce using rule 79 (literal -> NUMBER_FLOAT .)
    WHILE           reduce using rule 79 (literal -> NUMBER_FLOAT .)


state 78

    (80) literal -> NUMBER_INT .

    POWER           reduce using rule 80 (literal -> NUMBER_INT .)
    TIMES           reduce using rule 80 (literal -> NUMBER_INT .)
    DIVIDE          reduce using rule 80 (literal -> NUMBER_INT .)
    PLUS            reduce using rule 80 (literal -> NUMBER_INT .)
    MINUS           reduce using rule 80 (literal -> NUMBER_INT .)
    GREATERTHAN     reduce using rule 80 (literal -> NUMBER_INT .)
    GREATERTHANEQUAL reduce using rule 80 (literal -> NUMBER_INT .)
    LESSTHAN        reduce using rule 80 (literal -> NUMBER_INT .)
    LESSTHANEQUAL   reduce using rule 80 (literal -> NUMBER_INT .)
    NOTEQUAL        reduce using rule 80 (literal -> NUMBER_INT .)
    EQUAL           reduce using rule 80 (literal -> NUMBER_INT .)
    OR              reduce using rule 80 (literal -> NUMBER_INT .)
    THEN            reduce using rule 80 (literal -> NUMBER_INT .)
    AND             reduce using rule 80 (literal -> NUMBER_INT .)
    SEMICOLON       reduce using rule 80 (literal -> NUMBER_INT .)
    LOOP            reduce using rule 80 (literal -> NUMBER_INT .)
    COMMA           reduce using rule 80 (literal -> NUMBER_INT .)
    RPAREN          reduce using rule 80 (literal -> NUMBER_INT .)
    IF              reduce using rule 80 (literal -> NUMBER_INT .)
    PUTS            reduce using rule 80 (literal -> NUMBER_INT .)
    RETURN          reduce using rule 80 (literal -> NUMBER_INT .)
    ID              reduce using rule 80 (literal -> NUMBER_INT .)
    FOR             reduce using rule 80 (literal -> NUMBER_INT .)
    WHILE           reduce using rule 80 (literal -> NUMBER_INT .)


state 79

    (81) literal -> STR .

    POWER           reduce using rule 81 (literal -> STR .)
    TIMES           reduce using rule 81 (literal -> STR .)
    DIVIDE          reduce using rule 81 (literal -> STR .)
    PLUS            reduce using rule 81 (literal -> STR .)
    MINUS           reduce using rule 81 (literal -> STR .)
    GREATERTHAN     reduce using rule 81 (literal -> STR .)
    GREATERTHANEQUAL reduce using rule 81 (literal -> STR .)
    LESSTHAN        reduce using rule 81 (literal -> STR .)
    LESSTHANEQUAL   reduce using rule 81 (literal -> STR .)
    NOTEQUAL        reduce using rule 81 (literal -> STR .)
    EQUAL           reduce using rule 81 (literal -> STR .)
    OR              reduce using rule 81 (literal -> STR .)
    THEN            reduce using rule 81 (literal -> STR .)
    AND             reduce using rule 81 (literal -> STR .)
    SEMICOLON       reduce using rule 81 (literal -> STR .)
    LOOP            reduce using rule 81 (literal -> STR .)
    COMMA           reduce using rule 81 (literal -> STR .)
    RPAREN          reduce using rule 81 (literal -> STR .)
    IF              reduce using rule 81 (literal -> STR .)
    PUTS            reduce using rule 81 (literal -> STR .)
    RETURN          reduce using rule 81 (literal -> STR .)
    ID              reduce using rule 81 (literal -> STR .)
    FOR             reduce using rule 81 (literal -> STR .)
    WHILE           reduce using rule 81 (literal -> STR .)


state 80

    (82) literal -> TRUE .

    POWER           reduce using rule 82 (literal -> TRUE .)
    TIMES           reduce using rule 82 (literal -> TRUE .)
    DIVIDE          reduce using rule 82 (literal -> TRUE .)
    PLUS            reduce using rule 82 (literal -> TRUE .)
    MINUS           reduce using rule 82 (literal -> TRUE .)
    GREATERTHAN     reduce using rule 82 (literal -> TRUE .)
    GREATERTHANEQUAL reduce using rule 82 (literal -> TRUE .)
    LESSTHAN        reduce using rule 82 (literal -> TRUE .)
    LESSTHANEQUAL   reduce using rule 82 (literal -> TRUE .)
    NOTEQUAL        reduce using rule 82 (literal -> TRUE .)
    EQUAL           reduce using rule 82 (literal -> TRUE .)
    OR              reduce using rule 82 (literal -> TRUE .)
    THEN            reduce using rule 82 (literal -> TRUE .)
    AND             reduce using rule 82 (literal -> TRUE .)
    SEMICOLON       reduce using rule 82 (literal -> TRUE .)
    LOOP            reduce using rule 82 (literal -> TRUE .)
    COMMA           reduce using rule 82 (literal -> TRUE .)
    RPAREN          reduce using rule 82 (literal -> TRUE .)
    IF              reduce using rule 82 (literal -> TRUE .)
    PUTS            reduce using rule 82 (literal -> TRUE .)
    RETURN          reduce using rule 82 (literal -> TRUE .)
    ID              reduce using rule 82 (literal -> TRUE .)
    FOR             reduce using rule 82 (literal -> TRUE .)
    WHILE           reduce using rule 82 (literal -> TRUE .)


state 81

    (83) literal -> FALSE .

    POWER           reduce using rule 83 (literal -> FALSE .)
    TIMES           reduce using rule 83 (literal -> FALSE .)
    DIVIDE          reduce using rule 83 (literal -> FALSE .)
    PLUS            reduce using rule 83 (literal -> FALSE .)
    MINUS           reduce using rule 83 (literal -> FALSE .)
    GREATERTHAN     reduce using rule 83 (literal -> FALSE .)
    GREATERTHANEQUAL reduce using rule 83 (literal -> FALSE .)
    LESSTHAN        reduce using rule 83 (literal -> FALSE .)
    LESSTHANEQUAL   reduce using rule 83 (literal -> FALSE .)
    NOTEQUAL        reduce using rule 83 (literal -> FALSE .)
    EQUAL           reduce using rule 83 (literal -> FALSE .)
    OR              reduce using rule 83 (literal -> FALSE .)
    THEN            reduce using rule 83 (literal -> FALSE .)
    AND             reduce using rule 83 (literal -> FALSE .)
    SEMICOLON       reduce using rule 83 (literal -> FALSE .)
    LOOP            reduce using rule 83 (literal -> FALSE .)
    COMMA           reduce using rule 83 (literal -> FALSE .)
    RPAREN          reduce using rule 83 (literal -> FALSE .)
    IF              reduce using rule 83 (literal -> FALSE .)
    PUTS            reduce using rule 83 (literal -> FALSE .)
    RETURN          reduce using rule 83 (literal -> FALSE .)
    ID              reduce using rule 83 (literal -> FALSE .)
    FOR             reduce using rule 83 (literal -> FALSE .)
    WHILE           reduce using rule 83 (literal -> FALSE .)


state 82

    (38) puts -> PUTS LPAREN . STR RPAREN SEMICOLON

    STR             shift and go to state 117


state 83

    (85) return -> RETURN expression . SEMICOLON
    (51) expression -> expression . AND or_exp

    SEMICOLON       shift and go to state 118
    AND             shift and go to state 99


state 84

    (46) loop_statement -> LOOP cmd_loop . END LOOP SEMICOLON
    (36) cmd_loop -> cmd_loop . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 119
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 59
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 85

    (48) for_statement -> FOR ID . IN range LOOP cmd_loop END LOOP SEMICOLON

    IN              shift and go to state 120


state 86

    (47) while_statement -> WHILE expression . LOOP cmd_loop END LOOP SEMICOLON
    (51) expression -> expression . AND or_exp

    LOOP            shift and go to state 121
    AND             shift and go to state 99


state 87

    (11) var -> var_loop ID COLON . type
    (15) type -> . BOOLEAN
    (16) type -> . CHARACTER
    (17) type -> . FLOAT
    (18) type -> . INTEGER
    (19) type -> . STRING

    BOOLEAN         shift and go to state 51
    CHARACTER       shift and go to state 52
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55

    type                           shift and go to state 122

state 88

    (13) var_loop -> var_loop ID COMMA .

    ID              reduce using rule 13 (var_loop -> var_loop ID COMMA .)


state 89

    (84) array -> TYPE ID IS . ARRAY LPAREN range RPAREN OF type

    ARRAY           shift and go to state 123


state 90

    (21) decl_param -> LPAREN param RPAREN RETURN type .

    IS              reduce using rule 21 (decl_param -> LPAREN param RPAREN RETURN type .)


state 91

    (22) param -> ID COLON type SEMICOLON . param
    (23) param -> ID COLON type SEMICOLON .
    (22) param -> . ID COLON type SEMICOLON param
    (23) param -> . ID COLON type SEMICOLON

    RPAREN          reduce using rule 23 (param -> ID COLON type SEMICOLON .)
    ID              shift and go to state 13

    param                          shift and go to state 124

state 92

    (9) var -> ID COLON type ASSIGN . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    term                           shift and go to state 125
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 93

    (6) body -> BEGIN cmd_loop END ID . SEMICOLON

    SEMICOLON       shift and go to state 126


state 94

    (50) assign -> ID ASSIGN op_arithmetic . SEMICOLON
    (63) op_arithmetic -> op_arithmetic . PLUS factor
    (64) op_arithmetic -> op_arithmetic . MINUS factor

    SEMICOLON       shift and go to state 127
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109


state 95

    (24) function_call -> ID LPAREN param_pass . RPAREN SEMICOLON

    RPAREN          shift and go to state 128


state 96

    (25) function_call -> ID LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 129


state 97

    (28) param_pass -> expression . COMMA param_pass
    (29) param_pass -> expression .
    (51) expression -> expression . AND or_exp

    COMMA           shift and go to state 130
    RPAREN          reduce using rule 29 (param_pass -> expression .)
    AND             shift and go to state 99


state 98

    (39) if_statement -> IF expression THEN . cmd_loop if_statement_loop
    (36) cmd_loop -> . cmd_loop cmd
    (37) cmd_loop -> . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 131
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 99

    (51) expression -> expression AND . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    or_exp                         shift and go to state 132
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 100

    (53) or_exp -> or_exp OR . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    comp_exp                       shift and go to state 133
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 101

    (55) comp_exp -> comp_exp comp_op . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    op_arithmetic                  shift and go to state 134
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 102

    (57) comp_op -> GREATERTHAN .

    PLUS            reduce using rule 57 (comp_op -> GREATERTHAN .)
    MINUS           reduce using rule 57 (comp_op -> GREATERTHAN .)
    ID              reduce using rule 57 (comp_op -> GREATERTHAN .)
    LPAREN          reduce using rule 57 (comp_op -> GREATERTHAN .)
    CHAR            reduce using rule 57 (comp_op -> GREATERTHAN .)
    NUMBER_FLOAT    reduce using rule 57 (comp_op -> GREATERTHAN .)
    NUMBER_INT      reduce using rule 57 (comp_op -> GREATERTHAN .)
    STR             reduce using rule 57 (comp_op -> GREATERTHAN .)
    TRUE            reduce using rule 57 (comp_op -> GREATERTHAN .)
    FALSE           reduce using rule 57 (comp_op -> GREATERTHAN .)


state 103

    (58) comp_op -> GREATERTHANEQUAL .

    PLUS            reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    MINUS           reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    ID              reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    LPAREN          reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    CHAR            reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    NUMBER_FLOAT    reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    NUMBER_INT      reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    STR             reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    TRUE            reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)
    FALSE           reduce using rule 58 (comp_op -> GREATERTHANEQUAL .)


state 104

    (59) comp_op -> LESSTHAN .

    PLUS            reduce using rule 59 (comp_op -> LESSTHAN .)
    MINUS           reduce using rule 59 (comp_op -> LESSTHAN .)
    ID              reduce using rule 59 (comp_op -> LESSTHAN .)
    LPAREN          reduce using rule 59 (comp_op -> LESSTHAN .)
    CHAR            reduce using rule 59 (comp_op -> LESSTHAN .)
    NUMBER_FLOAT    reduce using rule 59 (comp_op -> LESSTHAN .)
    NUMBER_INT      reduce using rule 59 (comp_op -> LESSTHAN .)
    STR             reduce using rule 59 (comp_op -> LESSTHAN .)
    TRUE            reduce using rule 59 (comp_op -> LESSTHAN .)
    FALSE           reduce using rule 59 (comp_op -> LESSTHAN .)


state 105

    (60) comp_op -> LESSTHANEQUAL .

    PLUS            reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    MINUS           reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    ID              reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    LPAREN          reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    CHAR            reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    NUMBER_FLOAT    reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    NUMBER_INT      reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    STR             reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    TRUE            reduce using rule 60 (comp_op -> LESSTHANEQUAL .)
    FALSE           reduce using rule 60 (comp_op -> LESSTHANEQUAL .)


state 106

    (61) comp_op -> NOTEQUAL .

    PLUS            reduce using rule 61 (comp_op -> NOTEQUAL .)
    MINUS           reduce using rule 61 (comp_op -> NOTEQUAL .)
    ID              reduce using rule 61 (comp_op -> NOTEQUAL .)
    LPAREN          reduce using rule 61 (comp_op -> NOTEQUAL .)
    CHAR            reduce using rule 61 (comp_op -> NOTEQUAL .)
    NUMBER_FLOAT    reduce using rule 61 (comp_op -> NOTEQUAL .)
    NUMBER_INT      reduce using rule 61 (comp_op -> NOTEQUAL .)
    STR             reduce using rule 61 (comp_op -> NOTEQUAL .)
    TRUE            reduce using rule 61 (comp_op -> NOTEQUAL .)
    FALSE           reduce using rule 61 (comp_op -> NOTEQUAL .)


state 107

    (62) comp_op -> EQUAL .

    PLUS            reduce using rule 62 (comp_op -> EQUAL .)
    MINUS           reduce using rule 62 (comp_op -> EQUAL .)
    ID              reduce using rule 62 (comp_op -> EQUAL .)
    LPAREN          reduce using rule 62 (comp_op -> EQUAL .)
    CHAR            reduce using rule 62 (comp_op -> EQUAL .)
    NUMBER_FLOAT    reduce using rule 62 (comp_op -> EQUAL .)
    NUMBER_INT      reduce using rule 62 (comp_op -> EQUAL .)
    STR             reduce using rule 62 (comp_op -> EQUAL .)
    TRUE            reduce using rule 62 (comp_op -> EQUAL .)
    FALSE           reduce using rule 62 (comp_op -> EQUAL .)


state 108

    (63) op_arithmetic -> op_arithmetic PLUS . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    factor                         shift and go to state 135
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 109

    (64) op_arithmetic -> op_arithmetic MINUS . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    factor                         shift and go to state 136
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 110

    (71) unary -> PLUS term .

    POWER           reduce using rule 71 (unary -> PLUS term .)
    TIMES           reduce using rule 71 (unary -> PLUS term .)
    DIVIDE          reduce using rule 71 (unary -> PLUS term .)
    PLUS            reduce using rule 71 (unary -> PLUS term .)
    MINUS           reduce using rule 71 (unary -> PLUS term .)
    GREATERTHAN     reduce using rule 71 (unary -> PLUS term .)
    GREATERTHANEQUAL reduce using rule 71 (unary -> PLUS term .)
    LESSTHAN        reduce using rule 71 (unary -> PLUS term .)
    LESSTHANEQUAL   reduce using rule 71 (unary -> PLUS term .)
    NOTEQUAL        reduce using rule 71 (unary -> PLUS term .)
    EQUAL           reduce using rule 71 (unary -> PLUS term .)
    OR              reduce using rule 71 (unary -> PLUS term .)
    THEN            reduce using rule 71 (unary -> PLUS term .)
    AND             reduce using rule 71 (unary -> PLUS term .)
    SEMICOLON       reduce using rule 71 (unary -> PLUS term .)
    LOOP            reduce using rule 71 (unary -> PLUS term .)
    COMMA           reduce using rule 71 (unary -> PLUS term .)
    RPAREN          reduce using rule 71 (unary -> PLUS term .)
    IF              reduce using rule 71 (unary -> PLUS term .)
    PUTS            reduce using rule 71 (unary -> PLUS term .)
    RETURN          reduce using rule 71 (unary -> PLUS term .)
    ID              reduce using rule 71 (unary -> PLUS term .)
    FOR             reduce using rule 71 (unary -> PLUS term .)
    WHILE           reduce using rule 71 (unary -> PLUS term .)


state 111

    (66) factor -> factor TIMES . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    power                          shift and go to state 137
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 112

    (67) factor -> factor DIVIDE . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    power                          shift and go to state 138
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 113

    (72) unary -> MINUS term .

    POWER           reduce using rule 72 (unary -> MINUS term .)
    TIMES           reduce using rule 72 (unary -> MINUS term .)
    DIVIDE          reduce using rule 72 (unary -> MINUS term .)
    PLUS            reduce using rule 72 (unary -> MINUS term .)
    MINUS           reduce using rule 72 (unary -> MINUS term .)
    GREATERTHAN     reduce using rule 72 (unary -> MINUS term .)
    GREATERTHANEQUAL reduce using rule 72 (unary -> MINUS term .)
    LESSTHAN        reduce using rule 72 (unary -> MINUS term .)
    LESSTHANEQUAL   reduce using rule 72 (unary -> MINUS term .)
    NOTEQUAL        reduce using rule 72 (unary -> MINUS term .)
    EQUAL           reduce using rule 72 (unary -> MINUS term .)
    OR              reduce using rule 72 (unary -> MINUS term .)
    THEN            reduce using rule 72 (unary -> MINUS term .)
    AND             reduce using rule 72 (unary -> MINUS term .)
    SEMICOLON       reduce using rule 72 (unary -> MINUS term .)
    LOOP            reduce using rule 72 (unary -> MINUS term .)
    COMMA           reduce using rule 72 (unary -> MINUS term .)
    RPAREN          reduce using rule 72 (unary -> MINUS term .)
    IF              reduce using rule 72 (unary -> MINUS term .)
    PUTS            reduce using rule 72 (unary -> MINUS term .)
    RETURN          reduce using rule 72 (unary -> MINUS term .)
    ID              reduce using rule 72 (unary -> MINUS term .)
    FOR             reduce using rule 72 (unary -> MINUS term .)
    WHILE           reduce using rule 72 (unary -> MINUS term .)


state 114

    (69) power -> power POWER . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    unary                          shift and go to state 139
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 115

    (26) function_call_exp -> ID LPAREN . param_pass RPAREN
    (27) function_call_exp -> ID LPAREN . RPAREN
    (28) param_pass -> . expression COMMA param_pass
    (29) param_pass -> . expression
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    RPAREN          shift and go to state 141
    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    param_pass                     shift and go to state 140
    expression                     shift and go to state 97
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 116

    (76) term -> LPAREN expression . RPAREN
    (51) expression -> expression . AND or_exp

    RPAREN          shift and go to state 142
    AND             shift and go to state 99


state 117

    (38) puts -> PUTS LPAREN STR . RPAREN SEMICOLON

    RPAREN          shift and go to state 143


state 118

    (85) return -> RETURN expression SEMICOLON .

    END             reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    IF              reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    PUTS            reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    ID              reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    LOOP            reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    ELSIF           reduce using rule 85 (return -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 85 (return -> RETURN expression SEMICOLON .)


state 119

    (46) loop_statement -> LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 144


state 120

    (48) for_statement -> FOR ID IN . range LOOP cmd_loop END LOOP SEMICOLON
    (49) range -> . NUMBER_INT DOTDOT NUMBER_INT

    NUMBER_INT      shift and go to state 146

    range                          shift and go to state 145

state 121

    (47) while_statement -> WHILE expression LOOP . cmd_loop END LOOP SEMICOLON
    (36) cmd_loop -> . cmd_loop cmd
    (37) cmd_loop -> . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 147
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 122

    (11) var -> var_loop ID COLON type .

    SEMICOLON       reduce using rule 11 (var -> var_loop ID COLON type .)


state 123

    (84) array -> TYPE ID IS ARRAY . LPAREN range RPAREN OF type

    LPAREN          shift and go to state 148


state 124

    (22) param -> ID COLON type SEMICOLON param .

    RPAREN          reduce using rule 22 (param -> ID COLON type SEMICOLON param .)


state 125

    (9) var -> ID COLON type ASSIGN term .

    SEMICOLON       reduce using rule 9 (var -> ID COLON type ASSIGN term .)


state 126

    (6) body -> BEGIN cmd_loop END ID SEMICOLON .

    FUNCTION        reduce using rule 6 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    PROCEDURE       reduce using rule 6 (body -> BEGIN cmd_loop END ID SEMICOLON .)
    $end            reduce using rule 6 (body -> BEGIN cmd_loop END ID SEMICOLON .)


state 127

    (50) assign -> ID ASSIGN op_arithmetic SEMICOLON .

    END             reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    IF              reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    PUTS            reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    RETURN          reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ID              reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    LOOP            reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    FOR             reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    WHILE           reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSIF           reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)
    ELSE            reduce using rule 50 (assign -> ID ASSIGN op_arithmetic SEMICOLON .)


state 128

    (24) function_call -> ID LPAREN param_pass RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 149


state 129

    (25) function_call -> ID LPAREN RPAREN SEMICOLON .

    END             reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    IF              reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    PUTS            reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    RETURN          reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    ID              reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    LOOP            reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    FOR             reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    WHILE           reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    ELSIF           reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)
    ELSE            reduce using rule 25 (function_call -> ID LPAREN RPAREN SEMICOLON .)


state 130

    (28) param_pass -> expression COMMA . param_pass
    (28) param_pass -> . expression COMMA param_pass
    (29) param_pass -> . expression
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    expression                     shift and go to state 97
    param_pass                     shift and go to state 150
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 131

    (39) if_statement -> IF expression THEN cmd_loop . if_statement_loop
    (36) cmd_loop -> cmd_loop . cmd
    (40) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (41) if_statement_loop -> . ELSE cmd_loop END IF SEMICOLON
    (42) if_statement_loop -> . END IF SEMICOLON
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 152
    ELSE            shift and go to state 153
    END             shift and go to state 154
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    if_statement_loop              shift and go to state 151
    cmd                            shift and go to state 59
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 132

    (51) expression -> expression AND or_exp .
    (53) or_exp -> or_exp . OR comp_exp

    THEN            reduce using rule 51 (expression -> expression AND or_exp .)
    AND             reduce using rule 51 (expression -> expression AND or_exp .)
    SEMICOLON       reduce using rule 51 (expression -> expression AND or_exp .)
    LOOP            reduce using rule 51 (expression -> expression AND or_exp .)
    COMMA           reduce using rule 51 (expression -> expression AND or_exp .)
    RPAREN          reduce using rule 51 (expression -> expression AND or_exp .)
    IF              reduce using rule 51 (expression -> expression AND or_exp .)
    PUTS            reduce using rule 51 (expression -> expression AND or_exp .)
    RETURN          reduce using rule 51 (expression -> expression AND or_exp .)
    ID              reduce using rule 51 (expression -> expression AND or_exp .)
    FOR             reduce using rule 51 (expression -> expression AND or_exp .)
    WHILE           reduce using rule 51 (expression -> expression AND or_exp .)
    OR              shift and go to state 100


state 133

    (53) or_exp -> or_exp OR comp_exp .
    (55) comp_exp -> comp_exp . comp_op op_arithmetic
    (57) comp_op -> . GREATERTHAN
    (58) comp_op -> . GREATERTHANEQUAL
    (59) comp_op -> . LESSTHAN
    (60) comp_op -> . LESSTHANEQUAL
    (61) comp_op -> . NOTEQUAL
    (62) comp_op -> . EQUAL

    OR              reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    THEN            reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    AND             reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    SEMICOLON       reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    LOOP            reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    COMMA           reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    RPAREN          reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    IF              reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    PUTS            reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    RETURN          reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    ID              reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    FOR             reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    WHILE           reduce using rule 53 (or_exp -> or_exp OR comp_exp .)
    GREATERTHAN     shift and go to state 102
    GREATERTHANEQUAL shift and go to state 103
    LESSTHAN        shift and go to state 104
    LESSTHANEQUAL   shift and go to state 105
    NOTEQUAL        shift and go to state 106
    EQUAL           shift and go to state 107

    comp_op                        shift and go to state 101

state 134

    (55) comp_exp -> comp_exp comp_op op_arithmetic .
    (63) op_arithmetic -> op_arithmetic . PLUS factor
    (64) op_arithmetic -> op_arithmetic . MINUS factor

    GREATERTHAN     reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    GREATERTHANEQUAL reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LESSTHAN        reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LESSTHANEQUAL   reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    NOTEQUAL        reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    EQUAL           reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    OR              reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    THEN            reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    AND             reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    SEMICOLON       reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    LOOP            reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    COMMA           reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    RPAREN          reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    IF              reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    PUTS            reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    RETURN          reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    ID              reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    FOR             reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    WHILE           reduce using rule 55 (comp_exp -> comp_exp comp_op op_arithmetic .)
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109


state 135

    (63) op_arithmetic -> op_arithmetic PLUS factor .
    (66) factor -> factor . TIMES power
    (67) factor -> factor . DIVIDE power

    PLUS            reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    MINUS           reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    GREATERTHAN     reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    GREATERTHANEQUAL reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    LESSTHAN        reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    LESSTHANEQUAL   reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    NOTEQUAL        reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    EQUAL           reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    OR              reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    THEN            reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    AND             reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    SEMICOLON       reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    LOOP            reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    COMMA           reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    RPAREN          reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    IF              reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    PUTS            reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    RETURN          reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    ID              reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    FOR             reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    WHILE           reduce using rule 63 (op_arithmetic -> op_arithmetic PLUS factor .)
    TIMES           shift and go to state 111
    DIVIDE          shift and go to state 112


state 136

    (64) op_arithmetic -> op_arithmetic MINUS factor .
    (66) factor -> factor . TIMES power
    (67) factor -> factor . DIVIDE power

    PLUS            reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    MINUS           reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    GREATERTHAN     reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    GREATERTHANEQUAL reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    LESSTHAN        reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    LESSTHANEQUAL   reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    NOTEQUAL        reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    EQUAL           reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    OR              reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    THEN            reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    AND             reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    SEMICOLON       reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    LOOP            reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    COMMA           reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    RPAREN          reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    IF              reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    PUTS            reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    RETURN          reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    ID              reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    FOR             reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    WHILE           reduce using rule 64 (op_arithmetic -> op_arithmetic MINUS factor .)
    TIMES           shift and go to state 111
    DIVIDE          shift and go to state 112


state 137

    (66) factor -> factor TIMES power .
    (69) power -> power . POWER unary

    TIMES           reduce using rule 66 (factor -> factor TIMES power .)
    DIVIDE          reduce using rule 66 (factor -> factor TIMES power .)
    PLUS            reduce using rule 66 (factor -> factor TIMES power .)
    MINUS           reduce using rule 66 (factor -> factor TIMES power .)
    GREATERTHAN     reduce using rule 66 (factor -> factor TIMES power .)
    GREATERTHANEQUAL reduce using rule 66 (factor -> factor TIMES power .)
    LESSTHAN        reduce using rule 66 (factor -> factor TIMES power .)
    LESSTHANEQUAL   reduce using rule 66 (factor -> factor TIMES power .)
    NOTEQUAL        reduce using rule 66 (factor -> factor TIMES power .)
    EQUAL           reduce using rule 66 (factor -> factor TIMES power .)
    OR              reduce using rule 66 (factor -> factor TIMES power .)
    THEN            reduce using rule 66 (factor -> factor TIMES power .)
    AND             reduce using rule 66 (factor -> factor TIMES power .)
    SEMICOLON       reduce using rule 66 (factor -> factor TIMES power .)
    LOOP            reduce using rule 66 (factor -> factor TIMES power .)
    COMMA           reduce using rule 66 (factor -> factor TIMES power .)
    RPAREN          reduce using rule 66 (factor -> factor TIMES power .)
    IF              reduce using rule 66 (factor -> factor TIMES power .)
    PUTS            reduce using rule 66 (factor -> factor TIMES power .)
    RETURN          reduce using rule 66 (factor -> factor TIMES power .)
    ID              reduce using rule 66 (factor -> factor TIMES power .)
    FOR             reduce using rule 66 (factor -> factor TIMES power .)
    WHILE           reduce using rule 66 (factor -> factor TIMES power .)
    POWER           shift and go to state 114


state 138

    (67) factor -> factor DIVIDE power .
    (69) power -> power . POWER unary

    TIMES           reduce using rule 67 (factor -> factor DIVIDE power .)
    DIVIDE          reduce using rule 67 (factor -> factor DIVIDE power .)
    PLUS            reduce using rule 67 (factor -> factor DIVIDE power .)
    MINUS           reduce using rule 67 (factor -> factor DIVIDE power .)
    GREATERTHAN     reduce using rule 67 (factor -> factor DIVIDE power .)
    GREATERTHANEQUAL reduce using rule 67 (factor -> factor DIVIDE power .)
    LESSTHAN        reduce using rule 67 (factor -> factor DIVIDE power .)
    LESSTHANEQUAL   reduce using rule 67 (factor -> factor DIVIDE power .)
    NOTEQUAL        reduce using rule 67 (factor -> factor DIVIDE power .)
    EQUAL           reduce using rule 67 (factor -> factor DIVIDE power .)
    OR              reduce using rule 67 (factor -> factor DIVIDE power .)
    THEN            reduce using rule 67 (factor -> factor DIVIDE power .)
    AND             reduce using rule 67 (factor -> factor DIVIDE power .)
    SEMICOLON       reduce using rule 67 (factor -> factor DIVIDE power .)
    LOOP            reduce using rule 67 (factor -> factor DIVIDE power .)
    COMMA           reduce using rule 67 (factor -> factor DIVIDE power .)
    RPAREN          reduce using rule 67 (factor -> factor DIVIDE power .)
    IF              reduce using rule 67 (factor -> factor DIVIDE power .)
    PUTS            reduce using rule 67 (factor -> factor DIVIDE power .)
    RETURN          reduce using rule 67 (factor -> factor DIVIDE power .)
    ID              reduce using rule 67 (factor -> factor DIVIDE power .)
    FOR             reduce using rule 67 (factor -> factor DIVIDE power .)
    WHILE           reduce using rule 67 (factor -> factor DIVIDE power .)
    POWER           shift and go to state 114


state 139

    (69) power -> power POWER unary .

    POWER           reduce using rule 69 (power -> power POWER unary .)
    TIMES           reduce using rule 69 (power -> power POWER unary .)
    DIVIDE          reduce using rule 69 (power -> power POWER unary .)
    PLUS            reduce using rule 69 (power -> power POWER unary .)
    MINUS           reduce using rule 69 (power -> power POWER unary .)
    GREATERTHAN     reduce using rule 69 (power -> power POWER unary .)
    GREATERTHANEQUAL reduce using rule 69 (power -> power POWER unary .)
    LESSTHAN        reduce using rule 69 (power -> power POWER unary .)
    LESSTHANEQUAL   reduce using rule 69 (power -> power POWER unary .)
    NOTEQUAL        reduce using rule 69 (power -> power POWER unary .)
    EQUAL           reduce using rule 69 (power -> power POWER unary .)
    OR              reduce using rule 69 (power -> power POWER unary .)
    THEN            reduce using rule 69 (power -> power POWER unary .)
    AND             reduce using rule 69 (power -> power POWER unary .)
    SEMICOLON       reduce using rule 69 (power -> power POWER unary .)
    LOOP            reduce using rule 69 (power -> power POWER unary .)
    COMMA           reduce using rule 69 (power -> power POWER unary .)
    RPAREN          reduce using rule 69 (power -> power POWER unary .)
    IF              reduce using rule 69 (power -> power POWER unary .)
    PUTS            reduce using rule 69 (power -> power POWER unary .)
    RETURN          reduce using rule 69 (power -> power POWER unary .)
    ID              reduce using rule 69 (power -> power POWER unary .)
    FOR             reduce using rule 69 (power -> power POWER unary .)
    WHILE           reduce using rule 69 (power -> power POWER unary .)


state 140

    (26) function_call_exp -> ID LPAREN param_pass . RPAREN

    RPAREN          shift and go to state 155


state 141

    (27) function_call_exp -> ID LPAREN RPAREN .

    POWER           reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    GREATERTHANEQUAL reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    LESSTHAN        reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    LESSTHANEQUAL   reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    EQUAL           reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    OR              reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    THEN            reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    AND             reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    LOOP            reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    IF              reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    PUTS            reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    ID              reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    FOR             reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)
    WHILE           reduce using rule 27 (function_call_exp -> ID LPAREN RPAREN .)


state 142

    (76) term -> LPAREN expression RPAREN .

    POWER           reduce using rule 76 (term -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 76 (term -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 76 (term -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 76 (term -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 76 (term -> LPAREN expression RPAREN .)
    GREATERTHAN     reduce using rule 76 (term -> LPAREN expression RPAREN .)
    GREATERTHANEQUAL reduce using rule 76 (term -> LPAREN expression RPAREN .)
    LESSTHAN        reduce using rule 76 (term -> LPAREN expression RPAREN .)
    LESSTHANEQUAL   reduce using rule 76 (term -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 76 (term -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 76 (term -> LPAREN expression RPAREN .)
    OR              reduce using rule 76 (term -> LPAREN expression RPAREN .)
    THEN            reduce using rule 76 (term -> LPAREN expression RPAREN .)
    AND             reduce using rule 76 (term -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 76 (term -> LPAREN expression RPAREN .)
    LOOP            reduce using rule 76 (term -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 76 (term -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 76 (term -> LPAREN expression RPAREN .)
    IF              reduce using rule 76 (term -> LPAREN expression RPAREN .)
    PUTS            reduce using rule 76 (term -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 76 (term -> LPAREN expression RPAREN .)
    ID              reduce using rule 76 (term -> LPAREN expression RPAREN .)
    FOR             reduce using rule 76 (term -> LPAREN expression RPAREN .)
    WHILE           reduce using rule 76 (term -> LPAREN expression RPAREN .)


state 143

    (38) puts -> PUTS LPAREN STR RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 156


state 144

    (46) loop_statement -> LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 157


state 145

    (48) for_statement -> FOR ID IN range . LOOP cmd_loop END LOOP SEMICOLON

    LOOP            shift and go to state 158


state 146

    (49) range -> NUMBER_INT . DOTDOT NUMBER_INT

    DOTDOT          shift and go to state 159


state 147

    (47) while_statement -> WHILE expression LOOP cmd_loop . END LOOP SEMICOLON
    (36) cmd_loop -> cmd_loop . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 160
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 59
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 148

    (84) array -> TYPE ID IS ARRAY LPAREN . range RPAREN OF type
    (49) range -> . NUMBER_INT DOTDOT NUMBER_INT

    NUMBER_INT      shift and go to state 146

    range                          shift and go to state 161

state 149

    (24) function_call -> ID LPAREN param_pass RPAREN SEMICOLON .

    END             reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    IF              reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    PUTS            reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    RETURN          reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ID              reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    LOOP            reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    FOR             reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    WHILE           reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ELSIF           reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)
    ELSE            reduce using rule 24 (function_call -> ID LPAREN param_pass RPAREN SEMICOLON .)


state 150

    (28) param_pass -> expression COMMA param_pass .

    RPAREN          reduce using rule 28 (param_pass -> expression COMMA param_pass .)


state 151

    (39) if_statement -> IF expression THEN cmd_loop if_statement_loop .

    END             reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    IF              reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    PUTS            reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    RETURN          reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ID              reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    LOOP            reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    FOR             reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    WHILE           reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)
    ELSE            reduce using rule 39 (if_statement -> IF expression THEN cmd_loop if_statement_loop .)


state 152

    (40) if_statement_loop -> ELSIF . expression cmd_loop if_statement_loop
    (51) expression -> . expression AND or_exp
    (52) expression -> . or_exp
    (53) or_exp -> . or_exp OR comp_exp
    (54) or_exp -> . comp_exp
    (55) comp_exp -> . comp_exp comp_op op_arithmetic
    (56) comp_exp -> . op_arithmetic
    (63) op_arithmetic -> . op_arithmetic PLUS factor
    (64) op_arithmetic -> . op_arithmetic MINUS factor
    (65) op_arithmetic -> . factor
    (66) factor -> . factor TIMES power
    (67) factor -> . factor DIVIDE power
    (68) factor -> . power
    (69) power -> . power POWER unary
    (70) power -> . unary
    (71) unary -> . PLUS term
    (72) unary -> . MINUS term
    (73) unary -> . term
    (74) term -> . ID
    (75) term -> . function_call_exp
    (76) term -> . LPAREN expression RPAREN
    (77) term -> . literal
    (26) function_call_exp -> . ID LPAREN param_pass RPAREN
    (27) function_call_exp -> . ID LPAREN RPAREN
    (78) literal -> . CHAR
    (79) literal -> . NUMBER_FLOAT
    (80) literal -> . NUMBER_INT
    (81) literal -> . STR
    (82) literal -> . TRUE
    (83) literal -> . FALSE

    PLUS            shift and go to state 66
    MINUS           shift and go to state 68
    ID              shift and go to state 72
    LPAREN          shift and go to state 74
    CHAR            shift and go to state 76
    NUMBER_FLOAT    shift and go to state 77
    NUMBER_INT      shift and go to state 78
    STR             shift and go to state 79
    TRUE            shift and go to state 80
    FALSE           shift and go to state 81

    expression                     shift and go to state 162
    or_exp                         shift and go to state 63
    comp_exp                       shift and go to state 64
    op_arithmetic                  shift and go to state 65
    factor                         shift and go to state 67
    power                          shift and go to state 69
    unary                          shift and go to state 70
    term                           shift and go to state 71
    function_call_exp              shift and go to state 73
    literal                        shift and go to state 75

state 153

    (41) if_statement_loop -> ELSE . cmd_loop END IF SEMICOLON
    (36) cmd_loop -> . cmd_loop cmd
    (37) cmd_loop -> . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 163
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 154

    (42) if_statement_loop -> END . IF SEMICOLON

    IF              shift and go to state 164


state 155

    (26) function_call_exp -> ID LPAREN param_pass RPAREN .

    POWER           reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    TIMES           reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    DIVIDE          reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    PLUS            reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    MINUS           reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    GREATERTHAN     reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    GREATERTHANEQUAL reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LESSTHAN        reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LESSTHANEQUAL   reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    NOTEQUAL        reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    EQUAL           reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    OR              reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    THEN            reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    AND             reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    SEMICOLON       reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    LOOP            reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    COMMA           reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    RPAREN          reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    IF              reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    PUTS            reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    RETURN          reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    ID              reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    FOR             reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)
    WHILE           reduce using rule 26 (function_call_exp -> ID LPAREN param_pass RPAREN .)


state 156

    (38) puts -> PUTS LPAREN STR RPAREN SEMICOLON .

    END             reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    IF              reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    PUTS            reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    RETURN          reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    ID              reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    LOOP            reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    FOR             reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    WHILE           reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    ELSIF           reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)
    ELSE            reduce using rule 38 (puts -> PUTS LPAREN STR RPAREN SEMICOLON .)


state 157

    (46) loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 46 (loop_statement -> LOOP cmd_loop END LOOP SEMICOLON .)


state 158

    (48) for_statement -> FOR ID IN range LOOP . cmd_loop END LOOP SEMICOLON
    (36) cmd_loop -> . cmd_loop cmd
    (37) cmd_loop -> . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 165
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 159

    (49) range -> NUMBER_INT DOTDOT . NUMBER_INT

    NUMBER_INT      shift and go to state 166


state 160

    (47) while_statement -> WHILE expression LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 167


state 161

    (84) array -> TYPE ID IS ARRAY LPAREN range . RPAREN OF type

    RPAREN          shift and go to state 168


state 162

    (40) if_statement_loop -> ELSIF expression . cmd_loop if_statement_loop
    (51) expression -> expression . AND or_exp
    (36) cmd_loop -> . cmd_loop cmd
    (37) cmd_loop -> . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    AND             shift and go to state 99
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd_loop                       shift and go to state 169
    cmd                            shift and go to state 31
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 163

    (41) if_statement_loop -> ELSE cmd_loop . END IF SEMICOLON
    (36) cmd_loop -> cmd_loop . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 170
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 59
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 164

    (42) if_statement_loop -> END IF . SEMICOLON

    SEMICOLON       shift and go to state 171


state 165

    (48) for_statement -> FOR ID IN range LOOP cmd_loop . END LOOP SEMICOLON
    (36) cmd_loop -> cmd_loop . cmd
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    END             shift and go to state 172
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    cmd                            shift and go to state 59
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 166

    (49) range -> NUMBER_INT DOTDOT NUMBER_INT .

    LOOP            reduce using rule 49 (range -> NUMBER_INT DOTDOT NUMBER_INT .)
    RPAREN          reduce using rule 49 (range -> NUMBER_INT DOTDOT NUMBER_INT .)


state 167

    (47) while_statement -> WHILE expression LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 173


state 168

    (84) array -> TYPE ID IS ARRAY LPAREN range RPAREN . OF type

    OF              shift and go to state 174


state 169

    (40) if_statement_loop -> ELSIF expression cmd_loop . if_statement_loop
    (36) cmd_loop -> cmd_loop . cmd
    (40) if_statement_loop -> . ELSIF expression cmd_loop if_statement_loop
    (41) if_statement_loop -> . ELSE cmd_loop END IF SEMICOLON
    (42) if_statement_loop -> . END IF SEMICOLON
    (30) cmd -> . if_statement
    (31) cmd -> . repeat_statement
    (32) cmd -> . puts
    (33) cmd -> . return
    (34) cmd -> . assign
    (35) cmd -> . function_call
    (39) if_statement -> . IF expression THEN cmd_loop if_statement_loop
    (43) repeat_statement -> . loop_statement
    (44) repeat_statement -> . for_statement
    (45) repeat_statement -> . while_statement
    (38) puts -> . PUTS LPAREN STR RPAREN SEMICOLON
    (85) return -> . RETURN expression SEMICOLON
    (50) assign -> . ID ASSIGN op_arithmetic SEMICOLON
    (24) function_call -> . ID LPAREN param_pass RPAREN SEMICOLON
    (25) function_call -> . ID LPAREN RPAREN SEMICOLON
    (46) loop_statement -> . LOOP cmd_loop END LOOP SEMICOLON
    (48) for_statement -> . FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON
    (47) while_statement -> . WHILE expression LOOP cmd_loop END LOOP SEMICOLON

    ELSIF           shift and go to state 152
    ELSE            shift and go to state 153
    END             shift and go to state 154
    IF              shift and go to state 38
    PUTS            shift and go to state 42
    RETURN          shift and go to state 43
    ID              shift and go to state 30
    LOOP            shift and go to state 44
    FOR             shift and go to state 45
    WHILE           shift and go to state 46

    if_statement_loop              shift and go to state 175
    cmd                            shift and go to state 59
    if_statement                   shift and go to state 32
    repeat_statement               shift and go to state 33
    puts                           shift and go to state 34
    return                         shift and go to state 35
    assign                         shift and go to state 36
    function_call                  shift and go to state 37
    loop_statement                 shift and go to state 39
    for_statement                  shift and go to state 40
    while_statement                shift and go to state 41

state 170

    (41) if_statement_loop -> ELSE cmd_loop END . IF SEMICOLON

    IF              shift and go to state 176


state 171

    (42) if_statement_loop -> END IF SEMICOLON .

    END             reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    IF              reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    PUTS            reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    RETURN          reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    ID              reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    LOOP            reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    FOR             reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    WHILE           reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    ELSIF           reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)
    ELSE            reduce using rule 42 (if_statement_loop -> END IF SEMICOLON .)


state 172

    (48) for_statement -> FOR ID IN range LOOP cmd_loop END . LOOP SEMICOLON

    LOOP            shift and go to state 177


state 173

    (47) while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 47 (while_statement -> WHILE expression LOOP cmd_loop END LOOP SEMICOLON .)


state 174

    (84) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF . type
    (15) type -> . BOOLEAN
    (16) type -> . CHARACTER
    (17) type -> . FLOAT
    (18) type -> . INTEGER
    (19) type -> . STRING

    BOOLEAN         shift and go to state 51
    CHARACTER       shift and go to state 52
    FLOAT           shift and go to state 53
    INTEGER         shift and go to state 54
    STRING          shift and go to state 55

    type                           shift and go to state 178

state 175

    (40) if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .

    END             reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    IF              reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    PUTS            reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    RETURN          reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ID              reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    LOOP            reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    FOR             reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    WHILE           reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSIF           reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)
    ELSE            reduce using rule 40 (if_statement_loop -> ELSIF expression cmd_loop if_statement_loop .)


state 176

    (41) if_statement_loop -> ELSE cmd_loop END IF . SEMICOLON

    SEMICOLON       shift and go to state 179


state 177

    (48) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 180


state 178

    (84) array -> TYPE ID IS ARRAY LPAREN range RPAREN OF type .

    SEMICOLON       reduce using rule 84 (array -> TYPE ID IS ARRAY LPAREN range RPAREN OF type .)


state 179

    (41) if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .

    END             reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    IF              reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    PUTS            reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    RETURN          reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    ID              reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    LOOP            reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    FOR             reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    WHILE           reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    ELSIF           reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)
    ELSE            reduce using rule 41 (if_statement_loop -> ELSE cmd_loop END IF SEMICOLON .)


state 180

    (48) for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .

    END             reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    IF              reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    PUTS            reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    RETURN          reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ID              reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    LOOP            reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    FOR             reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    WHILE           reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSIF           reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)
    ELSE            reduce using rule 48 (for_statement -> FOR ID IN range LOOP cmd_loop END LOOP SEMICOLON .)

